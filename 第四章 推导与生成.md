# 第四章 推导式与生成式

​		许多编程语言都是以处理列表、字典键值对、集合为基础的。python提供了一种特殊的语法，叫做推导式(comprehensions)，用来简单的对这些类型的数据进行遍历并创建派生数据结构。推导式能够提高执行参见任务代码的可读性并且有许多的其他的好处。

​		python将这种处理风格扩展到了带有生成器(generators)的函数，它允许函数以流的形式递增地返回数据。调用生成器函数返回的结果可以用于任何迭代器(iterator,例如loops、*号表达式)。生成器可以改善性能、减少内存的使用、提高可读性。

## 第27条 尽量使用推导式而不是map和filter

​		python为从一个序列或迭代器派生新列表提供了许多的语法。这些表达式叫做列表推导式。例如，选哟计算一个列表里面元素的平凡。这里使用了简单的loop循环：

~~~python
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
squares = []
for x in a:
squares.append(x**2)
print(squares)
>>>
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
~~~

​		这也可以使用列表推导式，通过指定需要计算的表达式和要循环序列获取相同的结果：

~~~python
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
squares = [x**2 for x in a] # List comprehension
print(squares)
>>>
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
~~~

​		除非应用的是单参数的函数，针对简单的情况，列表推导式要比内置的mao函数更加清晰。map函数需要为计算创建一个lambda函数，这看上去很复杂：

~~~python
alt = map(lambda x: x ** 2, a)
~~~

​		与map不同，列表推导式可以很简单的在输入列表时过滤元素，并从结果中删除相应的输出。例如，要计算能被2整除的数的平方。这里通过循环后的列表推导式添加一个条件表达式来实现：

~~~python
even_squares = [x**2 for x in a if x % 2 == 0]
print(even_squares)
>>>
[4, 16, 36, 64, 100]

~~~

​		也可以使用map函数与内置的filter函数实现相同的结果，但是写法很难读：

~~~python
alt = map(lambda x: x**2, filter(lambda x: x % 2 == 0, a))
assert even_squares == list(alt)
~~~

​		字典和集合也有他们自己对应的列表推导式(分别叫做字典推导式dictionary comprehensions和集合推导式set comprehensions)。这使得在编写算法时容易创建其他类型的派生数据结构。

~~~python
even_squares_dict = {x: x**2 for x in a if x % 2 == 0}
threes_cubed_set = {x**3 for x in a if x % 3 == 0}
print(even_squares_dict)
print(threes_cubed_set)
>>>
{2: 4, 4: 16, 6: 36, 8: 64, 10: 100}
{216, 729, 27}
~~~

​		通过使用相应的构造函数包装每个调用，map和filter也可以获得相同的结果。这些语句太长了，所以可能需要拆分到多行，这甚至更加麻烦，应带避免

~~~python
alt_dict = dict(map(lambda x: (x, x**2),
				filter(lambda x: x % 2 == 0, a)))
alt_set = set(map(lambda x: x**3,
				filter(lambda x: x % 3 == 0, a)))
~~~

**要点**

* 列表推导式要比map和filter这些内置函数更加简单，因为他们不需要lambda表达式
* 列表推导式允许对列表中输入的元素进行筛选，而map要实现这样的功能就必须要和filter结合使用
* 字典和集合也可以通过推导式生成

## 第28条 在推导式中避免使用两个以上的子表达式

​		除了基本的用法(参见第27条)外，推导式支持多层的循环结构。例如，要把一个元素为列表结构的列表矩阵转换成一个列表。这里，通过包含两个子表达式的列表推导式实现。这些子表达式按照写定的顺序从左往右执行：

~~~python
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flat = [x for row in matrix for x in row]
print(flat)
>>>
[1, 2, 3, 4, 5, 6, 7, 8, 9]
~~~

​		这个示例简单、可读，并且很好的展示了列表推导式中多层循环的使用。多层循环的另一个和你用法时复制输入列表的两层深度到一个列表中。例如，要计算一个二维矩阵每一个元素的平方。这个推导式比较复杂，因为多了额外的[]，但还是比较容易阅读：

~~~python
squared = [[x**2 for x in row] for row in matrix]
print(squared)
>>>
[[1, 4, 9], [16, 25, 36], [49, 64, 81]]

~~~

​		如果列表推导式包含了其他的循环，就会变得很长，就不得不拆分成多行：

~~~python
my_lists = [
    [[1, 2, 3], [4, 5, 6]],
    ...
    ]
flat = [x for sublist1 in my_lists
        for sublist2 in sublist1
        for x in sublist2]

~~~

​		在这一方面，多行推导式并不会比循环写法少多少代码。这里，使用普通循环来实现相同的效果。这个版本的缩进使得循环比商城列表推导式更加容易理解：

~~~python
flat = []
for sublist1 in my_lists:
	for sublist2 in sublist1:
		flat.extend(sublist2)

~~~

​		导式支持多层if结构。相同循环级别的多个条件具有隐式和表达式。例如，要过滤一个列表中的大于4的偶数。下面的两个列表推导式效果相同：

~~~python
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
b = [x for x in a if x > 4 if x % 2 == 0]
c = [x for x in a if x > 4 and x % 2 == 0]
~~~

​		也可以在for子表达式之后的每一级循环中指定条件。例如，要找出一个矩阵中，每一行所有元素总和大于等于10，且元素为3的整数倍的元素。虽然通过推导式来实现这个表达式并不需要多少代码，但是可读性很差：

~~~python
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
filtered = [[x for x in row if x % 3 == 0]
for row in matrix if sum(row) >= 10]
print(filtered)
>>>
[[6], [9]]

~~~

​		尽管这个示例有点复杂，但在实践中您将看到这种推导式似乎非常适合的情况。这里强烈建议你避免像这样的列表、字典或结合推导式。对于阅读代码的人来说这很难读懂。对于字典推导式，混淆的可能性更大，因为它们已经需要一个额外的参数来表示每个项的键和值。

​		这里的经验之谈是在理解过程中避免使用两个以上的控制子表达式。这可以是两个条件，两个循环，或者一个条件和一个循环。一旦它变得更复杂，您应该使用普通的if和for语句，并编写一个帮助函数。

**要点**

* 推导式支持多层循环，并对每层循环支持多个条件表达式
* 一旦推导式拥有两个以上的子表达式，就很难读，应该避免这种情况

## 第29条 避免使用赋值表达式在推导式中重复操作

​			推导式(包含列表、字典和集合变体)的参见模式时需要在多个位置引用相同的计算。例如，要写一个程序来管理一家固件公司的订单。由于新订单来自顾客，需要程序告诉我能否完成他们的订单。这就需要验证一个请求是否有足够的库存并是否超过当前运输的最低门槛：

~~~python
stock = {
    'nails': 125,
    'screws': 35,
    'wingnuts': 8,
    'washers': 24,
}
order = ['screws', 'wingnuts', 'clips']
def get_batches(count, size):
	return count // size
result = {}
for name in order:
	count = stock.get(name, 0)
batches = get_batches(count, 8)
if batches:
	result[name] = batches
print(result)
>>>
{'screws': 4, 'wingnuts': 1}
~~~

​		这里通过使用字典推导式让循环逻辑更高效(参见第27条)：

~~~python
found = {name: get_batches(stock.get(name, 0), 8)
		for name in order
   		if get_batches(stock.get(name, 0), 8)}
print(found)
>>>
{'screws': 4, 'wingnuts': 1}
~~~

​		尽管代码比较紧凑，但是问题是get_batches(stock.get(name, 0), 8) 表达式是重复的。这会增加技术上不必要的视觉干扰，从而降低了可读性。如果两个表达式没有保持同步，还会增加引入bug的可能性。例如，将第一个get_batches的第二个参数改为4，而不是8就会导致结果不同：

~~~python
has_bug = {name: get_batches(stock.get(name, 0), 4)
			for name in order
			if get_batches(stock.get(name, 0), 8)}
print('Expected:', found)
print('Found: ', has_bug)
>>>
Expected: {'screws': 4, 'wingnuts': 1}
Found: {'screws': 8, 'wingnuts': 2}

~~~

​		解决这个问题的简单方法是使用python3.8才支持的海象表达式(:=)，能够将赋值表达式编程推导式的一部分(参见第10条)

~~~python
found = {name: batches for name in order
		 if (batches := get_batches(stock.get(name, 0), 8))}
~~~

​		赋值表达式(batches := get_batches(...))允许我们在stock字典中查找订单键一次，调用get_batches一次，并将其对应的值存储在批变量中。然后，可以在推导式的其他地方引用该变量来构造字典中的内容，并且不需要二次调用get_batches。消除对get和get_batches处理的冗余调用，还可以通过通过避免对顺序列表中的每个项进行不必要的计算来提高性能。

​		将赋值表达式用到推导式的值表达式上是有效的。但是如果尝试在推导式的其他部分引用它定义的变量，可能会在运行时遇到异常，以为推导式的计算顺序不同：

~~~python
result = {name: (tenth := count // 10)
			for name, count in stock.items() if tenth > 0}
>>>
Traceback ...
NameError: name 'tenth' is not defined
~~~

​		可以通多移动赋值表达式到条件中，然后引用他在推导式中定义的变量名来修估这个示例：

~~~python
result = {name: tenth for name, count in stock.items()
			if (tenth := count // 10) > 0}
print(result)
>>>
{'nails': 12, 'screws': 3, 'washers': 2}
~~~

​		如果在推导式的赋值部分使用了海象表达式，而没有任何条件，就会让循环变量泄露到当前的作用域外(参见第21条)：

~~~python
half = [(last := count // 2) for count in stock.values()]
print(f'Last item of {half} is {last}')
>>>
Last item of [62, 17, 4, 12] is 12

~~~

​		这个循环变量泄露和普通for循环造成的结果相似：

~~~python
for count in stock.values(): # Leaks loop variable
pass
print(f'Last item of {list(stock.values())} is {count}')
>>>
Last item of [125, 35, 8, 24] is 24

~~~

​		然而，对于推导式中的循环变量，类似的泄露不会发生：

~~~python
half = [count // 2 for count in stock.values()]
print(half) # Works
print(count) # Exception because loop variable didn't leak
>>>
[62, 17, 4, 12]
Traceback ...
NameError: name 'count' is not defined

~~~

​		最好避免循环变量，建议只在推导式的条件部分使用赋值表达式。

​		是哦那个赋值表达式的操作同样适用于生成器表达式(参见第32条)。这里，创建了一个包含item名称和stock中当前计数的迭代器，而不是dict实例:

~~~python
found = ((name, batches) for name in order
			if (batches := get_batches(stock.get(name, 0), 8)))
print(next(found))
print(next(found))
>>>
('screws', 4)
('wingnuts', 1)
~~~

**要点**

* 赋值表达式使得推导式和生成器表达式可以重用同一推导式中某个条件的值，这可以提高可读性和性能
* 尽管可以在推导式表达式或生成器表达式的条件之外使用赋值表达式，但应该避免这样做。

## 第30条 使用生成器代替直接返回列表

​		对于产生结果序列函数，最简单的是返回元素组成的列表。例如，假设要找到一个字符串中各个单词的索引。这里首先使用append方法见结果追加到一个列表中，并在函数的结尾返回：

~~~python
def index_words(text):
    result = []
    if text:
    	result.append(0)
        for index, letter in enumerate(text):
        if letter == ' ':
        	result.append(index + 1)
    return result

~~~

​		这种方法能够针对一些输入样本，返回正确结果：

~~~python
address = 'Four score and seven years ago...'
result = index_words(address)
print(result[:10])
>>>
[0, 5, 11, 15, 21, 27, 31, 35, 43, 51]
~~~

​		使用这个中法有两个问题：

​		第一个问题是，代码看起来很复杂。每到有一个单词就需要调用一次append方法。

这种方法调用的bulk(result.append)弱化了要追加到列表(index +1)位置的值。一行代码用于创建结果列表，另一行用户返回结果列表。虽然函数整体包含了130多个字符(不包含空格)，但只有75个字符时重要的。

​		通过生成器(generator)来构建这个函数才是更好的方法。生成器通过使用yield关键字产生结果。这里，定义一个生成器函数来获取相同的结果：

~~~python
def index_words_iter(text):
    if text:
    	yield 0
    for index, letter in enumerate(text):
        if letter == ' ':
        yield index + 1
~~~

​		但调用函数是，生成器函数不会立即运行，而是返回一个迭代器。只有调用内置的next函数，生成器才会执行迭代器表达式。生成器传递给yield的每个值都由迭代器返回给调用者：

~~~python
it = index_words_iter(address)
print(next(it))
print(next(it))
>>>
0
5
~~~

​		index_words_iter函数非常容易阅读，因为它消除了与结果列表的所有交互。结果被传递给yield表达式代替。如果需要，可以将生成器返回的迭代器传递给列表内置函数，从而轻松地将其转换为列表(参见第32条)：

~~~python
result = list(index_words_iter(address))
print(result[:10])
>>>
[0, 5, 11, 15, 21, 27, 31, 35, 43, 51]
~~~

​		index_words函数的第二个问题是，所有需要的结果在函数返回之前都必须存储在list中。如果函数的输入值非常巨大，就可能导致内存溢出而崩溃的问题。

​		相比之下，这个函数的生成器版本就可以很容易地适应任意长度的输入，因为它的内存需求是有限的。例如，这里定义一个生成器，他从文件中一行一行的输入，并输出每一个单词：

~~~python
def index_file(handle):
    offset = 0
    for line in handle:
        if line:
        	yield offset
        for letter in line:
            offset += 1
            if letter == ' ':
            	yield offset
~~~

​		这个函数的最大工作内存就是文件中最长行长度。这个函数可以获得相同的输出(参见第36条)：

~~~python
with open('address.txt', 'r') as f:
    it = index_file(f)
    results = itertools.islice(it, 0, 10)
print(list(results))
>>>
[0, 5, 11, 15, 21, 27, 31, 35, 43, 51]
~~~

​		定义这样的生成器的唯一问题是，调用者必须知道返回的迭代器是有状态的，不能重用(参见第31条)。

**要点**

* 使用生成器比使用函数返回累积结果列表更清晰
* 生成器返回的迭代器将生成一组传递给生成器函数体中的yield表达式的值
* 生成器可以为任意大的输入产生一系列输出，因为它们的工作内存不包括所有的输入和输出

