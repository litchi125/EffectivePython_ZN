# 第四章 推导式与生成式

​		许多编程语言都是以处理列表、字典键值对、集合为基础的。python提供了一种特殊的语法，叫做推导式(comprehensions)，用来简单的对这些类型的数据进行遍历并创建派生数据结构。推导式能够提高执行参见任务代码的可读性并且有许多的其他的好处。

​		python将这种处理风格扩展到了带有生成器(generators)的函数，它允许函数以流的形式递增地返回数据。调用生成器函数返回的结果可以用于任何迭代器(iterator,例如loops、*号表达式)。生成器可以改善性能、减少内存的使用、提高可读性。

## 第27条 尽量使用推导式而不是map和filter

​		python为从一个序列或迭代器派生新列表提供了许多的语法。这些表达式叫做列表推导式。例如，选哟计算一个列表里面元素的平凡。这里使用了简单的loop循环：

~~~python
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
squares = []
for x in a:
squares.append(x**2)
print(squares)
>>>
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
~~~

​		这也可以使用列表推导式，通过指定需要计算的表达式和要循环序列获取相同的结果：

~~~python
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
squares = [x**2 for x in a] # List comprehension
print(squares)
>>>
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
~~~

​		除非应用的是单参数的函数，针对简单的情况，列表推导式要比内置的mao函数更加清晰。map函数需要为计算创建一个lambda函数，这看上去很复杂：

~~~python
alt = map(lambda x: x ** 2, a)
~~~

​		与map不同，列表推导式可以很简单的在输入列表时过滤元素，并从结果中删除相应的输出。例如，要计算能被2整除的数的平方。这里通过循环后的列表推导式添加一个条件表达式来实现：

~~~python
even_squares = [x**2 for x in a if x % 2 == 0]
print(even_squares)
>>>
[4, 16, 36, 64, 100]

~~~

​		也可以使用map函数与内置的filter函数实现相同的结果，但是写法很难读：

~~~python
alt = map(lambda x: x**2, filter(lambda x: x % 2 == 0, a))
assert even_squares == list(alt)
~~~

​		字典和集合也有他们自己对应的列表推导式(分别叫做字典推导式dictionary comprehensions和集合推导式set comprehensions)。这使得在编写算法时容易创建其他类型的派生数据结构。

~~~python
even_squares_dict = {x: x**2 for x in a if x % 2 == 0}
threes_cubed_set = {x**3 for x in a if x % 3 == 0}
print(even_squares_dict)
print(threes_cubed_set)
>>>
{2: 4, 4: 16, 6: 36, 8: 64, 10: 100}
{216, 729, 27}
~~~

​		通过使用相应的构造函数包装每个调用，map和filter也可以获得相同的结果。这些语句太长了，所以可能需要拆分到多行，这甚至更加麻烦，应带避免

~~~python
alt_dict = dict(map(lambda x: (x, x**2),
				filter(lambda x: x % 2 == 0, a)))
alt_set = set(map(lambda x: x**3,
				filter(lambda x: x % 3 == 0, a)))
~~~

**要点**

* 列表推导式要比map和filter这些内置函数更加简单，因为他们不需要lambda表达式
* 列表推导式允许对列表中输入的元素进行筛选，而map要实现这样的功能就必须要和filter结合使用
* 字典和集合也可以通过推导式生成

## 第28条 在推导式中避免使用两个以上的子表达式

​		除了基本的用法(参见第27条)外，推导式支持多层的循环结构。例如，要把一个元素为列表结构的列表矩阵转换成一个列表。这里，通过包含两个子表达式的列表推导式实现。这些子表达式按照写定的顺序从左往右执行：

~~~python
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flat = [x for row in matrix for x in row]
print(flat)
>>>
[1, 2, 3, 4, 5, 6, 7, 8, 9]
~~~

​		这个示例简单、可读，并且很好的展示了列表推导式中多层循环的使用。多层循环的另一个和你用法时复制输入列表的两层深度到一个列表中。例如，要计算一个二维矩阵每一个元素的平方。这个推导式比较复杂，因为多了额外的[]，但还是比较容易阅读：

~~~python
squared = [[x**2 for x in row] for row in matrix]
print(squared)
>>>
[[1, 4, 9], [16, 25, 36], [49, 64, 81]]

~~~

​		如果列表推导式包含了其他的循环，就会变得很长，就不得不拆分成多行：

~~~python
my_lists = [
    [[1, 2, 3], [4, 5, 6]],
    ...
    ]
flat = [x for sublist1 in my_lists
        for sublist2 in sublist1
        for x in sublist2]

~~~

​		在这一方面，多行推导式并不会比循环写法少多少代码。这里，使用普通循环来实现相同的效果。这个版本的缩进使得循环比商城列表推导式更加容易理解：

~~~python
flat = []
for sublist1 in my_lists:
	for sublist2 in sublist1:
		flat.extend(sublist2)

~~~

​		导式支持多层if结构。相同循环级别的多个条件具有隐式和表达式。例如，要过滤一个列表中的大于4的偶数。下面的两个列表推导式效果相同：

~~~python
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
b = [x for x in a if x > 4 if x % 2 == 0]
c = [x for x in a if x > 4 and x % 2 == 0]
~~~

​		也可以在for子表达式之后的每一级循环中指定条件。例如，要找出一个矩阵中，每一行所有元素总和大于等于10，且元素为3的整数倍的元素。虽然通过推导式来实现这个表达式并不需要多少代码，但是可读性很差：

~~~python
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
filtered = [[x for x in row if x % 3 == 0]
for row in matrix if sum(row) >= 10]
print(filtered)
>>>
[[6], [9]]

~~~

​		尽管这个示例有点复杂，但在实践中您将看到这种推导式似乎非常适合的情况。这里强烈建议你避免像这样的列表、字典或结合推导式。对于阅读代码的人来说这很难读懂。对于字典推导式，混淆的可能性更大，因为它们已经需要一个额外的参数来表示每个项的键和值。

​		这里的经验之谈是在理解过程中避免使用两个以上的控制子表达式。这可以是两个条件，两个循环，或者一个条件和一个循环。一旦它变得更复杂，您应该使用普通的if和for语句，并编写一个帮助函数。

**要点**

* 推导式支持多层循环，并对每层循环支持多个条件表达式
* 一旦推导式拥有两个以上的子表达式，就很难读，应该避免这种情况

