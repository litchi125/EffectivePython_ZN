# 第六章 元类和属性

​		在Python的特性列表中经常提到元类，但是很少有人知道它们在实践中实现了什么。元类这个名称含糊地暗示了一个超越类的概念。简单地说，元类允许我们拦截Python的class语句，并在每次定义一个类时提供特殊行为。

​		Python用于动态自定义属性访问的内置特性也同样神秘而强大。这些工具与Python的面向对象结构一起提供了很好的工具，可以简化从简单类到复杂类的转换。

​		然而，这些功能也带来了许多陷阱。动态属性可能会覆盖对象并导致意外的副作用。元类可以造成极其奇怪的行为，这是新手无法接近的。重要的是，您必须遵循最少惊奇原则(the rule of least surprise)，并且只使用这些机制来实现易于理解的习惯用法。

## 第44条 使用普通属性代替Setter和Getter方法

​		来自其他语言的程序员可能会自然地尝试在自己的类中实现显式的getter和setter方法:

~~~python
class OldResistor:
    def __init__(self, ohms):
    	self._ohms = ohms
    def get_ohms(self):
    	return self._ohms
    def set_ohms(self, ohms):
    	self._ohms = ohms
~~~

​		使用这些getter、setter方法很简单，当不符合python思维：

~~~python
r0 = OldResistor(50e3)
print('Before:', r0.get_ohms())
r0.set_ohms(10e3)
print('After: ', r0.get_ohms())
>>>
Before: 50000.0
After: 10000.0
~~~

​		这样的方法对于像就地递增这样的操作尤其笨拙

~~~python
r0.set_ohms(r0.get_ohms() - 4e3)
assert r0.get_ohms() == 6e3
~~~

​		然而，这些使用程序方法确实有助于定义类的接口，使其更容易封装、验证用法和定义边界。这些是设计类的重要目标，以确保类随着时间的推移类的结构不会被调用者破坏。

​		然而，在Python中，永远不需要实现显示的setter或getter方法。相反，应该始终以简单的公共属性来定义接口，就像下面这样：

~~~python
class Resistor:
    def __init__(self, ohms):
        self.ohms = ohms
        self.voltage = 0
        self.current = 0
r1 = Resistor(50e3)
r1.ohms = 10e3
~~~

​		这些属性使得像递增这样的操作很自然和清晰：

~~~python
r1.ohms += 5e3
~~~

​		以后，如果在设置属性时需要特殊的行为，可以迁移到@property装饰器(参见第26条)以及相应的setter属性。这里，定义一个新的电阻类，它允许通过分配电压属性来修改电流。但请注意，为了使此代码正常工作，setter和getter方法的名称都必须与预期的属性名称匹配：

~~~python
class VoltageResistance(Resistor):
    def __init__(self, ohms):
        super().__init__(ohms)
        self._voltage = 0
    @property
    def voltage(self):
    	return self._voltage
    @voltage.setter
    def voltage(self, voltage):
        self._voltage = voltage
        self.current = self._voltage / self.ohms
~~~

​		现在，给voltage属性赋值时，将会运行voltage setter方法，该方法反过来建辉更新对象的当前属性值：

~~~python
r2 = VoltageResistance(1e3)
print(f'Before: {r2.current:.2f} amps')
r2.voltage = 10
print(f'After: {r2.current:.2f} amps')
>>>
Before: 0.00 amps
After: 0.01 amps
~~~

​		在属性上制定setter方法能够对传给类的值进行类检查和验证。这里定义一个所有电阻值都大于等于零欧姆的类：

~~~python
class BoundedResistance(Resistor):
    def __init__(self, ohms):
        super().__init__(ohms)
    @property
    def ohms(self):
        return self._ohms
    @ohms.setter
    def ohms(self, ohms):
        if ohms <= 0:
            raise ValueError(f'ohms must be > 0; got {ohms}')
            self._ohms = ohms
~~~

​		想在，如果给定一个无效的电阻值进行实例化时，这里的装饰类property就会抛出异常：

~~~python
r3 = BoundedResistance(1e3)
r3.ohms = 0
>>>
Traceback ...
ValueError: ohms must be > 0; got 0
~~~

​		如果给这个构造函数一个无效的负数，也会抛出异常：

~~~python
BoundedResistance(-5)
>>>
Traceback ...
ValueError: ohms must be > 0; got -5
~~~

​		之所以会在这里抛出异常，是因为BoundedResistance.--init--调用了Resistor.--init--,Resistor.--init--将会给self.ohms赋值-5。这个赋值操作将会导致BoundResistacne的修饰器@ohms.setter方法被调用，并且会在对象结构被实例化前运行监测有效值的代码。

​		也可以使用@property使父类的属性不可变：

~~~python
class FixedResistance(Resistor):
    def __init__(self, ohms):
    	super().__init__(ohms)
    @property
    def ohms(self):
    	return self._ohms
    @ohms.setter
    def ohms(self, ohms):
    	if hasattr(self, '_ohms'):
    		raise AttributeError("Ohms is immutable")
		self._ohms = ohms
~~~

​		在实例化对象的构造函数后，再给被修饰的属性赋值，就会抛出异常：

~~~python
r4 = FixedResistance(1e3)
r4.ohms = 2e3
>>>
Traceback ...
AttributeError: Ohms is immutable
~~~

​		当使用@property方法实现setters和getters方法时，要确保要实现的行为在意料之内。例如，别通过修饰器的getter方法设置其他属性：

~~~python
class MysteriousResistor(Resistor):
    @property
    def ohms(self):
        self.voltage = self._ohms * self.current
        return self._ohms
    @ohms.setter
    def ohms(self, ohms):
    	self._ohms = ohms
~~~

​		在getter属性方法中设置其他属性将会导致机器怪异的结果：

~~~python
r7 = MysteriousResistor(10)
r7.current = 0.01
print(f'Before: {r7.voltage:.2f}')
r7.ohms
print(f'After: {r7.voltage:.2f}')
>>>
Before: 0.00
After: 0.10
~~~

​		最好的策略是通过@property.setter方法修改相关对象的状态。还要确保避免调用者在对象之外的地方可能带来的副作用，例如动态导入模块、缓存缓慢的辅助函数、执行I/O或者进行耗时的数据库查询等。

​		类的用户会期望他的属性像任何其他Python对象一样：快速而简单。使用常规方法来做更加复杂或更慢的事情。

​		@property的最大缺点是，属性的方法只能由子类共享。不相关的类不能共享相同的实现。然而，Python也支持描述符(参见第46条)，它支持可重用的属性逻辑和许多其他用例。

**要点**	

* 要使用简单的公用属性定义新的类接口，而不是使用setter和getter方法
* 如果需要，使用@property来定义对象属性的特殊行为
* 在@property方法中遵循最小惊奇原则，避免奇怪的副作用
* 要确保@property方法是快速的；对于慢速或者复杂的尤其是I/O操作或者会造成负影响的操作要用普通方法代替

## 第45条 考虑@property而不是重构属性

​		内置的@property装饰器使得对实例属性的简单访问变得更加容易(参见第44条)。@property修饰器的一个高级但是很常见的用法是将曾经简单的数值属性转变成动态计算。这个用法是非常有用的，因为通过该方法能够迁移类的所有现有用法，从而拥有新的行为，而不需要重写任何调用站点(如果有无法控制的调用代码，这一点就尤其重要了)。@property修饰器还在后期接口的改进方面提供了很多方便。

​		例如，假设要使用纯Python对象实现一个露桶配额。这里，Bucket类表示剩余配额的数量和配额可用的持续时间：

~~~python
from datetime import datetime, timedelta
class Bucket:
    def __init__(self, period):
        self.period_delta = timedelta(seconds=period)
        self.reset_time = datetime.now()
        self.quota = 0
    def __repr__(self):
    	return f'Bucket(quota={self.quota})'
bucket = Bucket(60)
print(bucket)
>>>
Bucket(quota=0)
~~~

​		露桶算法的工作原理是，当桶被填满时，配额的数量就不会从一个周期延续到下一个周期：

~~~python
def fill(bucket, amount):
    now = datetime.now()
    if (now - bucket.reset_time) > bucket.period_delta:
        bucket.quota = 0
        bucket.reset_time = now
    bucket.quota += amount
~~~

​		每当配额使用者想要做某事时，它必须首先确保它可以扣除所需要使用的配额数量：

~~~python
def deduct(bucket, amount):
    now = datetime.now()
    if (now - bucket.reset_time) > bucket.period_delta:
        return False # Bucket hasn't been filled this period
    if bucket.quota - amount < 0:
        return False # Bucket was filled, but not enough
    bucket.quota -= amount
    return True # Bucket had enough, quota consumed
~~~

​			为了用这个类，第一步应该把桶先填满：

~~~python
bucket = Bucket(60)
fill(bucket, 100)
print(bucket)
>>>
Bucket(quota=100)
~~~

​		然后，我们需要扣除我们的配额：

~~~python
if deduct(bucket, 99):
	print('Had 99 quota')
else:
	print('Not enough for 99 quota')
print(bucket)
>>>
Had 99 quota
Bucket(quota=1)
~~~

​		最终，由于视图扣除比配额多的数量，程序就无法进行。此时，痛的配额级别保持不变：

~~~python
if deduct(bucket, 3):
	print('Had 3 quota')
else:
	print('Not enough for 3 quota')
print(bucket)
>>>
Not enough for 3 quota
Bucket(quota=1)
~~~

​		这种实现的问题是，我永远不知道桶从哪个配额级别开始。在此期间，配额将被扣除，直到达到零。如果配额被用完了，扣除将始终返回False，直到桶被填满。当这种情况发生时，了解漏洞调用者被阻塞是因为Bucket耗尽了配额，还是因为Bucket在这段时间内从未有配额是很有用的。

​		为了解决这个问题，可改变类来追踪在周期内最大配额max_quto和消费的配额quota_consumed:

```python
class NewBucket:
    def __init__(self, period):
        self.period_delta = timedelta(seconds=period)
        self.reset_time = datetime.now()
        self.max_quota = 0
        self.quota_consumed = 0
    def __repr__(self):
        return (f'NewBucket(max_quota={self.max_quota}, '
    f'quota_consumed={self.quota_consumed})')
```

​		为了匹配原来Bucket类的前一个接口，使用@property方法实时计算运行中:的桶的配额级别：

~~~python
    @property
    def quota(self):
        return self.max_quota - self.quota_consumed
~~~

​		当配额属性被赋值时，采取一些特殊的操作来兼容fill和deduct函数对Bucket类的操作：

~~~python
	@quota.setter
    def quota(self, amount):
        delta = self.max_quota - amount
        if amount == 0:
            # Quota being reset for a new period
            self.quota_consumed = 0
            self.max_quota = 0
        elif delta < 0:
            # Quota being filled during the period
            self.max_quota = amount + self.quota_consumed
        else:
            # Quota being consumed during the period
            self.quota_consumed = delta
~~~

​		重新运行上面的演示代码会产生相同的结果：

~~~python
class NewBucket:
    def __init__(self, period):
        self.period_delta = timedelta(seconds=period)
        self.reset_time = datetime.now()
        self.max_quota = 0
        self.quota_consumed = 0

    def __repr__(self):
        return (f'NewBucket(max_quota={self.max_quota}, '
                f'quota_consumed={self.quota_consumed})')

    @property
    def quota(self):
        return self.max_quota - self.quota_consumed

    @quota.setter
    def quota(self, amount):
        delta = self.max_quota - amount
        if amount == 0:
            # Quota being reset for a new period
            self.quota_consumed = 0
            self.max_quota = 0
        elif delta < 0:
            # Quota being filled during the period
            self.max_quota = amount + self.quota_consumed
        else:
            # Quota being consumed during the period
            self.quota_consumed = delta


bucket = NewBucket(60)
print('Initial', bucket)
fill(bucket, 100)
print('Filled', bucket)
if deduct(bucket, 99):
    print('Had 99 quota')
else:
    print('Not enough for 99 quota')
print('Now', bucket)
if deduct(bucket, 3):
    print('Had 3 quota')
else:
    print('Not enough for 3 quota')
print('Still', bucket)

>>>
Initial NewBucket(max_quota=0, quota_consumed=0)
Filled NewBucket(max_quota=100, quota_consumed=0)
Had 99 quota
Now NewBucket(max_quota=100, quota_consumed=99)
Not enough for 3 quota
Still NewBucket(max_quota=100, quota_consumed=99)
~~~

​		这个代码最大的好处是使用Bucket.quota时，不需要改变或者甚至不需要了解类已经改变了。Bucket的新用法能够完成需求，并直接访问max_quota和quota_consumed。

​		作者很喜欢@property，因为他可以在后续逐步改进数据模型。阅读上面的Bucket实例，可能会认为fill和deduct应该首先作为实例方法实现。虽然你肯能是对的(参见第37条)，但是在时间中，很多情况下，类可能都是以很槽糕的接口开始的或者被作为愚蠢的数据容器。在后续代码升级迭代过程中，随着代码的增长、范围增加、多个作者共享时，就会出翔这样的情况。

​		@property是一个工具，可以帮助你解决在现实代码中遇到的问题。但是不要过度使用它。当您发现自己反复扩展@property方法时，可能是时候重构您的类，而不是进一步弥补代码的糟糕设计。

**要点**

* 使用@property为现有实例属性提供新功能
* 通过使用@property，逐步改进数据模型
* 当您发现自己过度使用@property时，请考虑重构一个类和所有调用站点

## 第46条 为可重用的@property方法提供描述符

​		内置的@property方法(参见第44条，第45条)最大的问题是重用问题。@property修饰的方法不能被同一个类的多个属性重用，也不能被不相关的类重用。

​		例如，需要这样一个类，验证一个学生家庭作业的成绩，这个成绩是个百分比：

~~~python
class Homework:
    def __init__(self):
        self._grade = 0

    @property
    def grade(self):
        return self._grade

    @grade.setter
    def grade(self, value):
        if not (0 <= value <= 100):
            raise ValueError(
                'Grade must be between 0 and 100')
        self._grade = value
~~~

​		@property将会让这个类很容易使用：

~~~python
galileo = Homework()
galileo.grade = 95
~~~

​		假设想要给该学生的考试评分，该考试有多个项目，每个项目都有单独的评分：

~~~python
class Exam:
    def __init__(self):
        self._writing_grade = 0
        self._math_grade = 0

    @staticmethod
    def _check_grade(value):
        if not (0 <= value <= 100):
            raise ValueError(
                'Grade must be between 0 and 100')
~~~

​		这很快就会变得@property乏味。对于考试的每个部分，我需要添加一个新的@property和相关验证:

```python
@property
def writing_grade(self):
    return self._writing_grade

@writing_grade.setter
def writing_grade(self, value):
    self._check_grade(value)
    self._writing_grade = value

@property
def math_grade(self):
    return self._math_grade

@math_grade.setter
def math_grade(self, value):
    self._check_grade(value)
    self._math_grade = value
```

​		并且，这种方法并不通用。如果想在家庭作业和考试之外的其他课程中重用这个百分比验证，就需要一边又一边的编写@property样板和-check_grade方法。

​		Python中解决这个问题的最好方法是使用描述符(descriptor).描述符协议定义了编程语言是如何解析属性的访问的。描述符类可以提供--get--和--set--方法，允许你在没有样板文件的情况下重用等级验证行为。出于这个目的，描述符也比混合类更好(见第41条)，因为它们允许在单个类中为许多不同的属性重用相同的逻辑。

​		这里定义一个新的叫做Exam的类，类包含Grade实例化的属性。Grade类实现了描述符协议：

~~~python
class Grade:
    def __get__(self, instance, instance_type):
    	...
    def __set__(self, instance, value):
    	...
class Exam:
    # Class attributes
    math_grade = Grade()
    writing_grade = Grade()
    science_grade = Grade()
~~~

​		在我解释Grade类是如何工作之前，理解python在Exam类中接入描述符协议的实例后，python是如何工作的尤其重要。但我分配一个属性时：

~~~python
exam = Exam()
exam.writing_grade = 40
~~~

​		它会解释成：

~~~python
Exam.__dict__['writing_grade'].__set__(exam, 40)
~~~

​		当我重写一个属性时：

~~~python
exam.writing_grade
~~~

​		它解释成：

~~~python
Exam.__dict__['writing_grade'].__get__(exam, Exam)
~~~

​		之所以会这样，是因为对象的--getattribute--方法驱动所致(常见第47条)。简而言之，当Exam实例没有叫做writing_grade的属性时，Python转而使用Exam类的属性。如果类属性是一个含有--get--和--set--方法的对象，python就会假定已经遵循了描述符协议。

​		了解了这个行为，以及我如何在作业课上使用@property进行成绩验证，下面是实现grade描述符的第一个合理尝试:

~~~python
class Grade:
    def __init__(self):
    	self._value = 0
    def __get__(self, instance, instance_type):
    	return self._value
    def __set__(self, instance, value):
    	if not (0 <= value <= 100):
            raise ValueError(
                'Grade must be between 0 and 100')
        self._value = value
~~~

​		不幸的是，这是错误的并导致了错误的行为。在一个Exam实例上访问多个属性的工作如预期的那样：

~~~python
class Exam:
    math_grade = Grade()
    writing_grade = Grade()
    science_grade = Grade()
first_exam = Exam()
first_exam.writing_grade = 82
first_exam.science_grade = 99
print('Writing', first_exam.writing_grade)
print('Science', first_exam.science_grade)
>>>
Writing 82
Science 99

~~~

​		但是在多个Exam实例上访问这些属性会导致意外的行为:

~~~python
second_exam = Exam()
second_exam.writing_grade = 75
print(f'Second {second_exam.writing_grade} is right')
print(f'First {first_exam.writing_grade} is wrong; '
f'should be 82')
>>>
Second 75 is right
First 75 is wrong; should be 82
~~~

​		问题是，类属性writing_grade的所有Exam实例共享一个Grade实例。此属性的Grade实例在程序生命周期中构造一次，即在第一次定义Exam类时，而不是在每次创建Exam实例时：

​		为了解决这个问题，需要Grade类能够检测每一个Exam实例的值。可以通过在字典中保存每个实例的状态来做到这一点：

~~~python
class Grade:
    def __init__(self):
    	self._values = {}
    def __get__(self, instance, instance_type):
        if instance is None:
    		return self
    	return self._values.get(instance, 0)
    def __set__(self, instance, value):
    	if not (0 <= value <= 100):
    		raise ValueError(
   					 'Grade must be between 0 and 100')
    		self._values[instance] = value

~~~

​		这样实现很简单，工作也很好，但是仍然有一个问题：内存泄露。在程序生命周期内，-value字典保存了对Exam实例时，--set--方法赋的值。这将导致实例的引用计数将永远不会变为零，从而阻止垃圾收集器进行垃圾清理(常见第81条)。

​		为了修复这个问题，可以使用python内置的weakref模块。这个模块提供了一个特殊的方法叫做WeakKeyDictionary可以代替记录-values的简单字典。WeakKeyDctionary的独特行为是，当Python runtime时知道它持有该实例在程序中最后剩余的引用时，从它的项目集中删除了Exam实例。Python做了记录，并确保当所有的Exam实例不再使用时_values字典将为空:

~~~python
from weakref import WeakKeyDictionary
class Grade:
    def __init__(self):
    	self._values = WeakKeyDictionary()
    def __get__(self, instance, instance_type):
    	...
    def __set__(self, instance, value):
		...
~~~

​		使用Grade描述符的这个实现，一切都如预期的那样工作:

~~~python
class Exam:
    math_grade = Grade()
    writing_grade = Grade()
    science_grade = Grade()
first_exam = Exam()
first_exam.writing_grade = 82
second_exam = Exam()
second_exam.writing_grade = 75
print(f'First {first_exam.writing_grade} is right')
print(f'Second {second_exam.writing_grade} is right')
>>>
First 82 is right
Second 75 is right
~~~

**要点**

* 通过定义自己的描述符类来重用@property方法的行为和验证
* 使用WeakKeyDictionary来确保描述符类不会导致内存泄漏
* 不要因为试图理解--getattribute--如何使用描述符协议来获取和设置属性而陷入困境

## 第47条 堕属性使用--getattr--、--getattribute--、--setattr--方法

​		python的对象钩子使得编写将系统粘在一起的通用代码变得很容易。例如，假设想要将数据库中的记录表示成python对象。数据库已经有了他的模式集。使用与这些记录对应的代码还必须知道数据库是什么样子的。然而，在python中，将python对象连接到数据库的代码不需要像是地指出记录的模式，它可以是通用的。

​		这怎么可能?普通实例属性、@property方法和描述符不能这样做，因为它们都需要预先定义。Python通过--getattr--特殊方法使这种动态行为成为可能。如果一个类定义了--getattr--，那么每当在对象的实例字典中找不到属性时，该方法就会被调用:

~~~python
class LazyRecord:
    def __init__(self):
        self.exists = 5

    def __getattr__(self, name):
        value = f'Value for {name}'
        setattr(self, name, value)
        return value
~~~

​		这里，我们访问这个丢失的属性foo。这会导致python调用上面的--getattr--方法，它会对实例字典--dict--进行转变：

~~~python
data = LazyRecord()
print('Before:', data.__dict__)
print('foo: ', data.foo)
print('After: ', data.__dict__)
>>>
Before: {'exists': 5}
foo: Value for foo
After: {'exists': 5, 'foo': 'Value for foo'}
~~~

​		这里，在LazyRecord类中添加日志记录功能，来记录--getattr--方法什么时候被调用。请注意我是如何调用super().--getattr--()来实现超类--getattr--方法获取真正的属性值并避免无限递归的(参见第40条)。

~~~python
class LoggingLazyRecord(LazyRecord):
    def __getattr__(self, name):
    	print(f'* Called __getattr__({name!r}), '
    			f'populating instance dictionary')
        result = super().__getattr__(name)
        print(f'* Returning {result!r}')
   		return result
data = LoggingLazyRecord()
print('exists: ', data.exists)
print('First foo: ', data.foo)
print('Second foo: ', data.foo)
>>>
exists:  5
* Called __getattr__('foo'), populating instance dictionary
* Returning 'Value for foo'
First foo:  Value for foo
Second foo:  Value for foo
~~~

​		exists属性存在于实例字典中，因此--getattr--不会被调用。然而，foo属性并不再实例初始化的字典中，所以第一时间会调用调用--getattr--。但是对foo调用--getattr--时也会出发--setattr--，这将在字典中填充foo。这就是为什么在第二次访问foo时，它没有记录--getattr--的调用。

​		这种行为对于像惰性访问无模式数据这样的用例是特别有用的。--getattr--运行一次来做加载属性的工作，所以后续访问都会检索现有的结果。

​		假设想要用数据库中的事务。下次用户访问属性时，想知道数据库中的记录是否仍然有效，事务是否仍然打开。--getattr--购置不会让我可靠地做到这一点，因为它会使用对象的实例字典作为现有属性的快速路径。

​		为了启用这个更高级的用例，python又另外一个对象钩子--getattrbute--。每次访问对象上的属性时都会调用此特殊方法，即使属性字典中确实存在该属性。这使我能够在每次访问属性时检查全局事务状态。需要注意的是，这样的操作可能会产生巨大的开销并对性能产生负面影响，但有时这样做是值得的。在这里，我定义ValidatingRecord来记录每次调用--getattribute--访问的日志。

~~~python
class ValidatingRecord:
    def __init__(self):
    	self.exists = 5
    def __getattribute__(self, name):
        print(f'* Called __getattribute__({name!r})')
        try:
            value = super().__getattribute__(name)
            print(f'* Found {name!r}, returning {value!r}')
            return value
        except AttributeError:
            value = f'Value for {name}'
            print(f'* Setting {name!r} to {value!r}')
            setattr(self, name, value)
            return value
data = ValidatingRecord()
print('exists: ', data.exists)
print('First foo: ', data.foo)
print('Second foo: ', data.foo)
>>>
* Called __getattribute__('exists')
* Found 'exists', returning 5
exists: 5
* Called __getattribute__('foo')
* Setting 'foo' to 'Value for foo'
First foo: Value for foo
* Called __getattribute__('foo')
* Found 'foo', returning 'Value for foo'
Second foo: Value for foo

~~~

​		如果一个动态访问的属性不应该存在，可以抛出AttributeError来导致Python标准的--getattr--和--getattribute--属性缺失行为:

~~~python
class MissingPropertyRecord:
    def __getattr__(self, name):
        if name == 'bad_name':
            raise AttributeError(f'{name} is missing')
        ...
data = MissingPropertyRecord()
data.bad_name
>>>
Traceback ...
AttributeError: bad_name is missing

~~~

​		实现泛型功能的python代码通常依赖hasattr内置函数来确定属性何时存在，并依赖于getattr内置函数来检索属性值。这些函数在调用--getattr--之前还会再实例字典中查找属性名：

~~~python
data = LoggingLazyRecord() # Implements __getattr__
print('Before: ', data.__dict__)
print('Has first foo: ', hasattr(data, 'foo'))
print('After: ', data.__dict__)
print('Has second foo: ', hasattr(data, 'foo'))
>>>
Before: {'exists': 5}
* Called __getattr__('foo'), populating instance dictionary
* Returning 'Value for foo'
Has first foo: True
After: {'exists': 5, 'foo': 'Value for foo'}
Has second foo: True
~~~

​		在上面的例子中，--getattr--只被调用了一次。相比之下，实现--getattribute--的类在实例中没使用hasattr和getattr方法时，都会调用该方法：

~~~python
data = ValidatingRecord() # Implements __getattribute__
print('Has first foo: ', hasattr(data, 'foo'))
print('Has second foo: ', hasattr(data, 'foo'))
>>>
* Called __getattribute__('foo')
* Setting 'foo' to 'Value for foo'
Has first foo: True
* Called __getattribute__('foo')
* Found 'foo', returning 'Value for foo'
Has second foo: True
~~~

​		现在，假设想要在给python对象赋值时，将汇聚延迟地推回数据库。可以用--setattr--来做这一点，这是一个类似的对象钩子，可以让你拦截任意的属性值。与使用--getattr--和--getattribute--检索属性不同，不需要两个单独的方法。每次在实例上赋值属性时，--setattr--方法总是会被调用(直接或通过setattr内置函数)：

~~~python
class SavingRecord:
    def __setattr__(self, name, value):
        # Save some data for the record
        ...
        super().__setattr__(name, value)
~~~

​		这里，定义一个日志子类SavingRecord。他的--setattr--方法会在每次定义属性时被调用：

~~~python
class LoggingSavingRecord(SavingRecord):
    def __setattr__(self, name, value):
        print(f'* Called __setattr__({name!r}, {value!r})')
        super().__setattr__(name, value)
data = LoggingSavingRecord()
print('Before: ', data.__dict__)
data.foo = 5
print('After: ', data.__dict__)
data.foo = 7
print('Finally:', data.__dict__)
>>>
Before: {}
* Called __setattr__('foo', 5)
After: {'foo': 5}
* Called __setattr__('foo', 7)
Finally: {'foo': 7}
~~~

​		--getattribute--和--setattr--的问题是，他们会在对象每个属性访问时被调用，即便这不是所想要的。例如，假设想要我的对象上的属性访问来实际查找关联字典中的键：

~~~python
class BrokenDictionaryRecord:
    def __init__(self, data):
    	self._data = {}
    def __getattribute__(self, name):
        print(f'* Called __getattribute__({name!r})')
        return self._data[name]

~~~

​		则需要访问--getattribute--方法的self.data。

​		然而，如果这样这么做，python会递归到它的堆栈极限，直到最终死亡：

~~~python
data = BrokenDictionaryRecord({'foo': 3})
data.foo
>>>
* Called __getattribute__('foo')
* Called __getattribute__('_data')
* Called __getattribute__('_data')
* Called __getattribute__('_data')
...
Traceback ...
RecursionError: maximum recursion depth exceeded while
calling
➥ a Python object
~~~

​		问题是--getattribute--会访问self.data，这将会导致--getattribute--再次运行，紧接着访问self.data，依次陷入死循环。解决方法是使用super().--getattribute--方法从实例的属性字典中取值。这样将会避免递归：

~~~python
class DictionaryRecord:
    def __init__(self, data):
    	self._data = data
    def __getattribute__(self, name):
        print(f'* Called __getattribute__({name!r})')
        data_dict = super().__getattribute__('_data')
        return data_dict[name]
data = DictionaryRecord({'foo': 3})
print('foo: ', data.foo)
>>>
* Called __getattribute__('foo')
foo: 3
~~~

​		通过--setattr--方法修改对象的属性也需要使用super().--setattr--。

**要点**

* 使用--getattr--和--setattr--惰性加载和保存一个对象的属性
* 理解--getattr--只在访问丢失的属性时被调用，而--getattribute--在每次访问任何属性时被调用
* 使用super()(即对象类)的方法来访问实例属性，避免--getattribute--和--setattr--中的无限递归。

## 第48条 使用__init_subclass__验证子类

​		元类最简单的应用之一是验证一个类是否被正确定义。在构建复杂的类层次结构时，可能需要用到强制类型、要求重写方法或类属性之间具有严格的关系。元类通过在每次定义一个新的子类时，提供一种可靠的方式来运行验证代码解决这心情况。

​		当对象被实例化时，类的检测代码通常在--init--方法中运行。使用元类进行验证可能会在更早的时候抛出异常，比如当包含该类的模块在程序的开始首次被导入的时候。

​		在讨论定义用于验证子类的元类之前，理解标准对象的元类操作是很重要的。元类是通过继承type来定义的。在默认情况下，元类在--new--方法中接收相关类语句的内容。在这里，可以在实际构造type之前检查和修改类信息：

~~~python
class Meta(type):
    def __new__(meta, name, bases, class_dict):
        print(f'* Running {meta}.__new__ for {name}')
        print('Bases:', bases)
        print(class_dict)
        return type.__new__(meta, name, bases, class_dict)
class MyClass(metaclass=Meta):
    stuff = 123
    def foo(self):
    	pass
class MySubclass(MyClass):
    other = 567
    def bar(self):
    	pass 
~~~

​		元类可以访问类的名称、它继承的父类(基类)以及类主题定义的所有属性。所有类都继承自object，所以他不会显示第列在基类的元组中：

~~~python
>>>
* Running <class '__main__.Meta'>.__new__ for MyClass
Bases: ()
{'__module__': '__main__',
'__qualname__': 'MyClass',
'stuff': 123,
'foo': <function MyClass.foo at 0x105a05280>}
* Running <class '__main__.Meta'>.__new__ for MySubclass
Bases: (<class '__main__.MyClass'>,)
{'__module__': '__main__',
'__qualname__': 'MySubclass',
'other': 567,
'bar': <function MySubclass.bar at 0x105a05310>}

~~~

​		可以在Meta.--new--添加一些功能，一边在定义关联类之前验证它所有的参数。例如，假设想表示任何类型的多边形的内角和。可以通过定义一个特殊的验证元类并在多边形层次结构的基类中使用它来实现这一点。请注意吗，不要对基类引用相同的验证：

~~~python
class ValidatePolygon(type):
    def __new__(meta, name, bases, class_dict):
        # Only validate subclasses of the Polygon class
        if bases:
            if class_dict['sides'] < 3:
                raise ValueError('Polygons need 3+ sides')
        return type.__new__(meta, name, bases, class_dict)


class Polygon(metaclass=ValidatePolygon):
    sides = None  # Must be specified by subclasses

    @classmethod
    def interior_angles(cls):
        return (cls.sides - 2) * 180


class Triangle(Polygon):
    sides = 3


class Rectangle(Polygon):
    sides = 4


class Nonagon(Polygon):
    sides = 9


assert Triangle.interior_angles() == 180
assert Rectangle.interior_angles() == 360
assert Nonagon.interior_angles() == 1260

~~~

​			如果尝试定义一个少于三条边的多边形，验证将导致类语句在类语句体之后立即失败。这意味这，程序甚至不能开始运行(除非定义一个动态导入模型，参见第88条)：

~~~python
class Line(Polygon):
    print('Before sides')
    sides = 2
    print('After sides')


print('After class')
>>>
Traceback (most recent call last):
  File "D:/PyCharm_pro/effective_python/NO41/test.py", line 42, in <module>
    class Line(Polygon):
  File "D:/PyCharm_pro/effective_python/NO41/test.py", line 15, in __new__
    raise ValueError('Polygons need 3+ sides')
ValueError: Polygons need 3+ sides
Before class
Before sides
After sides
~~~

​		为了让python完成这样一个基本的任务，这似乎需要更加智能一些。幸运的是，python3.6引入了简单的语法--init-subclass--，以避免元类的同时实现相同的功能。这里，使用这种机制来提供与之前同级别的验证：

~~~python
class BetterPolygon:
    sides = None # Must be specified by subclasses
    def __init_subclass__(cls):
        super().__init_subclass__()
        if cls.sides < 3:
            raise ValueError('Polygons need 3+ sides')
    @classmethod
    def interior_angles(cls):
        return (cls.sides - 2) * 180
class Hexagon(BetterPolygon):
    sides = 6
assert Hexagon.interior_angles() == 720
~~~

​		代码现在就很简单了，并且ValidatePolygon元类完全消失了。它也更容易理解，因为可以在--init-subclass--中直接访问cls实例的sides属性，而不必须使用class_dict['sides']进入类的字典。如果定义BetterPolygon的一个无效的子类，同样异常会被抛出：

~~~python
print('Before class')
class Point(BetterPolygon):
	sides = 1
print('After class')
>>>
Before class
Traceback (most recent call last):
  File "D:/PyCharm_pro/effective_python/NO41/test.py", line 51, in <module>
    class Point(BetterPolygon):
  File "D:/PyCharm_pro/effective_python/NO41/test.py", line 44, in __init_subclass__
    raise ValueError('Polygons need 3+ sides')
ValueError: Polygons need 3+ sides
~~~

​		标准python元类机制的另一个问题是，每个类定义只能指定一个元类。在这里，定义第二个元类，用它来验证一个区域(不只是多边形)的填充颜色：

~~~python
class ValidateFilled(type):
    def __new__(meta, name, bases, class_dict):
        # Only validate subclasses of the Filled class
        if bases:
            if class_dict['color'] not in ('red', 'green'):
                raise ValueError('Fill color must be supported')
        return type.__new__(meta, name, bases, class_dict)
class Filled(metaclass=ValidateFilled):
    color = None # Must be specified by subclasses
~~~

​		当尝试一起使用Polygon元类和Filled元类时，就会抛出一个神秘的错误消息：

~~~python
class RedPentagon(Filled, Polygon):
    color = 'red'
    sides = 5
>>>
Traceback (most recent call last):
  File "D:/PyCharm_pro/effective_python/NO41/test.py", line 65, in <module>
    class RedPentagon(Filled, Polygon):
TypeError: metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
~~~

​		可以通过创建复杂的元类类型定义层次结构来进行验证解决这个问题：

~~~python
class ValidatePolygon(type):
    def __new__(meta, name, bases, class_dict):
        # Only validate non-root classes
        if not class_dict.get('is_root'):
            if class_dict['sides'] < 3:
                raise ValueError('Polygons need 3+ sides')

        return type.__new__(meta, name, bases, class_dict)


class Polygon(metaclass=ValidatePolygon):
    is_root = True
    sides = None  # Must be specified by subclasses


class ValidateFilledPolygon(ValidatePolygon):
    def __new__(meta, name, bases, class_dict):
        # Only validate non-root classes
        if not class_dict.get('is_root'):
            if class_dict['color'] not in ('red', 'green'):
                raise ValueError('Fill color must be supported')

        return super().__new__(meta, name, bases, class_dict)


class FilledPolygon(Polygon, metaclass=ValidateFilledPolygon):
    is_root = True
    color = None  # Must be specified by subclasses
~~~

​		这需要把每一个FilledPolygon实例转换成Polygon实例：

~~~python
class GreenPentagon(FilledPolygon):
    color = 'green'
    sides = 5
greenie = GreenPentagon()
assert isinstance(greenie, Polygon)

~~~

​		检测颜色时候工作正常：

~~~python
class OrangePentagon(FilledPolygon):
    color = 'orange'
    sides = 5
>>>
Traceback (most recent call last):
  File "D:/PyCharm_pro/effective_python/NO41/test.py", line 99, in <module>
    class OrangePentagon(FilledPolygon):
  File "D:/PyCharm_pro/effective_python/NO41/test.py", line 89, in __new__
    raise ValueError('Fill color must be supported')
ValueError: Fill color must be supported
~~~

​		检测边数时候工作正常：

~~~python
class RedLine(FilledPolygon):
    color = 'red'
    sides = 2
>>>
Traceback (most recent call last):
  File "D:/PyCharm_pro/effective_python/NO41/test.py", line 99, in <module>
    class RedLine(FilledPolygon):
  File "D:/PyCharm_pro/effective_python/NO41/test.py", line 91, in __new__
    return super().__new__(meta, name, bases, class_dict)
  File "D:/PyCharm_pro/effective_python/NO41/test.py", line 74, in __new__
    raise ValueError('Polygons need 3+ sides')
ValueError: Polygons need 3+ sides
~~~

​		然而，这种方法破坏了可组合型，而这正是此类验证的目的(参见第41条)。如果想要将ValidateFilledPolygon的颜色验证逻辑应用到另一个类的层次结构中，不得不再次复制所有的逻辑，这减少了代码重用并增加了样板文件。

​		--init-subclass--这个特殊的类方法也可以用于解决这样的问题。只要super内置函数被用来调用任何父类或兄弟类的--init-subclass--定义，它就可以被类层次结构的多个级别定义(参见第40条)。它甚至于多层继承兼容。在这里没定义一个类表示区域填充颜色，可以与之前的BetterPolygon类组合：

~~~python
class Filled:
    color = None # Must be specified by subclasses
    def __init_subclass__(cls):
        super().__init_subclass__()
        if cls.color not in ('red', 'green', 'blue'):
            raise ValueError('Fills need a valid color')
~~~

​		可以从这两个类继承来定义一个新类。两个类都调用super().--init-subclass--，从而参见子类时运行相应的验证逻辑：

~~~python
class RedTriangle(Filled, Polygon):
    color = 'red'
    sides = 3


ruddy = RedTriangle()
assert isinstance(ruddy, Filled)
assert isinstance(ruddy, Polygon)
~~~

​		如果指定的边数不正确，将会得到一个验证错误：

~~~python
print('Before class')
class BlueLine(Filled, Polygon):
    color = 'blue'
    sides = 2
print('After class')
>>>
Before class
Traceback (most recent call last):
  File "D:/PyCharm_pro/effective_python/NO41/test.py", line 112, in <module>
    class BlueLine(Filled, Polygon):
  File "D:/PyCharm_pro/effective_python/NO41/test.py", line 74, in __new__
    raise ValueError('Polygons need 3+ sides')
ValueError: Polygons need 3+ sides
~~~

​		如果指定的颜色不正确，将会得到一个验证错误：

~~~python
print('Before class')
class BeigeSquare(Filled, Polygon):
    color = 'beige'
    sides = 4
print('After class')
>>>
Before class
Traceback (most recent call last):
  File "D:/PyCharm_pro/effective_python/NO41/test.py", line 112, in <module>
    class BeigeSquare(Filled, Polygon):
  File "D:/PyCharm_pro/effective_python/NO41/test.py", line 76, in __new__
    return type.__new__(meta, name, bases, class_dict)
  File "D:/PyCharm_pro/effective_python/NO41/test.py", line 104, in __init_subclass__
    raise ValueError('Fills need a valid color')
ValueError: Fills need a valid color
~~~

​		甚至可以在复杂的情况下使用--init-subclass--，比如菱形继承(参见第40条)。在这里，定义个基本的菱形层次结构来显示它的实际作用：

~~~python
class Top:
    def __init_subclass__(cls):
        super().__init_subclass__()
        print(f'Top for {cls}')
class Left(Top):
    def __init_subclass__(cls):
        super().__init_subclass__()
        print(f'Left for {cls}')
class Right(Top):
    def __init_subclass__(cls):
        super().__init_subclass__()
        print(f'Right for {cls}')
class Bottom(Left, Right):
    def __init_subclass__(cls):
        super().__init_subclass__()
        print(f'Bottom for {cls}')
>>>
Top for <class '__main__.Left'>
Top for <class '__main__.Right'>
Top for <class '__main__.Bottom'>
Right for <class '__main__.Bottom'>
Left for <class '__main__.Bottom'>
~~~

​		像预期的一样，Top.--init-subclass--在每个类中都被调用了依次，尽管从Bottom类到其父类有Left和Right两条路径。

**要点**

* 元类的--new--方法在类语句的整个语句体被处理之后运行
* 元类可以用于在类定义之后、创建之前检查或修改类，但它们通常比您需要的更重要
* 使用--init-subclass--来确保子类在定义时，在构造其类型的对象之前是良好的结构
* 在定义的类的--init-subclass--方法中，一定要调用super().--init-subclass--，以便能在类的多层结构或多重继承中启用验证

