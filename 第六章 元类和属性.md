# 第六章 元类和属性

​		在Python的特性列表中经常提到元类，但是很少有人知道它们在实践中实现了什么。元类这个名称含糊地暗示了一个超越类的概念。简单地说，元类允许我们拦截Python的class语句，并在每次定义一个类时提供特殊行为。

​		Python用于动态自定义属性访问的内置特性也同样神秘而强大。这些工具与Python的面向对象结构一起提供了很好的工具，可以简化从简单类到复杂类的转换。

​		然而，这些功能也带来了许多陷阱。动态属性可能会覆盖对象并导致意外的副作用。元类可以造成极其奇怪的行为，这是新手无法接近的。重要的是，您必须遵循最少惊奇原则(the rule of least surprise)，并且只使用这些机制来实现易于理解的习惯用法。

## 第44条 使用普通属性代替Setter和Getter方法

​		来自其他语言的程序员可能会自然地尝试在自己的类中实现显式的getter和setter方法:

~~~python
class OldResistor:
    def __init__(self, ohms):
    	self._ohms = ohms
    def get_ohms(self):
    	return self._ohms
    def set_ohms(self, ohms):
    	self._ohms = ohms
~~~

​		使用这些getter、setter方法很简单，当不符合python思维：

~~~python
r0 = OldResistor(50e3)
print('Before:', r0.get_ohms())
r0.set_ohms(10e3)
print('After: ', r0.get_ohms())
>>>
Before: 50000.0
After: 10000.0
~~~

​		这样的方法对于像就地递增这样的操作尤其笨拙

~~~python
r0.set_ohms(r0.get_ohms() - 4e3)
assert r0.get_ohms() == 6e3
~~~

​		然而，这些使用程序方法确实有助于定义类的接口，使其更容易封装、验证用法和定义边界。这些是设计类的重要目标，以确保类随着时间的推移类的结构不会被调用者破坏。

​		然而，在Python中，永远不需要实现显示的setter或getter方法。相反，应该始终以简单的公共属性来定义接口，就像下面这样：

~~~python
class Resistor:
    def __init__(self, ohms):
        self.ohms = ohms
        self.voltage = 0
        self.current = 0
r1 = Resistor(50e3)
r1.ohms = 10e3
~~~

​		这些属性使得像递增这样的操作很自然和清晰：

~~~python
r1.ohms += 5e3
~~~

​		以后，如果在设置属性时需要特殊的行为，可以迁移到@property装饰器(参见第26条)以及相应的setter属性。这里，定义一个新的电阻类，它允许通过分配电压属性来修改电流。但请注意，为了使此代码正常工作，setter和getter方法的名称都必须与预期的属性名称匹配：

~~~python
class VoltageResistance(Resistor):
    def __init__(self, ohms):
        super().__init__(ohms)
        self._voltage = 0
    @property
    def voltage(self):
    	return self._voltage
    @voltage.setter
    def voltage(self, voltage):
        self._voltage = voltage
        self.current = self._voltage / self.ohms
~~~

​		现在，给voltage属性赋值时，将会运行voltage setter方法，该方法反过来建辉更新对象的当前属性值：

~~~python
r2 = VoltageResistance(1e3)
print(f'Before: {r2.current:.2f} amps')
r2.voltage = 10
print(f'After: {r2.current:.2f} amps')
>>>
Before: 0.00 amps
After: 0.01 amps
~~~

​		在修饰器中指定setter还能够使我们能够对传递给类的值进行类型检查和验证。在这里，定义呢一个确保所有电阻值都大于零欧姆的类：

~~~python
class BoundedResistance(Resistor):
    def __init__(self, ohms):
    	super().__init__(ohms)
    @property
    def ohms(self):
        return self._ohms
    @ohms.setter
    def ohms(self, ohms):
        if ohms <= 0:
        	raise ValueError(f'ohms must be > 0; got {ohms}')
        self._ohms = ohms


~~~

​		为属性赋一个无效的值将会引发异常：

~~~python
r3 = BoundedResistance(1e3)
r3.ohms = 0
>>>
Traceback ...
ValueError: ohms must be > 0; got 0
~~~

​		如果向构造函数传递一个无效值，也会引发异常：

~~~python
BoundedResistance(-5)
>>>
Traceback ...
ValueError: ohms must be > 0; got -5
~~~

​		之所以会发生这，是因为BoundedResistance.--init--调用了Resistor.--init--，这个方法将会给self.--ohms--赋值为5.这样的一个赋值操作将会导致BoundedResistance的修饰器ohms的setter方法被调用，并在对象构造完成之前立即验证代码。

​		甚至可以通过使用修饰器使父类的属性不可变：

~~~python
class FixedResistance(Resistor):
    def __init__(self, ohms):
    	super().__init__(ohms)
    @property
    def ohms(self):
    	return self._ohms
    @ohms.setter
    def ohms(self, ohms):
    	if hasattr(self, '_ohms'):
    		raise AttributeError("Ohms is immutable")
        self._ohms = ohms
~~~

​		如果试图在构造完成后对属性进行赋值将会引发异常：

​		当使用修饰器方法来实现setter和getter方法时，要确保实现的行为是情理之中的。例如，不要再getter属性方法中设置其他的属性：

~~~python
class MysteriousResistor(Resistor):
    @property
    def ohms(self):
        self.voltage = self._ohms * self.current
        return self._ohms
    @ohms.setter
    def ohms(self, ohms):
    	self._ohms = ohms
~~~

​		在getter属性方法中设置其他属性会导致极其奇怪的行为:

~~~python
r7 = MysteriousResistor(10)
r7.current = 0.01
print(f'Before: {r7.voltage:.2f}')
r7.ohms
print(f'After: {r7.voltage:.2f}')
>>>
Before: 0.00
After: 0.10
~~~

​		最好的策略是仅在修饰器@property的setter方法中修改相关对象状态。还要确保避免调用者在对象之外可能不会想到的任何其他副作用，比如动态导入模块、运行缓慢的辅助函数、执行I/O操作或进行耗时的数据库查询：

​		类的调用者期望他的属性像任何其他python对象一样：快速而简单。推荐使用常规方法来做更复杂或更慢的事情。

​		修饰器的最大缺点是，属性的方法只能由子类共享，不相关的类不能共享相同的实现。然而，python也会支持描述符(常见第46条)，它支持可重用的属性逻辑和其他许多用例。

**要点**

* 使用简单的公共属性定义新的类接口，避免定义setter和getter方法
* 如果需要，使用修饰器@property来定义访问对象属性时的特殊行为
* 在@property方法中要遵循最小惊奇原则，避免奇怪的副作用
* 确保@property方法是快速的;对于缓慢或复杂的工作，特别是涉及I/O或引起副作用的工作，使用普通方法代替



