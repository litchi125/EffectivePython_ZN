# 第六章 元类和属性

​		在Python的特性列表中经常提到元类，但是很少有人知道它们在实践中实现了什么。元类这个名称含糊地暗示了一个超越类的概念。简单地说，元类允许我们拦截Python的class语句，并在每次定义一个类时提供特殊行为。

​		Python用于动态自定义属性访问的内置特性也同样神秘而强大。这些工具与Python的面向对象结构一起提供了很好的工具，可以简化从简单类到复杂类的转换。

​		然而，这些功能也带来了许多陷阱。动态属性可能会覆盖对象并导致意外的副作用。元类可以造成极其奇怪的行为，这是新手无法接近的。重要的是，您必须遵循最少惊奇原则(the rule of least surprise)，并且只使用这些机制来实现易于理解的习惯用法。

## 第44条 使用普通属性代替Setter和Getter方法

​		来自其他语言的程序员可能会自然地尝试在自己的类中实现显式的getter和setter方法:

~~~python
class OldResistor:
    def __init__(self, ohms):
    	self._ohms = ohms
    def get_ohms(self):
    	return self._ohms
    def set_ohms(self, ohms):
    	self._ohms = ohms
~~~

​		使用这些getter、setter方法很简单，当不符合python思维：

~~~python
r0 = OldResistor(50e3)
print('Before:', r0.get_ohms())
r0.set_ohms(10e3)
print('After: ', r0.get_ohms())
>>>
Before: 50000.0
After: 10000.0
~~~

​		这样的方法对于像就地递增这样的操作尤其笨拙

~~~python
r0.set_ohms(r0.get_ohms() - 4e3)
assert r0.get_ohms() == 6e3
~~~

​		然而，这些使用程序方法确实有助于定义类的接口，使其更容易封装、验证用法和定义边界。这些是设计类的重要目标，以确保类随着时间的推移类的结构不会被调用者破坏。

​		然而，在Python中，永远不需要实现显示的setter或getter方法。相反，应该始终以简单的公共属性来定义接口，就像下面这样：

~~~python
class Resistor:
    def __init__(self, ohms):
        self.ohms = ohms
        self.voltage = 0
        self.current = 0
r1 = Resistor(50e3)
r1.ohms = 10e3
~~~

​		这些属性使得像递增这样的操作很自然和清晰：

~~~python
r1.ohms += 5e3
~~~

​		以后，如果在设置属性时需要特殊的行为，可以迁移到@property装饰器(参见第26条)以及相应的setter属性。这里，定义一个新的电阻类，它允许通过分配电压属性来修改电流。但请注意，为了使此代码正常工作，setter和getter方法的名称都必须与预期的属性名称匹配：

~~~python
class VoltageResistance(Resistor):
    def __init__(self, ohms):
        super().__init__(ohms)
        self._voltage = 0
    @property
    def voltage(self):
    	return self._voltage
    @voltage.setter
    def voltage(self, voltage):
        self._voltage = voltage
        self.current = self._voltage / self.ohms
~~~

​		现在，给voltage属性赋值时，将会运行voltage setter方法，该方法反过来建辉更新对象的当前属性值：

~~~python
r2 = VoltageResistance(1e3)
print(f'Before: {r2.current:.2f} amps')
r2.voltage = 10
print(f'After: {r2.current:.2f} amps')
>>>
Before: 0.00 amps
After: 0.01 amps
~~~

​		在属性上制定setter方法能够对传给类的值进行类检查和验证。这里定义一个所有电阻值都大于等于零欧姆的类：

~~~python
class BoundedResistance(Resistor):
    def __init__(self, ohms):
        super().__init__(ohms)
    @property
    def ohms(self):
        return self._ohms
    @ohms.setter
    def ohms(self, ohms):
        if ohms <= 0:
            raise ValueError(f'ohms must be > 0; got {ohms}')
            self._ohms = ohms
~~~

​		想在，如果给定一个无效的电阻值进行实例化时，这里的装饰类property就会抛出异常：

~~~python
r3 = BoundedResistance(1e3)
r3.ohms = 0
>>>
Traceback ...
ValueError: ohms must be > 0; got 0
~~~

​		如果给这个构造函数一个无效的负数，也会抛出异常：

~~~python
BoundedResistance(-5)
>>>
Traceback ...
ValueError: ohms must be > 0; got -5
~~~

​		之所以会在这里抛出异常，是因为BoundedResistance.--init--调用了Resistor.--init--,Resistor.--init--将会给self.ohms赋值-5。这个赋值操作将会导致BoundResistacne的修饰器@ohms.setter方法被调用，并且会在对象结构被实例化前运行监测有效值的代码。

​		也可以使用@property使父类的属性不可变：

~~~python
class FixedResistance(Resistor):
    def __init__(self, ohms):
    	super().__init__(ohms)
    @property
    def ohms(self):
    	return self._ohms
    @ohms.setter
    def ohms(self, ohms):
    	if hasattr(self, '_ohms'):
    		raise AttributeError("Ohms is immutable")
		self._ohms = ohms
~~~

​		在实例化对象的构造函数后，再给被修饰的属性赋值，就会抛出异常：

~~~python
r4 = FixedResistance(1e3)
r4.ohms = 2e3
>>>
Traceback ...
AttributeError: Ohms is immutable
~~~

​		当使用@property方法实现setters和getters方法时，要确保要实现的行为在意料之内。例如，别通过修饰器的getter方法设置其他属性：

~~~python
class MysteriousResistor(Resistor):
    @property
    def ohms(self):
        self.voltage = self._ohms * self.current
        return self._ohms
    @ohms.setter
    def ohms(self, ohms):
    	self._ohms = ohms
~~~

​		在getter属性方法中设置其他属性将会导致机器怪异的结果：

~~~python
r7 = MysteriousResistor(10)
r7.current = 0.01
print(f'Before: {r7.voltage:.2f}')
r7.ohms
print(f'After: {r7.voltage:.2f}')
>>>
Before: 0.00
After: 0.10
~~~

​		最好的策略是通过@property.setter方法修改相关对象的状态。还要确保避免调用者在对象之外的地方可能带来的副作用，例如动态导入模块、缓存缓慢的辅助函数、执行I/O或者进行耗时的数据库查询等。

​		类的用户会期望他的属性像任何其他Python对象一样：快速而简单。使用常规方法来做更加复杂或更慢的事情。

​		@property的最大缺点是，属性的方法只能由子类共享。不相关的类不能共享相同的实现。然而，Python也支持描述符(参见第46条)，它支持可重用的属性逻辑和许多其他用例。

**要点**	

* 要使用简单的公用属性定义新的类接口，而不是使用setter和getter方法
* 如果需要，使用@property来定义对象属性的特殊行为
* 在@property方法中遵循最小惊奇原则，避免奇怪的副作用
* 要确保@property方法是快速的；对于慢速或者复杂的尤其是I/O操作或者会造成负影响的操作要用普通方法代替

## 第45条 考虑@property而不是重构属性

​		内置的@property装饰器使得对实例属性的简单访问变得更加容易(参见第44条)。@property修饰器的一个高级但是很常见的用法是将曾经简单的数值属性转变成动态计算。这个用法是非常有用的，因为通过该方法能够迁移类的所有现有用法，从而拥有新的行为，而不需要重写任何调用站点(如果有无法控制的调用代码，这一点就尤其重要了)。@property修饰器还在后期接口的改进方面提供了很多方便。

​		例如，假设要使用纯Python对象实现一个露桶配额。这里，Bucket类表示剩余配额的数量和配额可用的持续时间：

~~~python
from datetime import datetime, timedelta
class Bucket:
    def __init__(self, period):
        self.period_delta = timedelta(seconds=period)
        self.reset_time = datetime.now()
        self.quota = 0
    def __repr__(self):
    	return f'Bucket(quota={self.quota})'
bucket = Bucket(60)
print(bucket)
>>>
Bucket(quota=0)
~~~

​		露桶算法的工作原理是，当桶被填满时，配额的数量就不会从一个周期延续到下一个周期：

~~~python
def fill(bucket, amount):
    now = datetime.now()
    if (now - bucket.reset_time) > bucket.period_delta:
        bucket.quota = 0
        bucket.reset_time = now
    bucket.quota += amount
~~~

​		每当配额使用者想要做某事时，它必须首先确保它可以扣除所需要使用的配额数量：

~~~python
def deduct(bucket, amount):
    now = datetime.now()
    if (now - bucket.reset_time) > bucket.period_delta:
        return False # Bucket hasn't been filled this period
    if bucket.quota - amount < 0:
        return False # Bucket was filled, but not enough
    bucket.quota -= amount
    return True # Bucket had enough, quota consumed
~~~

​			为了用这个类，第一步应该把桶先填满：

~~~python
bucket = Bucket(60)
fill(bucket, 100)
print(bucket)
>>>
Bucket(quota=100)
~~~

​		然后，我们需要扣除我们的配额：

~~~python
if deduct(bucket, 99):
	print('Had 99 quota')
else:
	print('Not enough for 99 quota')
print(bucket)
>>>
Had 99 quota
Bucket(quota=1)
~~~

​		最终，由于视图扣除比配额多的数量，程序就无法进行。此时，痛的配额级别保持不变：

~~~python
if deduct(bucket, 3):
	print('Had 3 quota')
else:
	print('Not enough for 3 quota')
print(bucket)
>>>
Not enough for 3 quota
Bucket(quota=1)
~~~

​		这种实现的问题是，我永远不知道桶从哪个配额级别开始。在此期间，配额将被扣除，直到达到零。如果配额被用完了，扣除将始终返回False，直到桶被填满。当这种情况发生时，了解漏洞调用者被阻塞是因为Bucket耗尽了配额，还是因为Bucket在这段时间内从未有配额是很有用的。

​		为了解决这个问题，可改变类来追踪在周期内最大配额max_quto和消费的配额quota_consumed:

```python
class NewBucket:
    def __init__(self, period):
        self.period_delta = timedelta(seconds=period)
        self.reset_time = datetime.now()
        self.max_quota = 0
        self.quota_consumed = 0
    def __repr__(self):
        return (f'NewBucket(max_quota={self.max_quota}, '
    f'quota_consumed={self.quota_consumed})')
```

​		为了匹配原来Bucket类的前一个接口，使用@property方法实时计算运行中:的桶的配额级别：

~~~python
    @property
    def quota(self):
        return self.max_quota - self.quota_consumed
~~~

​		当配额属性被赋值时，采取一些特殊的操作来兼容fill和deduct函数对Bucket类的操作：

~~~python
	@quota.setter
    def quota(self, amount):
        delta = self.max_quota - amount
        if amount == 0:
            # Quota being reset for a new period
            self.quota_consumed = 0
            self.max_quota = 0
        elif delta < 0:
            # Quota being filled during the period
            self.max_quota = amount + self.quota_consumed
        else:
            # Quota being consumed during the period
            self.quota_consumed = delta
~~~

​		重新运行上面的演示代码会产生相同的结果：

~~~python
class NewBucket:
    def __init__(self, period):
        self.period_delta = timedelta(seconds=period)
        self.reset_time = datetime.now()
        self.max_quota = 0
        self.quota_consumed = 0

    def __repr__(self):
        return (f'NewBucket(max_quota={self.max_quota}, '
                f'quota_consumed={self.quota_consumed})')

    @property
    def quota(self):
        return self.max_quota - self.quota_consumed

    @quota.setter
    def quota(self, amount):
        delta = self.max_quota - amount
        if amount == 0:
            # Quota being reset for a new period
            self.quota_consumed = 0
            self.max_quota = 0
        elif delta < 0:
            # Quota being filled during the period
            self.max_quota = amount + self.quota_consumed
        else:
            # Quota being consumed during the period
            self.quota_consumed = delta


bucket = NewBucket(60)
print('Initial', bucket)
fill(bucket, 100)
print('Filled', bucket)
if deduct(bucket, 99):
    print('Had 99 quota')
else:
    print('Not enough for 99 quota')
print('Now', bucket)
if deduct(bucket, 3):
    print('Had 3 quota')
else:
    print('Not enough for 3 quota')
print('Still', bucket)

>>>
Initial NewBucket(max_quota=0, quota_consumed=0)
Filled NewBucket(max_quota=100, quota_consumed=0)
Had 99 quota
Now NewBucket(max_quota=100, quota_consumed=99)
Not enough for 3 quota
Still NewBucket(max_quota=100, quota_consumed=99)
~~~

​		这个代码最大的好处是使用Bucket.quota时，不需要改变或者甚至不需要了解类已经改变了。Bucket的新用法能够完成需求，并直接访问max_quota和quota_consumed。

​		作者很喜欢@property，因为他可以在后续逐步改进数据模型。阅读上面的Bucket实例，可能会认为fill和deduct应该首先作为实例方法实现。虽然你肯能是对的(参见第37条)，但是在时间中，很多情况下，类可能都是以很槽糕的接口开始的或者被作为愚蠢的数据容器。在后续代码升级迭代过程中，随着代码的增长、范围增加、多个作者共享时，就会出翔这样的情况。

​		@property是一个工具，可以帮助你解决在现实代码中遇到的问题。但是不要过度使用它。当您发现自己反复扩展@property方法时，可能是时候重构您的类，而不是进一步弥补代码的糟糕设计。

**要点**

* 使用@property为现有实例属性提供新功能
* 通过使用@property，逐步改进数据模型
* 当您发现自己过度使用@property时，请考虑重构一个类和所有调用站点