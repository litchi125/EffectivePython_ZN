# 第八章 稳定与性能

​		一旦写好了一个非常有用的程序，下一步就是让代码更加高效、且使之更加不易受攻击。使程序在遇到以外情况时变得更加可靠与确保程序的正确性一样重要。Python有内置的特性和模块，有助于强化程序，使他们在各种情况下都很健壮。

​		健壮性的一个方面是可伸缩性和性能。当在实现处理大量数据的Python程序时，经常会看到由于代码的算法复杂性或其他类型的计算开销而导致的速度变慢。幸运的是，Python包含了许多算法和数据结构，需要用最少的努力来实现高性能。

## 第65条 合理利用try/except/else/finally结构中的每个代码块

​		在Python中，处理异常通常包括四个步。这些是在try、except、else和finally块的功能中捕获的。在复合语句中，每个块都有独特的用途，它们的各种组合都很有用(参见第87条。

**finally Blocks**

​		如果希望捕获异常后，异常向上传播且发生异常时运行清理代码，那就使用try/finally。try/finally的一个常见用法是用于可靠地关闭文件句柄(参见第66条)：

```python
def try_finally_example(filename):
    print('* Opening file')
    handle = open(filename, encoding='utf-8') # May raise OSError
    try:
        print('* Reading data')
        return handle.read()  # May raise UnicodeDecodeError
    finally:
        print('* Calling close()')
        handle.close()        # Always runs after try block
```

​		read方法引发的任何异常都将一直传播到try_finally_example方法调用处，但finally块中handle的close方法将首先运行:

```python
try:
    filename = 'random_data.txt'
    
    with open(filename, 'wb') as f:
        f.write(b'\xf1\xf2\xf3\xf4\xf5')  # Invalid utf-8
    
    data = try_finally_example(filename)
    # This should not be reached.
    import sys
    sys.exit(1)
except:
    logging.exception('Expected')
else:
    assert False
>>>
>>>
* Opening file
* Reading data
* Calling close()
Traceback ...
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xf1 in
➥position 0: invalid continuation byte
```

​		必须在try块之前调用open，因为当打开文件时发生的异常(如文件不存在时的OSError)应该完全跳过finally块:

~~~python
try_finally_example('does_not_exist.txt')
>>>
* Opening file
Traceback ...
FileNotFoundError: [Errno 2] No such file or directory:
➥'does_not_exist.txt'
~~~

**else Blocks**

​		在处理异常时使用try/except/else，在出现异常时能够清晰的指导哪个异常会被向上抛出。当try代码块内有抛出异常时，else代码块就会运行。else块可以最小化try块中的代码量，这有助于隔离潜在的异常原因并提高可读性。例如，说想从一个字符串加载JSON字典数据，并返回它包含的键值:

```python
import json

def load_json_key(data, key):
    try:
        print('* Loading JSON data')
        result_dict = json.loads(data)  # May raise ValueError
    except ValueError as e:
        print('* Handling ValueError')
        raise KeyError(key) from e
    else:
        print('* Looking up key')
        return result_dict[key]         # May raise KeyError
```

​		顺利的情况下，json数据在try代码块中解码，然后在else代码块中进行键查找：

```python
print(load_json_key('{"foo": "bar"}', 'foo'))
>>>
* Loading JSON data
* Looking up key
bar
```

​		如果输入不是一个有效的json，json.loads解码时就会抛出ValueError异常。这个异常被except捕获并抛出：

~~~python
load_json_key('{"foo": bad payload', 'foo')
>>>
* Loading JSON data
* Handling ValueError
Traceback ...
JSONDecodeError: Expecting value: line 1 column 9 (char 8)
The above exception was the direct cause of the following
➥exception:
Traceback ...
KeyError: 'foo'
~~~

​		如果键查找引发任何异常，他们将传播到调用方，因为他们在try代码块之外。else子句确保try/except后面的内容在视觉上与except不同。这使得异常传播行为更加清晰：

```python
try:
    load_json_key('{"foo": "bar"}', 'does not exist')
except:
    logging.exception('Expected')
else:
    assert False
>>>
>>>
* Loading JSON data
* Looking up key
Traceback ...
KeyError: 'does not exist'
```

**Everything Together**

​	  如果想在一个符合语句中完成所有操作，使用try/except/else/finally结构。例如，假设想从文件中读取要做的工作描述，处理，然后更新文件。这里，try快用于读取文件并处理它；except用于处理来自期望的try的异常；else用于更新文件，并允许相关异常向上传播；finally清除文件句柄。

```python
UNDEFINED = object()
DIE_IN_ELSE_BLOCK = False

def divide_json(path):
    print('* Opening file')
    handle = open(path, 'r+')   # May raise OSError
    try:
        print('* Reading data')
        data = handle.read()    # May raise UnicodeDecodeError
        print('* Loading JSON data')
        op = json.loads(data)   # May raise ValueError
        print('* Performing calculation')
        value = (
            op['numerator'] /
            op['denominator'])  # May raise ZeroDivisionError
    except ZeroDivisionError as e:
        print('* Handling ZeroDivisionError')
        return UNDEFINED
    else:
        print('* Writing calculation')
        op['result'] = value
        result = json.dumps(op)
        handle.seek(0)          # May raise OSError
        if DIE_IN_ELSE_BLOCK:
            import errno
            import os
            raise OSError(errno.ENOSPC, os.strerror(errno.ENOSPC))
        handle.write(result)    # May raise OSError
        return value
    finally:
        print('* Calling close()')
        handle.close()          # Always runs
```

​		没有异常的情况下，try、else、finally运行：

~~~python
temp_path = 'random_data.json'

with open(temp_path, 'w') as f:
    f.write('{"numerator": 1, "denominator": 10}')

print(divide_json(temp_path))
>>>
* Opening file
* Reading data
* Loading JSON data
* Performing calculation
* Writing calculation
* Calling close()
0.1
~~~

​		如果有异常的情况，try、except、finally运行：

```python
temp_path = 'random_data.json'

with open(temp_path, 'w') as f:
    f.write('{"numerator": 1, "denominator": 0}')

print(divide_json(temp_path))
```

​		如果json文件格式正确，try运行并且抛出了一个异常，finally运行，异常就会向上跑给调用者。except和else不运行：

```python
try:
    with open(temp_path, 'w') as f:
        f.write('{"numerator": 1 bad data')

    divide_json(temp_path)
except:
    print('Expected')
else:
    assert False
>>>
* Opening file
* Reading data
* Loading JSON data
* Calling close()
Traceback ...
JSONDecodeError: Expecting ',' delimiter: line 1 column 17
➥(char 16)
```

​		这种布局特别有用，因为所有的快都以直观的方式一起工作。例如，这里通过耗尽磁盘空间的同时运行divide_json函数来模拟这一点：

```python
try:
    with open(temp_path, 'w') as f:
        f.write('{"numerator": 1, "denominator": 10}')
    DIE_IN_ELSE_BLOCK = True
    
    divide_json(temp_path)
except:
    logging.exception('Expected')
else:
    assert False
    
>>>
* Opening file
* Reading data
* Loading JSON data
* Performing calculation
* Writing calculation
* Calling close()
Traceback ...
OSError: [Errno 28] No space left on device

```

​		当重写结果数据时在else块中引发异常时，finally块仍然运行并按预期关闭文件句柄。

**要点**

* try/finally复合语句允许运行清理代码，而不管try块中是否引发了异常
* else块可以最小化try块中的代码量，并从视觉上区分成功案例与try/except块
* else块可用于在成功的try块之后，但在finally块的普通清理之前执行其他操作

## 第66条 虑用contextlib和with语句来改写可复用的try/finally代码

 		Python中的with语句用于指示代码何时在特定上下文中运行。例如，互斥锁(参见第54条)可以用在with语句中，表示缩进代码块只在锁被持有时运行:

```python
from threading import Lock

lock = Lock()
with lock:
    # Do something while maintaining an invariant
    pass
```

​		上面的例子等价于使用try/finally结构，因为Lock类正确地启用了with语句：

```python
lock.acquire()
try:
    # Do something while maintaining an invariant
    pass
finally:
    lock.release()
```

​		这个版本的with语句更好，因为它消除了编写try/finally构造的重复代码的需要，并且它确保您不会忘记对每个acquire调用有一个相应的release调用。

​		通过使用contextlib内置模块，可以很容易地让对象和函数与语句一起工作。这个模块包含了contextmanager装饰器(参见第26条)，它允许在with语句中使用一个简单的函数。这比用特殊方法--enter--和--exit--(标准方法)定义一个新类容易得多。

​		例如，假设希望某个代码区域有时有更多的调试日志记录。这里，定义了一个函数，它在两个严重级别上进行日志记录:

```python
import logging
logging.getLogger().setLevel(logging.WARNING)

def my_function():
    logging.debug('Some debug data')
    logging.error('Error log here')
    logging.debug('More debug data')
```

​		程序的默认log等级是WARRING，在运行代码时只有错误消息会打印出来：

~~~python
my_function()
>>>
Error log here
~~~

​		可以通过定义上下文管理器临时提高这个函数的日志级别。这个helper函数在运行with块中的代码之前提高了日志记录的严重级别，之后降低了日志记录的严重级别:

```python
from contextlib import contextmanager

@contextmanager
def debug_logging(level):
    logger = logging.getLogger()
    old_level = logger.getEffectiveLevel()
    logger.setLevel(level)
    try:
        yield
    finally:
        logger.setLevel(old_level)
```

​		yield表达式是with块内容将执行的点(参见第30条)。在with块中发生的任何异常都将由yield表达式重新引发，以便在helper函数中捕获(参见第35条)。

​		现在，可以再次调用相同的日志记录函数，但是是在debug_logging上下文中。这一次，所有的调试消息都在with块期间被打印到屏幕上。在with块之外运行的相同函数不会打印调试消息:

~~~python
with debug_logging(logging.DEBUG):
    print('* Inside:')
    my_function()

print('* After:')
my_function()
>>>
* Inside:
* After:
DEBUG:root:Some debug data
ERROR:root:Error log here
DEBUG:root:More debug data
ERROR:root:Error log here
~~~

**Using with Targets**

​		传递给with语句的上下文管理器也可以返回一个对象。该对象被赋值给复合语句的as部分中的一个局部变量。这使得在with块中运行的代码能够直接与其上下文交互。

​		例如，假设想写一个文件，并确保它总是正确关闭。可以通过将open传递给with语句来做到这一点。Open为with的as目标返回一个文件句柄，并在with块退出时关闭该句柄:

~~~python
with open('my_output.txt', 'w') as handle:
	handle.write('This is some data!')
~~~

​		这种方法比每次手动打开和关闭文件句柄更python化。当执行离开with语句时，文件最终是关闭的。通过突出显示关键部分，它还鼓励减少在打开文件句柄时执行的代码数量，这通常是一种良好的实践。

​		要使自己的函数能够为目标提供值，所需要做的就是从上下文管理器中生成一个值。例如，这里定义了一个上下文管理器来获取Logger实例，设置其级别，然后将其作为目标:

```python
@contextmanager
def log_level(level, name):
    logger = logging.getLogger(name)
    old_level = logger.getEffectiveLevel()
    logger.setLevel(level)
    try:
        yield logger
    finally:
        logger.setLevel(old_level)
```

​		调用as目标上的debug等日志记录方法会产生输出，因为特定Logger实例上的with块中的日志记录严重级别设置得足够低。直接使用日志模块不会打印任何东西，因为默认程序记录器的默认日志级别是WARNING:

```python
with log_level(logging.DEBUG, 'my-log') as logger:
    logger.debug(f'This is a message for {logger.name}!')
    logging.debug('This will not print')
>>>
This is a message for my-log!
```

​		在with语句退出后，在名为“my-log”的Logger上调用调试日志记录方法将不会打印任何内容，因为默认的日志记录严重级别已经恢复。错误日志信息将始终打印:

```python
logger = logging.getLogger('my-log')
logger.debug('Debug will not print')
logger.error('Error will print')
>>>
Error will print
```

​		稍后，可以通过更新with语句来更改想要使用的记录器的名称。这将指向与块中的作为目标的Logger到一个不同的实例，但我不需要更新任何其他代码来匹配:

```python
with log_level(logging.DEBUG, 'other-log') as logger:
    logger.debug(f'This is a message for {logger.name}!')
    logging.debug('This will not print')
>>>
DEBUG:other-log:This is a message for other-log!
```

​		这种状态隔离以及创建上下文和在该上下文中操作之间的分离是with语句的另一个好处。

**要点**

* with语句允许重用try/finally块中的逻辑，减少视觉干扰
* 内置模块contextlib提供了一个contextmanager装饰器，可以方便地在with语句中使用自己的函数
* 上下文管理器生成的值提供给with语句的as部分。它有助于让代码直接访问特殊上下文的原因

## 第67条 用datetime模块处理本地时间，不要用time模块

​		协调世界时(UTC)是标准的、与时区无关的时间表示。UTC对于将时间表示为自UNIX纪元以来的秒数的计算机非常有效。但是UTC对人类来说并不理想。人类会根据他们当前所处的位置来参考时间。人们说“中午”或“上午8点”，而不是“UTC 15:00 - 7小时。”如果程序处理时间，可能会发现为了便于人们理解，需要在UTC和本地时钟之间转换时间。

​		Python提供了两种实现时区转换的方法。使用time内置模块的旧方法非常容易出错。使用datetime内置模块的新方法在名为pytz的社区构建包的帮助下工作得非常好。

​		应该熟悉time和datetime，以便彻底理解为什么datetime是最好的选择，并且应该避免使用time。

*The time Module*

​		时间内置模块中的localtime函数允许将UNIX时间戳(UTC中UNIX纪元以来的秒数)转换为与主机计算机时区匹配的本地时间(在我的例子中是太平洋夏令时)。这个本地时间可以使用strftime函数以人类可读的格式打印出来:

```python
import time

now = 1552774475
local_tuple = time.localtime(now)
time_format = '%Y-%m-%d %H:%M:%S'
time_str = time.strftime(time_format, local_tuple)
print(time_str)
>>>
2019-03-17 06:14:35
```

​		通常还需要采用另一种方法，从用户输入人类可读的本地时间开始，然后将其转换为UTC时间。可以通过使用strptime函数来解析时间字符串，然后调用mktime将本地时间转换为UNIX时间戳来实现这一点:

```python
time_tuple = time.strptime(time_str, time_format)
utc_now = time.mktime(time_tuple)
print(utc_now)
>>>
1552774475.0
```

​		最初可能假设可以直接操作time、localtime和strptime函数的返回值来进行时区转换。但这是个非常糟糕的主意。时区会因为当地的法律而随时改变。这对你自己来说太复杂了，尤其是如果你想要处理全球每个城市的航班起飞和到达。

​		许多操作系统都有与时区变化自动同步的配置文件。如果平台支持，Python允许您通过时间模块使用这些时区。在其他平台上，比如Windows，有些时区功能根本不能从时间开始使用。例如，这里解析了一个从旧金山时区出发的时间，太平洋夏令时(PDT):

```python
import os

if os.name == 'nt':
    print("This example doesn't work on Windows")
else:
    parse_format = '%Y-%m-%d %H:%M:%S %Z'
    depart_sfo = '2019-03-16 15:45:16 PDT'
    time_tuple = time.strptime(depart_sfo, parse_format)
    time_str = time.strftime(time_format, time_tuple)
    print(time_str)
>>>
This example doesn't work on Windows
```

​		在看到'PDT'与strptime函数一起工作之后，可能还会假设计算机知道的其他时区也可以工作。不幸的是，事实并非如此。strptime在看到东部夏令时(EDT)时引发异常，这是纽约的时区:

```python
arrival_nyc = '2019-03-16 23:33:24 EDT'
time_tuple = time.strptime(arrival_nyc, time_format)
>>>
Traceback ...
ValueError: unconverted data remains: EDT
```

​		这里的问题是时间模块的平台依赖性。它的行为是由底层C函数与宿主操作系统的工作方式决定的。这使得Python中的time模块的功能不可靠。时间模块在多个本地时间无法正常工作。因此，您应该避免将时间模块用于此目的。如果必须使用时间，请仅在UTC和主机本地时间之间使用它。对于所有其他类型的转换，请使用datetime模块。

*The datetime Module*

​		Python中表示时间的第二个选项是datetime内建模块中的datetime类。与time模块类似，datetime可用于将UTC中的当前时间转换为本地时间。

​		这里，将UTC的当前时间转换为我的计算机的本地时间，PDT:

```python
from datetime import datetime, timezone

now = datetime(2019, 3, 16, 22, 14, 35)
now_utc = now.replace(tzinfo=timezone.utc)
now_local = now_utc.astimezone()
print(now_local)
>>>
2019-03-17 06:14:35+08:00
```

​		datetime模块也可以很容易地将本地时间转换回UTC格式的UNIX时间戳:

```python
import time
from datetime import datetime, timezone
time_format = '%Y-%m-%d %H:%M:%S'
time_str = '2019-03-16 15:14:35'
now = datetime.strptime(time_str, time_format)
time_tuple = now.timetuple()
utc_now = time.mktime(time_tuple)
print(utc_now)
>>>
1552774475.0

```

​		与time模块不同，datetime模块具有从一个本地时间可靠地转换为另一个本地时间的功能。但是，datetime仅通过其tzinfo类和相关方法为时区操作提供机制。Python的默认安装缺少UTC以外的时区定义。

​		幸运的是，Python社区已经解决了这个问题，可以从Python包索引中下载pytz模块(参见第82条)。Pytz包含可能需要的每个时区定义的完整数据库。

​		为了有效地使用pytz，应该总是首先将本地时间转换为UTC。对UTC值执行任何需要的datetime操作(例如偏移量)。然后，将其转换为本地时间作为最后一步。

​		例如，这里将纽约市航班到达时间转换为UTC日期时间。尽管其中一些调用看起来是多余的，但在使用pytz时，所有这些调用都是必要的:

```python
import pytz

arrival_nyc = '2019-03-16 23:33:24'
nyc_dt_naive = datetime.strptime(arrival_nyc, time_format)
eastern = pytz.timezone('US/Eastern')
nyc_dt = eastern.localize(nyc_dt_naive)
utc_dt = pytz.utc.normalize(nyc_dt.astimezone(pytz.utc))
print(utc_dt)
>>>
2019-03-17 03:33:24+00:00
```

​		一旦有了UTC日期时间，可以将它转换为旧金山当地时间:

~~~python
pacific = pytz.timezone('US/Pacific')
sf_dt = pacific.normalize(utc_dt.astimezone(pacific))
print(sf_dt)
>>>
2019-03-16 20:33:24-07:00
~~~

​		同样简单的是，可以把它转换成尼泊尔当地时间:

~~~python
nepal = pytz.timezone('Asia/Katmandu')
nepal_dt = nepal.normalize(utc_dt.astimezone(nepal))
print(nepal_dt)
>>>
2019-03-17 09:18:24+05:45

~~~

​		使用datetime和pytz，这些转换在所有环境中都是一致的，而不管主机计算机运行的是什么操作系统.

**要点**

* 避免使用时间模块在不同时区之间进行转换
* 使用datetime内置模块和pytz社区模块来可靠地转换不同时区的时间
* 始终用UTC表示时间，并将转换为本地时间作为显示前的最后一步。