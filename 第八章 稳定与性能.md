# 第八章 稳定与性能

​		一旦写好了一个非常有用的程序，下一步就是让代码更加高效、且使之更加不易受攻击。使程序在遇到以外情况时变得更加可靠与确保程序的正确性一样重要。Python有内置的特性和模块，有助于强化程序，使他们在各种情况下都很健壮。

​		健壮性的一个方面是可伸缩性和性能。当在实现处理大量数据的Python程序时，经常会看到由于代码的算法复杂性或其他类型的计算开销而导致的速度变慢。幸运的是，Python包含了许多算法和数据结构，需要用最少的努力来实现高性能。

## 第65条 合理利用try/except/else/finally结构中的每个代码块

​		在Python中，处理异常通常包括四个步。这些是在try、except、else和finally块的功能中捕获的。在复合语句中，每个块都有独特的用途，它们的各种组合都很有用(参见第87条。

**finally Blocks**

​		如果希望捕获异常后，异常向上传播且发生异常时运行清理代码，那就使用try/finally。try/finally的一个常见用法是用于可靠地关闭文件句柄(参见第66条)：

```python
def try_finally_example(filename):
    print('* Opening file')
    handle = open(filename, encoding='utf-8') # May raise OSError
    try:
        print('* Reading data')
        return handle.read()  # May raise UnicodeDecodeError
    finally:
        print('* Calling close()')
        handle.close()        # Always runs after try block
```

​		read方法引发的任何异常都将一直传播到try_finally_example方法调用处，但finally块中handle的close方法将首先运行:

```python
try:
    filename = 'random_data.txt'
    
    with open(filename, 'wb') as f:
        f.write(b'\xf1\xf2\xf3\xf4\xf5')  # Invalid utf-8
    
    data = try_finally_example(filename)
    # This should not be reached.
    import sys
    sys.exit(1)
except:
    logging.exception('Expected')
else:
    assert False
>>>
>>>
* Opening file
* Reading data
* Calling close()
Traceback ...
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xf1 in
➥position 0: invalid continuation byte
```

​		必须在try块之前调用open，因为当打开文件时发生的异常(如文件不存在时的OSError)应该完全跳过finally块:

~~~python
try_finally_example('does_not_exist.txt')
>>>
* Opening file
Traceback ...
FileNotFoundError: [Errno 2] No such file or directory:
➥'does_not_exist.txt'
~~~

**else Blocks**

​		在处理异常时使用try/except/else，在出现异常时能够清晰的指导哪个异常会被向上抛出。当try代码块内有抛出异常时，else代码块就会运行。else块可以最小化try块中的代码量，这有助于隔离潜在的异常原因并提高可读性。例如，说想从一个字符串加载JSON字典数据，并返回它包含的键值:

```python
import json

def load_json_key(data, key):
    try:
        print('* Loading JSON data')
        result_dict = json.loads(data)  # May raise ValueError
    except ValueError as e:
        print('* Handling ValueError')
        raise KeyError(key) from e
    else:
        print('* Looking up key')
        return result_dict[key]         # May raise KeyError
```

​		顺利的情况下，json数据在try代码块中解码，然后在else代码块中进行键查找：

```python
print(load_json_key('{"foo": "bar"}', 'foo'))
>>>
* Loading JSON data
* Looking up key
bar
```

​		如果输入不是一个有效的json，json.loads解码时就会抛出ValueError异常。这个异常被except捕获并抛出：

~~~python
load_json_key('{"foo": bad payload', 'foo')
>>>
* Loading JSON data
* Handling ValueError
Traceback ...
JSONDecodeError: Expecting value: line 1 column 9 (char 8)
The above exception was the direct cause of the following
➥exception:
Traceback ...
KeyError: 'foo'
~~~

​		如果键查找引发任何异常，他们将传播到调用方，因为他们在try代码块之外。else子句确保try/except后面的内容在视觉上与except不同。这使得异常传播行为更加清晰：

```python
try:
    load_json_key('{"foo": "bar"}', 'does not exist')
except:
    logging.exception('Expected')
else:
    assert False
>>>
>>>
* Loading JSON data
* Looking up key
Traceback ...
KeyError: 'does not exist'
```

**Everything Together**

​	  如果想在一个符合语句中完成所有操作，使用try/except/else/finally结构。例如，假设想从文件中读取要做的工作描述，处理，然后更新文件。这里，try快用于读取文件并处理它；except用于处理来自期望的try的异常；else用于更新文件，并允许相关异常向上传播；finally清除文件句柄。

```python
UNDEFINED = object()
DIE_IN_ELSE_BLOCK = False

def divide_json(path):
    print('* Opening file')
    handle = open(path, 'r+')   # May raise OSError
    try:
        print('* Reading data')
        data = handle.read()    # May raise UnicodeDecodeError
        print('* Loading JSON data')
        op = json.loads(data)   # May raise ValueError
        print('* Performing calculation')
        value = (
            op['numerator'] /
            op['denominator'])  # May raise ZeroDivisionError
    except ZeroDivisionError as e:
        print('* Handling ZeroDivisionError')
        return UNDEFINED
    else:
        print('* Writing calculation')
        op['result'] = value
        result = json.dumps(op)
        handle.seek(0)          # May raise OSError
        if DIE_IN_ELSE_BLOCK:
            import errno
            import os
            raise OSError(errno.ENOSPC, os.strerror(errno.ENOSPC))
        handle.write(result)    # May raise OSError
        return value
    finally:
        print('* Calling close()')
        handle.close()          # Always runs
```

​		没有异常的情况下，try、else、finally运行：

~~~python
temp_path = 'random_data.json'

with open(temp_path, 'w') as f:
    f.write('{"numerator": 1, "denominator": 10}')

print(divide_json(temp_path))
>>>
* Opening file
* Reading data
* Loading JSON data
* Performing calculation
* Writing calculation
* Calling close()
0.1
~~~

​		如果有异常的情况，try、except、finally运行：

```python
temp_path = 'random_data.json'

with open(temp_path, 'w') as f:
    f.write('{"numerator": 1, "denominator": 0}')

print(divide_json(temp_path))
```

​		如果json文件格式正确，try运行并且抛出了一个异常，finally运行，异常就会向上跑给调用者。except和else不运行：

```python
try:
    with open(temp_path, 'w') as f:
        f.write('{"numerator": 1 bad data')

    divide_json(temp_path)
except:
    print('Expected')
else:
    assert False
>>>
* Opening file
* Reading data
* Loading JSON data
* Calling close()
Traceback ...
JSONDecodeError: Expecting ',' delimiter: line 1 column 17
➥(char 16)
```

​		这种布局特别有用，因为所有的快都以直观的方式一起工作。例如，这里通过耗尽磁盘空间的同时运行divide_json函数来模拟这一点：

```python
try:
    with open(temp_path, 'w') as f:
        f.write('{"numerator": 1, "denominator": 10}')
    DIE_IN_ELSE_BLOCK = True
    
    divide_json(temp_path)
except:
    logging.exception('Expected')
else:
    assert False
    
>>>
* Opening file
* Reading data
* Loading JSON data
* Performing calculation
* Writing calculation
* Calling close()
Traceback ...
OSError: [Errno 28] No space left on device

```

​		当重写结果数据时在else块中引发异常时，finally块仍然运行并按预期关闭文件句柄。

**要点**

* try/finally复合语句允许运行清理代码，而不管try块中是否引发了异常
* else块可以最小化try块中的代码量，并从视觉上区分成功案例与try/except块
* else块可用于在成功的try块之后，但在finally块的普通清理之前执行其他操作

## 第66条 虑用contextlib和with语句来改写可复用的try/finally代码

 		Python中的with语句用于指示代码何时在特定上下文中运行。例如，互斥锁(参见第54条)可以用在with语句中，表示缩进代码块只在锁被持有时运行:

```python
from threading import Lock

lock = Lock()
with lock:
    # Do something while maintaining an invariant
    pass
```

​		上面的例子等价于使用try/finally结构，因为Lock类正确地启用了with语句：

```python
lock.acquire()
try:
    # Do something while maintaining an invariant
    pass
finally:
    lock.release()
```

​		这个版本的with语句更好，因为它消除了编写try/finally构造的重复代码的需要，并且它确保您不会忘记对每个acquire调用有一个相应的release调用。

​		通过使用contextlib内置模块，可以很容易地让对象和函数与语句一起工作。这个模块包含了contextmanager装饰器(参见第26条)，它允许在with语句中使用一个简单的函数。这比用特殊方法--enter--和--exit--(标准方法)定义一个新类容易得多。

​		例如，假设希望某个代码区域有时有更多的调试日志记录。这里，定义了一个函数，它在两个严重级别上进行日志记录:

```python
import logging
logging.getLogger().setLevel(logging.WARNING)

def my_function():
    logging.debug('Some debug data')
    logging.error('Error log here')
    logging.debug('More debug data')
```

​		程序的默认log等级是WARRING，在运行代码时只有错误消息会打印出来：

~~~python
my_function()
>>>
Error log here
~~~

​		可以通过定义上下文管理器临时提高这个函数的日志级别。这个helper函数在运行with块中的代码之前提高了日志记录的严重级别，之后降低了日志记录的严重级别:

```python
from contextlib import contextmanager

@contextmanager
def debug_logging(level):
    logger = logging.getLogger()
    old_level = logger.getEffectiveLevel()
    logger.setLevel(level)
    try:
        yield
    finally:
        logger.setLevel(old_level)
```

​		yield表达式是with块内容将执行的点(参见第30条)。在with块中发生的任何异常都将由yield表达式重新引发，以便在helper函数中捕获(参见第35条)。

​		现在，可以再次调用相同的日志记录函数，但是是在debug_logging上下文中。这一次，所有的调试消息都在with块期间被打印到屏幕上。在with块之外运行的相同函数不会打印调试消息:

~~~python
with debug_logging(logging.DEBUG):
    print('* Inside:')
    my_function()

print('* After:')
my_function()
>>>
* Inside:
* After:
DEBUG:root:Some debug data
ERROR:root:Error log here
DEBUG:root:More debug data
ERROR:root:Error log here
~~~

**Using with Targets**

​		传递给with语句的上下文管理器也可以返回一个对象。该对象被赋值给复合语句的as部分中的一个局部变量。这使得在with块中运行的代码能够直接与其上下文交互。

​		例如，假设想写一个文件，并确保它总是正确关闭。可以通过将open传递给with语句来做到这一点。Open为with的as目标返回一个文件句柄，并在with块退出时关闭该句柄:

~~~python
with open('my_output.txt', 'w') as handle:
	handle.write('This is some data!')
~~~

​		这种方法比每次手动打开和关闭文件句柄更python化。当执行离开with语句时，文件最终是关闭的。通过突出显示关键部分，它还鼓励减少在打开文件句柄时执行的代码数量，这通常是一种良好的实践。

​		要使自己的函数能够为目标提供值，所需要做的就是从上下文管理器中生成一个值。例如，这里定义了一个上下文管理器来获取Logger实例，设置其级别，然后将其作为目标:

```python
@contextmanager
def log_level(level, name):
    logger = logging.getLogger(name)
    old_level = logger.getEffectiveLevel()
    logger.setLevel(level)
    try:
        yield logger
    finally:
        logger.setLevel(old_level)
```

​		调用as目标上的debug等日志记录方法会产生输出，因为特定Logger实例上的with块中的日志记录严重级别设置得足够低。直接使用日志模块不会打印任何东西，因为默认程序记录器的默认日志级别是WARNING:

```python
with log_level(logging.DEBUG, 'my-log') as logger:
    logger.debug(f'This is a message for {logger.name}!')
    logging.debug('This will not print')
>>>
This is a message for my-log!
```

​		在with语句退出后，在名为“my-log”的Logger上调用调试日志记录方法将不会打印任何内容，因为默认的日志记录严重级别已经恢复。错误日志信息将始终打印:

```python
logger = logging.getLogger('my-log')
logger.debug('Debug will not print')
logger.error('Error will print')
>>>
Error will print
```

​		稍后，可以通过更新with语句来更改想要使用的记录器的名称。这将指向与块中的作为目标的Logger到一个不同的实例，但我不需要更新任何其他代码来匹配:

```python
with log_level(logging.DEBUG, 'other-log') as logger:
    logger.debug(f'This is a message for {logger.name}!')
    logging.debug('This will not print')
>>>
DEBUG:other-log:This is a message for other-log!
```

​		这种状态隔离以及创建上下文和在该上下文中操作之间的分离是with语句的另一个好处。

**要点**

* with语句允许重用try/finally块中的逻辑，减少视觉干扰
* 内置模块contextlib提供了一个contextmanager装饰器，可以方便地在with语句中使用自己的函数
* 上下文管理器生成的值提供给with语句的as部分。它有助于让代码直接访问特殊上下文的原因