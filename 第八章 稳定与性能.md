# 第八章 稳定与性能

​		一旦写好了一个非常有用的程序，下一步就是让代码更加高效、且使之更加不易受攻击。使程序在遇到以外情况时变得更加可靠与确保程序的正确性一样重要。Python有内置的特性和模块，有助于强化程序，使他们在各种情况下都很健壮。

​		健壮性的一个方面是可伸缩性和性能。当在实现处理大量数据的Python程序时，经常会看到由于代码的算法复杂性或其他类型的计算开销而导致的速度变慢。幸运的是，Python包含了许多算法和数据结构，需要用最少的努力来实现高性能。

## 第65条 合理利用try/except/else/finally结构中的每个代码块

​		在Python中，处理异常通常包括四个步。这些是在try、except、else和finally块的功能中捕获的。在复合语句中，每个块都有独特的用途，它们的各种组合都很有用(参见第87条。

**finally Blocks**

​		如果希望捕获异常后，异常向上传播且发生异常时运行清理代码，那就使用try/finally。try/finally的一个常见用法是用于可靠地关闭文件句柄(参见第66条)：

```python
def try_finally_example(filename):
    print('* Opening file')
    handle = open(filename, encoding='utf-8') # May raise OSError
    try:
        print('* Reading data')
        return handle.read()  # May raise UnicodeDecodeError
    finally:
        print('* Calling close()')
        handle.close()        # Always runs after try block
```

​		read方法引发的任何异常都将一直传播到try_finally_example方法调用处，但finally块中handle的close方法将首先运行:

```python
try:
    filename = 'random_data.txt'
    
    with open(filename, 'wb') as f:
        f.write(b'\xf1\xf2\xf3\xf4\xf5')  # Invalid utf-8
    
    data = try_finally_example(filename)
    # This should not be reached.
    import sys
    sys.exit(1)
except:
    logging.exception('Expected')
else:
    assert False
>>>
>>>
* Opening file
* Reading data
* Calling close()
Traceback ...
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xf1 in
➥position 0: invalid continuation byte
```

​		必须在try块之前调用open，因为当打开文件时发生的异常(如文件不存在时的OSError)应该完全跳过finally块:

~~~python
try_finally_example('does_not_exist.txt')
>>>
* Opening file
Traceback ...
FileNotFoundError: [Errno 2] No such file or directory:
➥'does_not_exist.txt'
~~~

**else Blocks**

​		在处理异常时使用try/except/else，在出现异常时能够清晰的指导哪个异常会被向上抛出。当try代码块内有抛出异常时，else代码块就会运行。else块可以最小化try块中的代码量，这有助于隔离潜在的异常原因并提高可读性。例如，说想从一个字符串加载JSON字典数据，并返回它包含的键值:

```python
import json

def load_json_key(data, key):
    try:
        print('* Loading JSON data')
        result_dict = json.loads(data)  # May raise ValueError
    except ValueError as e:
        print('* Handling ValueError')
        raise KeyError(key) from e
    else:
        print('* Looking up key')
        return result_dict[key]         # May raise KeyError
```

​		顺利的情况下，json数据在try代码块中解码，然后在else代码块中进行键查找：

```python
print(load_json_key('{"foo": "bar"}', 'foo'))
>>>
* Loading JSON data
* Looking up key
bar
```

​		如果输入不是一个有效的json，json.loads解码时就会抛出ValueError异常。这个异常被except捕获并抛出：

~~~python
load_json_key('{"foo": bad payload', 'foo')
>>>
* Loading JSON data
* Handling ValueError
Traceback ...
JSONDecodeError: Expecting value: line 1 column 9 (char 8)
The above exception was the direct cause of the following
➥exception:
Traceback ...
KeyError: 'foo'
~~~

​		如果键查找引发任何异常，他们将传播到调用方，因为他们在try代码块之外。else子句确保try/except后面的内容在视觉上与except不同。这使得异常传播行为更加清晰：

```python
try:
    load_json_key('{"foo": "bar"}', 'does not exist')
except:
    logging.exception('Expected')
else:
    assert False
>>>
>>>
* Loading JSON data
* Looking up key
Traceback ...
KeyError: 'does not exist'
```

**Everything Together**

​	  如果想在一个符合语句中完成所有操作，使用try/except/else/finally结构。例如，假设想从文件中读取要做的工作描述，处理，然后更新文件。这里，try快用于读取文件并处理它；except用于处理来自期望的try的异常；else用于更新文件，并允许相关异常向上传播；finally清除文件句柄。

```python
UNDEFINED = object()
DIE_IN_ELSE_BLOCK = False

def divide_json(path):
    print('* Opening file')
    handle = open(path, 'r+')   # May raise OSError
    try:
        print('* Reading data')
        data = handle.read()    # May raise UnicodeDecodeError
        print('* Loading JSON data')
        op = json.loads(data)   # May raise ValueError
        print('* Performing calculation')
        value = (
            op['numerator'] /
            op['denominator'])  # May raise ZeroDivisionError
    except ZeroDivisionError as e:
        print('* Handling ZeroDivisionError')
        return UNDEFINED
    else:
        print('* Writing calculation')
        op['result'] = value
        result = json.dumps(op)
        handle.seek(0)          # May raise OSError
        if DIE_IN_ELSE_BLOCK:
            import errno
            import os
            raise OSError(errno.ENOSPC, os.strerror(errno.ENOSPC))
        handle.write(result)    # May raise OSError
        return value
    finally:
        print('* Calling close()')
        handle.close()          # Always runs
```

​		没有异常的情况下，try、else、finally运行：

~~~python
temp_path = 'random_data.json'

with open(temp_path, 'w') as f:
    f.write('{"numerator": 1, "denominator": 10}')

print(divide_json(temp_path))
>>>
* Opening file
* Reading data
* Loading JSON data
* Performing calculation
* Writing calculation
* Calling close()
0.1
~~~

​		如果有异常的情况，try、except、finally运行：

```python
temp_path = 'random_data.json'

with open(temp_path, 'w') as f:
    f.write('{"numerator": 1, "denominator": 0}')

print(divide_json(temp_path))
```

​		如果json文件格式正确，try运行并且抛出了一个异常，finally运行，异常就会向上跑给调用者。except和else不运行：

```python
try:
    with open(temp_path, 'w') as f:
        f.write('{"numerator": 1 bad data')

    divide_json(temp_path)
except:
    print('Expected')
else:
    assert False
>>>
* Opening file
* Reading data
* Loading JSON data
* Calling close()
Traceback ...
JSONDecodeError: Expecting ',' delimiter: line 1 column 17
➥(char 16)
```

​		这种布局特别有用，因为所有的快都以直观的方式一起工作。例如，这里通过耗尽磁盘空间的同时运行divide_json函数来模拟这一点：

```python
try:
    with open(temp_path, 'w') as f:
        f.write('{"numerator": 1, "denominator": 10}')
    DIE_IN_ELSE_BLOCK = True
    
    divide_json(temp_path)
except:
    logging.exception('Expected')
else:
    assert False
    
>>>
* Opening file
* Reading data
* Loading JSON data
* Performing calculation
* Writing calculation
* Calling close()
Traceback ...
OSError: [Errno 28] No space left on device

```

​		当重写结果数据时在else块中引发异常时，finally块仍然运行并按预期关闭文件句柄。

**要点**

* try/finally复合语句允许运行清理代码，而不管try块中是否引发了异常
* else块可以最小化try块中的代码量，并从视觉上区分成功案例与try/except块
* else块可用于在成功的try块之后，但在finally块的普通清理之前执行其他操作