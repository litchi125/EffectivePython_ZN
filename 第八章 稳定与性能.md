# 第八章 稳定与性能

​		一旦写好了一个非常有用的程序，下一步就是让代码更加高效、且使之更加不易受攻击。使程序在遇到以外情况时变得更加可靠与确保程序的正确性一样重要。Python有内置的特性和模块，有助于强化程序，使他们在各种情况下都很健壮。

​		健壮性的一个方面是可伸缩性和性能。当在实现处理大量数据的Python程序时，经常会看到由于代码的算法复杂性或其他类型的计算开销而导致的速度变慢。幸运的是，Python包含了许多算法和数据结构，需要用最少的努力来实现高性能。

## 第65条 合理利用try/except/else/finally结构中的每个代码块

​		在Python中，处理异常通常包括四个步。这些是在try、except、else和finally块的功能中捕获的。在复合语句中，每个块都有独特的用途，它们的各种组合都很有用(参见第87条。

**finally Blocks**

​		如果希望捕获异常后，异常向上传播且发生异常时运行清理代码，那就使用try/finally。try/finally的一个常见用法是用于可靠地关闭文件句柄(参见第66条)：

```python
def try_finally_example(filename):
    print('* Opening file')
    handle = open(filename, encoding='utf-8') # May raise OSError
    try:
        print('* Reading data')
        return handle.read()  # May raise UnicodeDecodeError
    finally:
        print('* Calling close()')
        handle.close()        # Always runs after try block
```

​		read方法引发的任何异常都将一直传播到try_finally_example方法调用处，但finally块中handle的close方法将首先运行:

```python
try:
    filename = 'random_data.txt'
    
    with open(filename, 'wb') as f:
        f.write(b'\xf1\xf2\xf3\xf4\xf5')  # Invalid utf-8
    
    data = try_finally_example(filename)
    # This should not be reached.
    import sys
    sys.exit(1)
except:
    logging.exception('Expected')
else:
    assert False
>>>
>>>
* Opening file
* Reading data
* Calling close()
Traceback ...
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xf1 in
➥position 0: invalid continuation byte
```

​		必须在try块之前调用open，因为当打开文件时发生的异常(如文件不存在时的OSError)应该完全跳过finally块:

~~~python
try_finally_example('does_not_exist.txt')
>>>
* Opening file
Traceback ...
FileNotFoundError: [Errno 2] No such file or directory:
➥'does_not_exist.txt'
~~~

**else Blocks**

​		在处理异常时使用try/except/else，在出现异常时能够清晰的指导哪个异常会被向上抛出。当try代码块内有抛出异常时，else代码块就会运行。else块可以最小化try块中的代码量，这有助于隔离潜在的异常原因并提高可读性。例如，说想从一个字符串加载JSON字典数据，并返回它包含的键值:

```python
import json

def load_json_key(data, key):
    try:
        print('* Loading JSON data')
        result_dict = json.loads(data)  # May raise ValueError
    except ValueError as e:
        print('* Handling ValueError')
        raise KeyError(key) from e
    else:
        print('* Looking up key')
        return result_dict[key]         # May raise KeyError
```

​		顺利的情况下，json数据在try代码块中解码，然后在else代码块中进行键查找：

```python
print(load_json_key('{"foo": "bar"}', 'foo'))
>>>
* Loading JSON data
* Looking up key
bar
```

​		如果输入不是一个有效的json，json.loads解码时就会抛出ValueError异常。这个异常被except捕获并抛出：

~~~python
load_json_key('{"foo": bad payload', 'foo')
>>>
* Loading JSON data
* Handling ValueError
Traceback ...
JSONDecodeError: Expecting value: line 1 column 9 (char 8)
The above exception was the direct cause of the following
➥exception:
Traceback ...
KeyError: 'foo'
~~~

​		如果键查找引发任何异常，他们将传播到调用方，因为他们在try代码块之外。else子句确保try/except后面的内容在视觉上与except不同。这使得异常传播行为更加清晰：

```python
try:
    load_json_key('{"foo": "bar"}', 'does not exist')
except:
    logging.exception('Expected')
else:
    assert False
>>>
>>>
* Loading JSON data
* Looking up key
Traceback ...
KeyError: 'does not exist'
```

**Everything Together**

​	  如果想在一个符合语句中完成所有操作，使用try/except/else/finally结构。例如，假设想从文件中读取要做的工作描述，处理，然后更新文件。这里，try快用于读取文件并处理它；except用于处理来自期望的try的异常；else用于更新文件，并允许相关异常向上传播；finally清除文件句柄。

```python
UNDEFINED = object()
DIE_IN_ELSE_BLOCK = False

def divide_json(path):
    print('* Opening file')
    handle = open(path, 'r+')   # May raise OSError
    try:
        print('* Reading data')
        data = handle.read()    # May raise UnicodeDecodeError
        print('* Loading JSON data')
        op = json.loads(data)   # May raise ValueError
        print('* Performing calculation')
        value = (
            op['numerator'] /
            op['denominator'])  # May raise ZeroDivisionError
    except ZeroDivisionError as e:
        print('* Handling ZeroDivisionError')
        return UNDEFINED
    else:
        print('* Writing calculation')
        op['result'] = value
        result = json.dumps(op)
        handle.seek(0)          # May raise OSError
        if DIE_IN_ELSE_BLOCK:
            import errno
            import os
            raise OSError(errno.ENOSPC, os.strerror(errno.ENOSPC))
        handle.write(result)    # May raise OSError
        return value
    finally:
        print('* Calling close()')
        handle.close()          # Always runs
```

​		没有异常的情况下，try、else、finally运行：

~~~python
temp_path = 'random_data.json'

with open(temp_path, 'w') as f:
    f.write('{"numerator": 1, "denominator": 10}')

print(divide_json(temp_path))
>>>
* Opening file
* Reading data
* Loading JSON data
* Performing calculation
* Writing calculation
* Calling close()
0.1
~~~

​		如果有异常的情况，try、except、finally运行：

```python
temp_path = 'random_data.json'

with open(temp_path, 'w') as f:
    f.write('{"numerator": 1, "denominator": 0}')

print(divide_json(temp_path))
```

​		如果json文件格式正确，try运行并且抛出了一个异常，finally运行，异常就会向上跑给调用者。except和else不运行：

```python
try:
    with open(temp_path, 'w') as f:
        f.write('{"numerator": 1 bad data')

    divide_json(temp_path)
except:
    print('Expected')
else:
    assert False
>>>
* Opening file
* Reading data
* Loading JSON data
* Calling close()
Traceback ...
JSONDecodeError: Expecting ',' delimiter: line 1 column 17
➥(char 16)
```

​		这种布局特别有用，因为所有的快都以直观的方式一起工作。例如，这里通过耗尽磁盘空间的同时运行divide_json函数来模拟这一点：

```python
try:
    with open(temp_path, 'w') as f:
        f.write('{"numerator": 1, "denominator": 10}')
    DIE_IN_ELSE_BLOCK = True
    
    divide_json(temp_path)
except:
    logging.exception('Expected')
else:
    assert False
    
>>>
* Opening file
* Reading data
* Loading JSON data
* Performing calculation
* Writing calculation
* Calling close()
Traceback ...
OSError: [Errno 28] No space left on device

```

​		当重写结果数据时在else块中引发异常时，finally块仍然运行并按预期关闭文件句柄。

**要点**

* try/finally复合语句允许运行清理代码，而不管try块中是否引发了异常
* else块可以最小化try块中的代码量，并从视觉上区分成功案例与try/except块
* else块可用于在成功的try块之后，但在finally块的普通清理之前执行其他操作

## 第66条 虑用contextlib和with语句来改写可复用的try/finally代码

 		Python中的with语句用于指示代码何时在特定上下文中运行。例如，互斥锁(参见第54条)可以用在with语句中，表示缩进代码块只在锁被持有时运行:

```python
from threading import Lock

lock = Lock()
with lock:
    # Do something while maintaining an invariant
    pass
```

​		上面的例子等价于使用try/finally结构，因为Lock类正确地启用了with语句：

```python
lock.acquire()
try:
    # Do something while maintaining an invariant
    pass
finally:
    lock.release()
```

​		这个版本的with语句更好，因为它消除了编写try/finally构造的重复代码的需要，并且它确保您不会忘记对每个acquire调用有一个相应的release调用。

​		通过使用contextlib内置模块，可以很容易地让对象和函数与语句一起工作。这个模块包含了contextmanager装饰器(参见第26条)，它允许在with语句中使用一个简单的函数。这比用特殊方法--enter--和--exit--(标准方法)定义一个新类容易得多。

​		例如，假设希望某个代码区域有时有更多的调试日志记录。这里，定义了一个函数，它在两个严重级别上进行日志记录:

```python
import logging
logging.getLogger().setLevel(logging.WARNING)

def my_function():
    logging.debug('Some debug data')
    logging.error('Error log here')
    logging.debug('More debug data')
```

​		程序的默认log等级是WARRING，在运行代码时只有错误消息会打印出来：

~~~python
my_function()
>>>
Error log here
~~~

​		可以通过定义上下文管理器临时提高这个函数的日志级别。这个helper函数在运行with块中的代码之前提高了日志记录的严重级别，之后降低了日志记录的严重级别:

```python
from contextlib import contextmanager

@contextmanager
def debug_logging(level):
    logger = logging.getLogger()
    old_level = logger.getEffectiveLevel()
    logger.setLevel(level)
    try:
        yield
    finally:
        logger.setLevel(old_level)
```

​		yield表达式是with块内容将执行的点(参见第30条)。在with块中发生的任何异常都将由yield表达式重新引发，以便在helper函数中捕获(参见第35条)。

​		现在，可以再次调用相同的日志记录函数，但是是在debug_logging上下文中。这一次，所有的调试消息都在with块期间被打印到屏幕上。在with块之外运行的相同函数不会打印调试消息:

~~~python
with debug_logging(logging.DEBUG):
    print('* Inside:')
    my_function()

print('* After:')
my_function()
>>>
* Inside:
* After:
DEBUG:root:Some debug data
ERROR:root:Error log here
DEBUG:root:More debug data
ERROR:root:Error log here
~~~

**Using with Targets**

​		传递给with语句的上下文管理器也可以返回一个对象。该对象被赋值给复合语句的as部分中的一个局部变量。这使得在with块中运行的代码能够直接与其上下文交互。

​		例如，假设想写一个文件，并确保它总是正确关闭。可以通过将open传递给with语句来做到这一点。Open为with的as目标返回一个文件句柄，并在with块退出时关闭该句柄:

~~~python
with open('my_output.txt', 'w') as handle:
	handle.write('This is some data!')
~~~

​		这种方法比每次手动打开和关闭文件句柄更python化。当执行离开with语句时，文件最终是关闭的。通过突出显示关键部分，它还鼓励减少在打开文件句柄时执行的代码数量，这通常是一种良好的实践。

​		要使自己的函数能够为目标提供值，所需要做的就是从上下文管理器中生成一个值。例如，这里定义了一个上下文管理器来获取Logger实例，设置其级别，然后将其作为目标:

```python
@contextmanager
def log_level(level, name):
    logger = logging.getLogger(name)
    old_level = logger.getEffectiveLevel()
    logger.setLevel(level)
    try:
        yield logger
    finally:
        logger.setLevel(old_level)
```

​		调用as目标上的debug等日志记录方法会产生输出，因为特定Logger实例上的with块中的日志记录严重级别设置得足够低。直接使用日志模块不会打印任何东西，因为默认程序记录器的默认日志级别是WARNING:

```python
with log_level(logging.DEBUG, 'my-log') as logger:
    logger.debug(f'This is a message for {logger.name}!')
    logging.debug('This will not print')
>>>
This is a message for my-log!
```

​		在with语句退出后，在名为“my-log”的Logger上调用调试日志记录方法将不会打印任何内容，因为默认的日志记录严重级别已经恢复。错误日志信息将始终打印:

```python
logger = logging.getLogger('my-log')
logger.debug('Debug will not print')
logger.error('Error will print')
>>>
Error will print
```

​		稍后，可以通过更新with语句来更改想要使用的记录器的名称。这将指向与块中的作为目标的Logger到一个不同的实例，但我不需要更新任何其他代码来匹配:

```python
with log_level(logging.DEBUG, 'other-log') as logger:
    logger.debug(f'This is a message for {logger.name}!')
    logging.debug('This will not print')
>>>
DEBUG:other-log:This is a message for other-log!
```

​		这种状态隔离以及创建上下文和在该上下文中操作之间的分离是with语句的另一个好处。

**要点**

* with语句允许重用try/finally块中的逻辑，减少视觉干扰
* 内置模块contextlib提供了一个contextmanager装饰器，可以方便地在with语句中使用自己的函数
* 上下文管理器生成的值提供给with语句的as部分。它有助于让代码直接访问特殊上下文的原因

## 第67条 用datetime模块处理本地时间，不要用time模块

​		协调世界时(UTC)是标准的、与时区无关的时间表示。UTC对于将时间表示为自UNIX纪元以来的秒数的计算机非常有效。但是UTC对人类来说并不理想。人类会根据他们当前所处的位置来参考时间。人们说“中午”或“上午8点”，而不是“UTC 15:00 - 7小时。”如果程序处理时间，可能会发现为了便于人们理解，需要在UTC和本地时钟之间转换时间。

​		Python提供了两种实现时区转换的方法。使用time内置模块的旧方法非常容易出错。使用datetime内置模块的新方法在名为pytz的社区构建包的帮助下工作得非常好。

​		应该熟悉time和datetime，以便彻底理解为什么datetime是最好的选择，并且应该避免使用time。

*The time Module*

​		时间内置模块中的localtime函数允许将UNIX时间戳(UTC中UNIX纪元以来的秒数)转换为与主机计算机时区匹配的本地时间(在我的例子中是太平洋夏令时)。这个本地时间可以使用strftime函数以人类可读的格式打印出来:

```python
import time

now = 1552774475
local_tuple = time.localtime(now)
time_format = '%Y-%m-%d %H:%M:%S'
time_str = time.strftime(time_format, local_tuple)
print(time_str)
>>>
2019-03-17 06:14:35
```

​		通常还需要采用另一种方法，从用户输入人类可读的本地时间开始，然后将其转换为UTC时间。可以通过使用strptime函数来解析时间字符串，然后调用mktime将本地时间转换为UNIX时间戳来实现这一点:

```python
time_tuple = time.strptime(time_str, time_format)
utc_now = time.mktime(time_tuple)
print(utc_now)
>>>
1552774475.0
```

​		最初可能假设可以直接操作time、localtime和strptime函数的返回值来进行时区转换。但这是个非常糟糕的主意。时区会因为当地的法律而随时改变。这对你自己来说太复杂了，尤其是如果你想要处理全球每个城市的航班起飞和到达。

​		许多操作系统都有与时区变化自动同步的配置文件。如果平台支持，Python允许您通过时间模块使用这些时区。在其他平台上，比如Windows，有些时区功能根本不能从时间开始使用。例如，这里解析了一个从旧金山时区出发的时间，太平洋夏令时(PDT):

```python
import os

if os.name == 'nt':
    print("This example doesn't work on Windows")
else:
    parse_format = '%Y-%m-%d %H:%M:%S %Z'
    depart_sfo = '2019-03-16 15:45:16 PDT'
    time_tuple = time.strptime(depart_sfo, parse_format)
    time_str = time.strftime(time_format, time_tuple)
    print(time_str)
>>>
This example doesn't work on Windows
```

​		在看到'PDT'与strptime函数一起工作之后，可能还会假设计算机知道的其他时区也可以工作。不幸的是，事实并非如此。strptime在看到东部夏令时(EDT)时引发异常，这是纽约的时区:

```python
arrival_nyc = '2019-03-16 23:33:24 EDT'
time_tuple = time.strptime(arrival_nyc, time_format)
>>>
Traceback ...
ValueError: unconverted data remains: EDT
```

​		这里的问题是时间模块的平台依赖性。它的行为是由底层C函数与宿主操作系统的工作方式决定的。这使得Python中的time模块的功能不可靠。时间模块在多个本地时间无法正常工作。因此，您应该避免将时间模块用于此目的。如果必须使用时间，请仅在UTC和主机本地时间之间使用它。对于所有其他类型的转换，请使用datetime模块。

*The datetime Module*

​		Python中表示时间的第二个选项是datetime内建模块中的datetime类。与time模块类似，datetime可用于将UTC中的当前时间转换为本地时间。

​		这里，将UTC的当前时间转换为我的计算机的本地时间，PDT:

```python
from datetime import datetime, timezone

now = datetime(2019, 3, 16, 22, 14, 35)
now_utc = now.replace(tzinfo=timezone.utc)
now_local = now_utc.astimezone()
print(now_local)
>>>
2019-03-17 06:14:35+08:00
```

​		datetime模块也可以很容易地将本地时间转换回UTC格式的UNIX时间戳:

```python
import time
from datetime import datetime, timezone
time_format = '%Y-%m-%d %H:%M:%S'
time_str = '2019-03-16 15:14:35'
now = datetime.strptime(time_str, time_format)
time_tuple = now.timetuple()
utc_now = time.mktime(time_tuple)
print(utc_now)
>>>
1552774475.0

```

​		与time模块不同，datetime模块具有从一个本地时间可靠地转换为另一个本地时间的功能。但是，datetime仅通过其tzinfo类和相关方法为时区操作提供机制。Python的默认安装缺少UTC以外的时区定义。

​		幸运的是，Python社区已经解决了这个问题，可以从Python包索引中下载pytz模块(参见第82条)。Pytz包含可能需要的每个时区定义的完整数据库。

​		为了有效地使用pytz，应该总是首先将本地时间转换为UTC。对UTC值执行任何需要的datetime操作(例如偏移量)。然后，将其转换为本地时间作为最后一步。

​		例如，这里将纽约市航班到达时间转换为UTC日期时间。尽管其中一些调用看起来是多余的，但在使用pytz时，所有这些调用都是必要的:

```python
import pytz

arrival_nyc = '2019-03-16 23:33:24'
nyc_dt_naive = datetime.strptime(arrival_nyc, time_format)
eastern = pytz.timezone('US/Eastern')
nyc_dt = eastern.localize(nyc_dt_naive)
utc_dt = pytz.utc.normalize(nyc_dt.astimezone(pytz.utc))
print(utc_dt)
>>>
2019-03-17 03:33:24+00:00
```

​		一旦有了UTC日期时间，可以将它转换为旧金山当地时间:

~~~python
pacific = pytz.timezone('US/Pacific')
sf_dt = pacific.normalize(utc_dt.astimezone(pacific))
print(sf_dt)
>>>
2019-03-16 20:33:24-07:00
~~~

​		同样简单的是，可以把它转换成尼泊尔当地时间:

~~~python
nepal = pytz.timezone('Asia/Katmandu')
nepal_dt = nepal.normalize(utc_dt.astimezone(nepal))
print(nepal_dt)
>>>
2019-03-17 09:18:24+05:45

~~~

​		使用datetime和pytz，这些转换在所有环境中都是一致的，而不管主机计算机运行的是什么操作系统.

**要点**

* 避免使用时间模块在不同时区之间进行转换
* 使用datetime内置模块和pytz社区模块来可靠地转换不同时区的时间
* 始终用UTC表示时间，并将转换为本地时间作为显示前的最后一步。

## 第68条 用copyreg实现可靠的pickle操作

​		pickle内置模块可以将Python对象序列化为字节流，并将字节反序列化回对象。pickle的字节流不应该用于不受信任方之间的通信。pickle的目的是让您在您通过二进制通道控制的程序之间传递Python对象。

***

**Note**

​		pickle模块的序列化格式在设计上是不安全的。序列化的数据本质上包含了一个描述如何重构原始Python对象的程序。这意味着恶意的pickle负载可能被用来破坏Python程序中试图反序列化它的任何部分。

​		相反，json模块在设计上是安全的。序列化的JSON数据包含一个对象层次结构的简单描述。反序列化JSON数据不会使Python程序暴露于额外的风险。像JSON这样的格式应该用于程序之间或相互不信任的人之间的通信。

***

​		例如，假设想使用一个Python对象来表示游戏中玩家进程的状态。游戏状态包括玩家所处的关卡以及他们所剩下的生命数:

```python
class GameState:
    def __init__(self):
        self.level = 0
        self.lives = 4
```

​		程序在游戏运行时修改这个对象:

```python
state = GameState()
state.level += 1  # Player beat a level
state.lives -= 1  # Player had to try again

print(state.__dict__)
>>>
{'level': 1, 'lives': 3}
```

​		当用户退出游戏时，程序可以将游戏状态保存到文件中，以便在以后的时间恢复。通过pickle模块可以很容易地做到这一点。在这里，使用dump函数将GameState对象写入文件:

```python
import pickle

state_path = 'game_state.bin'
with open(state_path, 'wb') as f:
    pickle.dump(state, f)
```

​		之后，可以调用文件的加载函数并取回GameState对象，就像它从未被序列化过一样:

~~~python
with open(state_path, 'rb') as f:
	state_after = pickle.load(f)
print(state_after.__dict__)
>>>
{'level': 1, 'lives': 3}
~~~

​		这种方法的问题在于，随着时间的推移，游戏功能的扩展会发生什么。假设想让玩家获得高分。为了追踪玩家的分数，将在GameState类中添加一个新字段：

```python
class GameState:
    def __init__(self):
        self.level = 0
        self.lives = 4
        self.points = 0  # New field
```

​		使用pickle序列化新版本的GameState类将和以前一样工作。在这里，通过序列化一个带有转储的字符串和一个带有加载的对象来模拟遍历一个文件的往返过程:

```python
state = GameState()
serialized = pickle.dumps(state)
state_after = pickle.loads(serialized)
print(state_after.__dict__)
>>>
{'level': 0, 'lives': 4, 'points': 0}
```

​		但是对于用户可能想要恢复的旧保存的GameState对象会发生什么呢?在这里，使用带有GameState类新定义的程序来解pickle一个旧游戏文件:

```python
with open(state_path, 'rb') as f:
    state_after = pickle.load(f)

print(state_after.__dict__)
>>>
{'level': 1, 'lives': 3}
```

​		points属性丢失了。这尤其令人困惑，因为返回的对象是新GameState类的一个实例。

​		这种行为是pickle模块工作方式的副产品。它的主要用例是简化对象序列化。一旦pickle的使用超出了常规用途，模块的功能就会以令人惊讶的方式出现故障。

​		使用copyreg内置模块可以很容易地修复这些问题。copyreg模块允许注册负责序列化和反序列化Python对象的函数，允许控制pickle的行为并使其更可靠。

*Default Attribute Values*

***

​		在最简单的情况下，可以使用带有默认参数的构造函数(参见第23条)来确保GameState对象在unpickling后始终具有所有属性。在这里，这样重新定义构造函数:

```python
class GameState:
    def __init__(self, level=0, lives=4, points=0):
        self.level = level
        self.lives = lives
        self.points = points
```

​		为了使用这个构造函数进行pickle，定义了一个helper函数，它接受一个GameState对象，并将其转换为copyreg模块的参数元组。返回的元组包含用于unpickling的函数和传递给unpickling函数的参数:

```python
def pickle_game_state(game_state):
    kwargs = game_state.__dict__
    return unpickle_game_state, (kwargs,)
```

​		现在，需要定义unpickle_game_state辅助函数。这个函数接受来自pickle_game_state的序列化数据和参数，并返回相应的GameState对象。它是构造函数的一个小小的包装:

```python
def unpickle_game_state(kwargs):
    return GameState(**kwargs)
```

​		现在，可以将这些函数注册到copyreg模块中：

```python
import copyreg

copyreg.pickle(GameState, pickle_game_state)
```

​		注册后，序列化和反序列化工作如常:

```python
state = GameState()
state.points += 1000
serialized = pickle.dumps(state)
state_after = pickle.loads(serialized)
print(state_after.__dict__)
>>>
{'level': 0, 'lives': 4, 'points': 1000}

```

​		完成注册后，现在将再次改变GameState的定义，让玩家能够使用一些魔法咒语。这个改变类似于在GameState中添加点域:

```python
class GameState:
    def __init__(self, level=0, lives=4, points=0, magic=5):
        self.level = level
        self.lives = lives
        self.points = points
        self.magic = magic  # New field
```

​		但与之前不同的是，反序列化一个旧的GameState对象将导致有效的游戏数据，而不是丢失属性。这是可行的，因为unpickle_game_state直接调用GameState构造函数，而不是使用pickle模块的默认行为，即只保存和恢复属于对象的属性。GameState构造函数的关键字参数具有默认值，将用于任何缺少的参数。这将导致旧的游戏状态文件在被反序列化时接收到新的魔法字段的默认值:

~~~python
print('Before:', state.__dict__)
state_after = pickle.loads(serialized)
print('After: ', state_after.__dict__)
>>>
Before: {'level': 0, 'lives': 4, 'points': 1000}
After: {'level': 0, 'lives': 4, 'points': 1000, 'magic': 5}
~~~

*Versioning Classes*

​		有时需要通过删除字段来对Python对象进行向后不兼容的更改。这样做会阻止上面的默认参数方法工作。

​		例如，假设意识到有限的生命数量是个糟糕的想法，想要从游戏中移除生命的概念。在这里，重新定义了GameState类，使其不再拥有lives字段:

```python
class GameState:
    def __init__(self, level=0, points=0, magic=5):
        self.level = level
        self.points = points
        self.magic = magic
```

​		问题是，这破坏了旧游戏数据的反序列化。旧数据中的所有字段，甚至从类中移除的字段，都将通过unpickle_game_state函数传递给GameState构造函数:

~~~python
pickle.loads(serialized)
>>>
Traceback ...
TypeError: __init__() got an unexpected keyword argument
➥'lives'
~~~

​		可以通过向提供给copyreg的函数添加一个版本参数来解决这个问题。当pickle一个新的GameState对象时，新的序列化数据将有一个指定的版本2:

```python
def pickle_game_state(game_state):
    kwargs = game_state.__dict__
    kwargs['version'] = 2
    return unpickle_game_state, (kwargs,)
```

​		旧版本的数据不会有版本参数，这意味着我可以相应地操纵传递给GameState构造函数的参数:

```python
def unpickle_game_state(kwargs):
    version = kwargs.pop('version', 1)
    if version == 1:
        del kwargs['lives']
    return GameState(**kwargs)
```

​		现在，反序列化旧对象可以正常工作:

```python
copyreg.pickle(GameState, pickle_game_state)
print('Before:', state.__dict__)
state_after = pickle.loads(serialized)
print('After: ', state_after.__dict__)
>>>
Before: {'level': 0, 'lives': 4, 'points': 1000}
After: {'level': 0, 'points': 1000, 'magic': 5}
```

​		可以继续使用这种方法来处理同一个类的未来版本之间的更改。将类的旧版本调整为类的新版本所需要的任何逻辑都可以在unpickle_game_state函数中找到。

*Stable Import Paths*

​		使用pickle时可能遇到的另一个问题是重命名类会造成破坏。通常在程序的生命周期中，将通过重命名类并将它们移到其他模块来重构代码。不幸的是，这样做会破坏pickle模块，除非非常小心。

​		在这里，将GameState类重命名为BetterGameState，并从程序中完全删除旧类:

```python
copyreg.dispatch_table.clear()
state = GameState()
serialized = pickle.dumps(state)
del GameState
class BetterGameState:
    def __init__(self, level=0, points=0, magic=5):
        self.level = level
        self.points = points
        self.magic = magic
```

​		试图反序列化一个旧的GameState对象现在失败了，因为类无法找到:

~~~python
pickle.loads(serialized)
>>>
Traceback ...
AttributeError: Can't get attribute 'GameState' on <module
➥'__main__' from 'my_code.py'>
~~~

​		这个异常的原因是序列化对象的类的导入路径被编码在pickle的数据中:

~~~python
print(serialized)
>>>
b'\x80\x04\x95A\x00\x00\x00\x00\x00\x00\x00\x8c\x08__main__
➥\x94\x8c\tGameState\x94\x93\x94)\x81\x94}\x94(\x8c\x05level
➥\x94K\x00\x8c\x06points\x94K\x00\x8c\x05magic\x94K\x05ub.'
~~~

​		解决方案是再次使用copyreg。可以为函数指定一个稳定的标识符，用于解pickle对象。这允许在进行反序列化时将pickle的数据转换为具有不同名称的不同类。它给了一个间接的层次:

~~~python
copyreg.pickle(BetterGameState, pickle_game_state)
~~~

​		在使用copyreg之后，可以看到unpickle_game_state的导入路径被编码在序列化的数据中，而不是BetterGameState:

~~~python
state = BetterGameState()
serialized = pickle.dumps(state)
print(serialized)
>>>
b'\x80\x04\x95W\x00\x00\x00\x00\x00\x00\x00\x8c\x08__main__
➥\x94\x8c\x13unpickle_game_state\x94\x93\x94}\x94(\x8c
➥\x05level\x94K\x00\x8c\x06points\x94K\x00\x8c\x05magic\x94K
➥\x05\x8c\x07version\x94K\x02u\x85\x94R\x94.'
~~~

​		唯一的问题是不能改变unpickle_game_state函数所在模块的路径。一旦用一个函数序列化了数据，它必须在导入路径上保持可用，以便将来反序列化。

**要点**

* pickle内置模块仅用于在受信任的程序之间序列化和反序列化对象
* 如果所涉及的类随着时间的推移发生了变化(例如，添加或删除了属性)，那么先前pickle的对象的反序列化可能会中断
* 使用带有pickle的copyreg内置模块来确保序列化对象的向后兼容性

