# 第九章 测试与调试

​		Python没有编译时静态类型检查。当运行程序时，解释器中没有任何东西能够确保程序正确工作。Python确实支持可选类型注释，可在静态分析中用于检测许多类型的bug(参见第90条)。但是，从根本上讲，它仍然是一种动态语言，任何事情都是可能的。使用Python，最终不知道程序调用的函数是否在运行时定义，即使它们在源代码中明显存在。这种动态行为既是好事也是坏事。

​		大量的Python程序员都说，不进行编译时静态类型检查是值得的，因为这样做的简洁性和简单性可以提高生产率。但是，大多数使用Python的人都至少有一个可怕的情况:程序在运行时遇到愚蠢的错误。我听说过的最糟糕的例子之一是，在生产环境中动态导入(参见第88条)引发SyntaxError，导致服务器进程崩溃。我认识的被这一意外事件击中的程序员已经不再使用Python了。

​		但是我不得不想，为什么在程序部署到生产环境之前，代码没有经过更好的测试?编译时静态类型安全并不是一切。应该始终测试您的代码，无论它是用什么语言编写的。然而，我承认在Python中编写测试来验证正确性可能比在其他语言中更重要。幸运的是，这些会带来风险的动态特性也使得为代码编写测试和调试故障程序变得非常容易。可以使用Python的动态特性和易于重写的行为来实现测试，并确保程序按预期工作。

​		应该将测试视为代码的保险策略。好的测试能确信代码是正确的。如果重构或扩展代码，验证行为(而不是实现)的测试可以很容易地确定更改了什么。这听起来违反直觉，但是有好的测试实际上使修改Python代码更容易，而不是更难。

## 第75条 通过repr字符串输出调试信息

​		当调试Python程序时，print函数和格式化字符串(参见第4条)，或者通过内置的日志模块输出，会很慢。Python内部通常很容易通过普通属性访问(参见第42条)。所需要做的就是调用print来查看程序运行时的状态如何变化，并了解哪里出了问题。

​		print函数输出提供的任何内容的可读字符串版本。例如，打印一个基本字符串只打印字符串的内容，不包含引号:

~~~python
print('foo bar')
>>>
foo bar
~~~

​		这相当于所有这些替代方案:

* 在将值传递给打印之前调用str函数
* 使用'%s'格式字符串和%操作符
* 使用f字符串对值进行默认格式化
* 调用format内置函数
* 显式调用--format--特殊方法
* 显式调用--str--特殊方法

在这里，验证这个行为:

~~~python
my_value = 'foo bar'
print(str(my_value))
print('%s' % my_value)
print(f'{my_value}')
print(format(my_value))
print(my_value.__format__('s'))
print(my_value.__str__())
>>>
foo bar
foo bar
foo bar
foo bar
foo bar
foo bar
~~~

​		问题是，人类可读的值字符串并没有清楚地说明实际的类型及其具体的组合是什么。例如，注意在print的默认输出中，你不能区分数字5和字符串'5'的类型:

~~~python
print(5)
print('5')
int_value = 5
str_value = '5'
print(f'{int_value} == {str_value} ?')
>>>
5
5
5 == 5 ?
~~~

​		如果您正在用print调试一个程序，那么这些类型差异很重要。在调试时，几乎总是希望看到对象的repr版本。repr内置函数返回对象的可打印表示，这应该是它最容易理解的字符串表示。对于大多数内置类型，repr返回的字符串是一个有效的Python表达式:

~~~python
a = '\x07'
print(repr(a))
>>>
'\x07'
~~~

​		将repr的值传递给eval内置函数应该会得到与开始时使用的相同的Python对象(当然，在实践中应该非常小心地使用eval):

~~~python
b = eval(repr(a))
assert a == b
~~~

​		在使用print进行调试时，应该在打印之前对一个值调用repr，以确保类型之间的任何差异都是清楚的：

~~~python
print(repr(5))
print(repr('5'))
>>>
5
'5'
~~~

​		这相当于在%操作符中使用'%r'格式字符串或在!r类型转换中使用fstring:

~~~python
print('%r' % 5)
print('%r' % '5')
int_value = 5
str_value = '5'
print(f'{int_value!r} != {str_value!r}')
>>>
5
'5'
5 != '5'
~~~

​		对于Python类的实例，人类可读的默认字符串值与repr值相同。这意味着传递一个实例给print将会做正确的事情，并且不需要显式地对它调用repr。不幸的是，对象子类的repr的默认实现并不是特别有用。例如，这里定义了一个简单的类，然后打印它的一个实例:

```python
class OpaqueClass:
    def __init__(self, x, y):
        self.x = x
        self.y = y

obj = OpaqueClass(1, 'foo')
print(obj)
>>>
<__main__.OpaqueClass object at 0x10963d6d0>
```

​		这个输出不能传递给eval函数，而且它没有说明对象的实例字段。

​		这个问题有两种解决方案。如果控制了这个类，可以定义你自己的--repr--特殊方法，它返回一个包含重新创建对象的Python表达式的字符串。这里，我为上面的类定义了这个函数:

```python
class BetterClass:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return f'BetterClass({self.x!r}, {self.y!r})'
```

​		现在repr值更有用了:

~~~python
obj = BetterClass(2, 'bar')
print(obj)
>>>
BetterClass(2, 'bar')
~~~

​		当不能控制类定义时，可以进入对象的实例字典，它存储在--dict--属性中。在这里，打印了一个paqueClass实例的内容:

~~~python
obj = OpaqueClass(4, 'baz')
print(obj.__dict__)
>>>
{'x': 4, 'y': 'baz'}
~~~

**要点**

* 在内置Python类型上调用print会生成可读的字符串版本的值，它隐藏了类型信息
* 在内置Python类型上调用repr会生成一个值的可打印字符串版本。这些repr字符串通常可以传递给eval内置函数以获得原始值
* 格式字符串中的%s会产生像str这样的可读字符串。%r会产生像repr这样的可打印字符串。f -字符串生成可用于替换文本表达式的可读字符串，除非您指定!r后缀
* 可以在类上定义--repr--特殊方法来定制实例的可打印表示，并提供更详细的调试信息

## 第76条　在TestCase子类里验证相关的行为

​		在Python中编写测试的规范方法是使用unittest内置模块。例如，假设在utils.py中定义了以下实用函数，我想验证它在各种输入中正确工作:

 *utils.py*

```python
def to_str(data):
    if isinstance(data, str):
        return data
    elif isinstance(data, bytes):
        return data.decode('utf-8')
    else:
        raise TypeError('Must supply str or bytes, '
                        'found: %r' % data)
```

​		为了定义测试，创建了名为test_utils.py或utils_test.py的第二个文件(您更喜欢的命名方案是一种样式选择)，它包含所期望的每个行为的测试:

*utils_test.py*

```python
from unittest import TestCase, main

from example_code.item_76.testing.utils import to_str


class UtilsTestCase(TestCase):
    def test_to_str_bytes(self):
        self.assertEqual('hello', to_str(b'hello'))

    def test_to_str_str(self):
        self.assertEqual('hello', to_str('hello'))

    def test_failing(self):
        self.assertEqual('incorrect', to_str('hello'))

if __name__ == '__main__':
    main()
```

​		然后，使用Python命令行运行测试文件。在这种情况下，两个测试方法通过了，一个失败了，并提供了关于出错原因的有用错误消息:

~~~python
$ python3 utils_test.py
F..
=============================================================
==
FAIL: test_failing (__main__.UtilsTestCase)
-------------------------------------------------------------
--
Traceback (most recent call last):
File "utils_test.py", line 15, in test_failing
self.assertEqual('incorrect', to_str('hello'))
AssertionError: 'incorrect' != 'hello'
- incorrect
+ hello
-------------------------------------------------------------
--
Ran 3 tests in 0.002s
FAILED (failures=1)

~~~

​		测试被组织成TestCase子类。每个测试用例都是一个以单词test开头的方法。如果测试方法运行时没有引发任何类型的Exception(包括来自assert语句的AssertionError)，则认为测试已成功通过。如果一个测试失败，TestCase子类将继续运行其他测试方法，这样您就可以全面了解所有测试是如何进行的，而不是在出现问题的第一个迹象时就停止。如果想快速迭代以修复或改进特定的测试，可以只运行该测试方法，方法是在命令行中指定测试模块中的路径:

~~~python
$ python3 utils_test.py UtilsTestCase.test_to_str_bytes
.
-------------------------------------------------------------
--
Ran 1 test in 0.000s
OK

~~~

​		还可以在特定的断点处直接从测试方法中调用调试器，以便更深入地挖掘失败的原因(参考第80条)。

​		TestCase类提供了在测试中进行断言的辅助方法，例如assertEqual用于验证是否相等，assertTrue用于验证布尔表达式，以及更多(请参阅help(TestCase)以获得完整列表)。它们比内置的断言语句更好，因为它们打印出所有的输入和输出，以帮助理解测试失败的确切原因。例如，这里有一个相同的测试用例，使用和不使用helper断言方法:

*assert_test.py*

```python
from unittest import TestCase, main
from example_code.item_76.testing.utils import to_str

class AssertTestCase(TestCase):
    def test_assert_helper(self):
        expected = 12
        found = 2 * 5
        self.assertEqual(expected, found)

    def test_assert_statement(self):
        expected = 12
        found = 2 * 5
        assert expected == found

if __name__ == '__main__':
    main()
```

​		下面哪个失败消息对您更有帮助?

~~~python
$ python3 assert_test.py
FF
=============================================================
==
FAIL: test_assert_helper (__main__.AssertTestCase)
-------------------------------------------------------------
--
Traceback (most recent call last):
File "assert_test.py", line 16, in test_assert_helper
self.assertEqual(expected, found)
AssertionError: 12 != 10
=============================================================
==
FAIL: test_assert_statement (__main__.AssertTestCase)
-------------------------------------------------------------
--
Traceback (most recent call last):
File "assert_test.py", line 11, in test_assert_statement
assert expected == found
AssertionError
-------------------------------------------------------------
--
Ran 2 tests in 0.001s
FAILED (failures=2)

~~~

​		还有一个assertRaises helper方法用于验证异常，可以作为一个上下文管理器使用在with语句中(参见第66条)。这看起来类似于try/except语句，并且非常清楚异常将在何处被抛出:

```python
from unittest import TestCase, main
from example_code.item_76.testing.utils import to_str


class UtilsErrorTestCase(TestCase):
    def test_to_str_bad(self):
        with self.assertRaises(TypeError):
            to_str(object())

    def test_to_str_bad_encoding(self):
        with self.assertRaises(UnicodeDecodeError):
            to_str(b'\xfa\xfa')

if __name__ == '__main__':
    main()
```

​		可以在TestCase子类中使用复杂的逻辑定义您自己的帮助器方法，以使测试更具可读性。只要确保方法名不以单词test开头，否则它们将像测试用例一样运行。除了调用TestCase断言方法之外，这些自定义测试帮助程序经常使用fail方法来阐明哪些假设或不变条件没有得到满足。例如，在这里定义了一个定制的测试帮助器方法，用于指定生成器的行为：

*helper_test.py*

```python
from unittest import TestCase, main

def sum_squares(values):
    cumulative = 0
    for value in values:
        cumulative += value ** 2
        yield cumulative

class HelperTestCase(TestCase):
    def verify_complex_case(self, values, expected):
        expect_it = iter(expected)
        found_it = iter(sum_squares(values))
        test_it = zip(expect_it, found_it)

        for i, (expect, found) in enumerate(test_it):
            self.assertEqual(
                expect,
                found,
                f'Index {i} is wrong')

        # Verify both generators are exhausted
        try:
            next(expect_it)
        except StopIteration:
            pass
        else:
            self.fail('Expected longer than found')

        try:
            next(found_it)
        except StopIteration:
            pass
        else:
            self.fail('Found longer than expected')

    def test_wrong_lengths(self):
        values = [1.1, 2.2, 3.3]
        expected = [
            1.1**2,
        ]
        self.verify_complex_case(values, expected)

    def test_wrong_results(self):
        values = [1.1, 2.2, 3.3]
        expected = [
            1.1**2,
            1.1**2 + 2.2**2,
            1.1**2 + 2.2**2 + 3.3**2 + 4.4**2,
        ]
        self.verify_complex_case(values, expected)

if __name__ == '__main__':
    main()
```

​		helper方法使测试用例简短易读，输出的错误消息易于理解:

~~~python
$ python3 helper_test.py
FF
=============================================================
==
FAIL: test_wrong_lengths (__main__.HelperTestCase)
-------------------------------------------------------------
--
Traceback (most recent call last):
File "helper_test.py", line 43, in test_wrong_lengths
self.verify_complex_case(values, expected)
File "helper_test.py", line 34, in verify_complex_case
self.fail('Found longer than expected')
AssertionError: Found longer than expected
=============================================================
==
FAIL: test_wrong_results (__main__.HelperTestCase)
-------------------------------------------------------------
--
Traceback (most recent call last):
File "helper_test.py", line 52, in test_wrong_results
self.verify_complex_case(values, expected)
File "helper_test.py", line 24, in verify_complex_case
f'Index {i} is wrong')
AssertionError: 36.3 != 16.939999999999998 : Index 2 is wrong
-------------------------------------------------------------
--
Ran 2 tests in 0.002s
FAILED (failures=2)

~~~

​		通常为每一组相关的测试定义一个TestCase子类。有时，每个函数都有一个TestCase子类，它有许多边界情况。其他时候，TestCase子类跨越了单个模块中的所有函数。我经常创建一个TestCase子类来测试每个基本类及其所有方法。

​		TestCase类还提供了一个subTest帮助器方法，通过在单个测试方法中定义多个测试，可以避免样板文件。这对于编写数据驱动的测试特别有帮助，并且它允许测试方法继续测试其他用例，即使其中一个失败了(类似于TestCase及其包含的测试方法的行为)。显示这个,这里定义了一个数据驱动测试的例子:

*data_driven_test.py*

```python
from unittest import TestCase, main
from example_code.item_76.testing.utils import to_str

class DataDrivenTestCase(TestCase):
    def test_good(self):
        good_cases = [
            (b'my bytes', 'my bytes'),
            ('no error', b'no error'),  # This one will fail
            ('other str', 'other str'),
        ]
        for value, expected in good_cases:
            with self.subTest(value):
                self.assertEqual(expected, to_str(value))

    def test_bad(self):
        bad_cases = [
            (object(), TypeError),
            (b'\xfa\xfa', UnicodeDecodeError),
        ]
        for value, exception in bad_cases:
            with self.subTest(value):
                with self.assertRaises(exception):
                    to_str(value)

if __name__ == '__main__':
    main()
```

​		“没有错误”测试用例失败，打印了一个有用的错误消息，但是所有其他的用例仍然被测试并确认通过:

~~~python
$ python3 data_driven_test.py
.
=============================================================
==
FAIL: test_good (__main__.DataDrivenTestCase) [no error]
-------------------------------------------------------------
--
Traceback (most recent call last):
File "testing/data_driven_test.py", line 18, in test_good
self.assertEqual(expected, to_str(value))
AssertionError: b'no error' != 'no error'
-------------------------------------------------------------
--
Ran 2 tests in 0.001s
FAILED (failures=1)

~~~

*Note*

​		根据项目的复杂性和测试需求，pytest (https://pytest.org)开源包及其大量社区插件可能特别有用。

**要点**

* 可以通过从unittest内置模块创建TestCase类的子类，并为想要测试的每个行为定义一个方法来创建测试。TestCase类上的测试方法必须以单词Test开头。
* 使用TestCase类定义的各种辅助方法(比如assertEqual)来确认测试中的预期行为，而不是使用内置的断言语句
* 考虑使用subTest帮助器方法编写数据驱动测试，以减少样板文件

## 第77条　把测试前、后的准备与清理逻辑写在setUp、tearDown、setUpModule与tearDownModule中，以防用例之间互相干扰

​		TestCase类(参见第76条)通常需要在运行测试方法之前建立测试环境;这有时被称为测试工具。为此，可以覆盖TestCase子类的setUp和tearDown方法。这些方法分别在每个测试方法之前和之后被调用，因此可以确保每个测试独立运行，这是正确测试的一个重要最佳实践。

​		例如，这里定义了一个TestCase，它在每个测试之前创建一个临时目录，并在每个测试完成后删除它的内容:

*environment_test.py*

```python
from pathlib import Path
from tempfile import TemporaryDirectory
from unittest import TestCase, main

class EnvironmentTest(TestCase):
    def setUp(self):
        self.test_dir = TemporaryDirectory()
        self.test_path = Path(self.test_dir.name)

    def tearDown(self):
        self.test_dir.cleanup()

    def test_modify_file(self):
        with open(self.test_path / 'data.bin', 'w') as f:
            f.write('hello')

if __name__ == '__main__':
    main()
```

​		当程序变得复杂时，会想要额外的测试来验证模块之间的端到端交互，而不是只测试独立的代码(使用像mock这样的工具;参见第78项:“使用模拟来测试具有复杂依赖关系的代码”)。这就是单元测试和集成测试之间的区别。在Python中，编写这两种类型的测试非常重要，原因完全相同:除非您证明了这一点，否则您无法保证您的模块能够真正协同工作。

​		一个常见的问题是，为集成测试设置测试环境在计算上可能很昂贵，可能需要大量的时钟时间。例如，可能需要启动一个数据库进程，并等待它完成索引加载，然后才能运行集成测试。这种类型的延迟使得在TestCase类的setUp和tearDown方法中为每个测试做测试准备和清理是不切实际的。

​		为了处理这种情况，unittest模块还支持模块级测试工具初始化。可以一次性配置昂贵的资源，然后在不重复初始化的情况下运行所有TestCase类及其测试方法。稍后，当模块中的所有测试都完成时，可以一次性拆除测试工具。在这里，我通过在包含TestCase类的模块中定义setUpModule和tearDownModule函数来利用这种行为:

*integration_test.py*

```python
from unittest import TestCase, main

def setUpModule():
    print('* Module setup')

def tearDownModule():
    print('* Module clean-up')

class IntegrationTest(TestCase):
    def setUp(self):
        print('* Test setup')

    def tearDown(self):
        print('* Test clean-up')

    def test_end_to_end1(self):
        print('* Test 1')

    def test_end_to_end2(self):
        print('* Test 2')

if __name__ == '__main__':
    main()
```

~~~python
--
Ran 2 tests in 0.000s
OK$ python3 integration_test.py
* Module setup
* Test setup
* Test 1
* Test clean-up
.* Test setup
* Test 2
* Test clean-up
.* Module clean-up
-------------------------------------------------------------
--
Ran 2 tests in 0.000s
OK
~~~

​		可以清楚地看到，setUpModule只由unittest运行一次，并且它发生在任何setUp方法被调用之前。类似地，tearDownModule发生在调用tearDown方法之后。

**要点**

* 同时编写单元测试(针对独立的功能)和集成测试(针对相互交互的模块)是很重要的
* 使用setUp和tearDown方法确保测试彼此隔离，并拥有一个干净的测试环境
* 对于集成测试，使用setUpModule和tearDownModule模块级函数来管理测试模块整个生命周期所需的任何测试工具，以及它包含的所有TestCase类

