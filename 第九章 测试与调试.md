# 第九章 测试与调试

​		Python没有编译时静态类型检查。当运行程序时，解释器中没有任何东西能够确保程序正确工作。Python确实支持可选类型注释，可在静态分析中用于检测许多类型的bug(参见第90条)。但是，从根本上讲，它仍然是一种动态语言，任何事情都是可能的。使用Python，最终不知道程序调用的函数是否在运行时定义，即使它们在源代码中明显存在。这种动态行为既是好事也是坏事。

​		大量的Python程序员都说，不进行编译时静态类型检查是值得的，因为这样做的简洁性和简单性可以提高生产率。但是，大多数使用Python的人都至少有一个可怕的情况:程序在运行时遇到愚蠢的错误。我听说过的最糟糕的例子之一是，在生产环境中动态导入(参见第88条)引发SyntaxError，导致服务器进程崩溃。我认识的被这一意外事件击中的程序员已经不再使用Python了。

​		但是我不得不想，为什么在程序部署到生产环境之前，代码没有经过更好的测试?编译时静态类型安全并不是一切。应该始终测试您的代码，无论它是用什么语言编写的。然而，我承认在Python中编写测试来验证正确性可能比在其他语言中更重要。幸运的是，这些会带来风险的动态特性也使得为代码编写测试和调试故障程序变得非常容易。可以使用Python的动态特性和易于重写的行为来实现测试，并确保程序按预期工作。

​		应该将测试视为代码的保险策略。好的测试能确信代码是正确的。如果重构或扩展代码，验证行为(而不是实现)的测试可以很容易地确定更改了什么。这听起来违反直觉，但是有好的测试实际上使修改Python代码更容易，而不是更难。

## 第75条 通过repr字符串输出调试信息

​		当调试Python程序时，print函数和格式化字符串(参见第4条)，或者通过内置的日志模块输出，会很慢。Python内部通常很容易通过普通属性访问(参见第42条)。所需要做的就是调用print来查看程序运行时的状态如何变化，并了解哪里出了问题。

​		print函数输出提供的任何内容的可读字符串版本。例如，打印一个基本字符串只打印字符串的内容，不包含引号:

~~~python
print('foo bar')
>>>
foo bar
~~~

​		这相当于所有这些替代方案:

* 在将值传递给打印之前调用str函数
* 使用'%s'格式字符串和%操作符
* 使用f字符串对值进行默认格式化
* 调用format内置函数
* 显式调用--format--特殊方法
* 显式调用--str--特殊方法

在这里，验证这个行为:

~~~python
my_value = 'foo bar'
print(str(my_value))
print('%s' % my_value)
print(f'{my_value}')
print(format(my_value))
print(my_value.__format__('s'))
print(my_value.__str__())
>>>
foo bar
foo bar
foo bar
foo bar
foo bar
foo bar
~~~

​		问题是，人类可读的值字符串并没有清楚地说明实际的类型及其具体的组合是什么。例如，注意在print的默认输出中，你不能区分数字5和字符串'5'的类型:

~~~python
print(5)
print('5')
int_value = 5
str_value = '5'
print(f'{int_value} == {str_value} ?')
>>>
5
5
5 == 5 ?
~~~

​		如果您正在用print调试一个程序，那么这些类型差异很重要。在调试时，几乎总是希望看到对象的repr版本。repr内置函数返回对象的可打印表示，这应该是它最容易理解的字符串表示。对于大多数内置类型，repr返回的字符串是一个有效的Python表达式:

~~~python
a = '\x07'
print(repr(a))
>>>
'\x07'
~~~

​		将repr的值传递给eval内置函数应该会得到与开始时使用的相同的Python对象(当然，在实践中应该非常小心地使用eval):

~~~python
b = eval(repr(a))
assert a == b
~~~

​		在使用print进行调试时，应该在打印之前对一个值调用repr，以确保类型之间的任何差异都是清楚的：

~~~python
print(repr(5))
print(repr('5'))
>>>
5
'5'
~~~

​		这相当于在%操作符中使用'%r'格式字符串或在!r类型转换中使用fstring:

~~~python
print('%r' % 5)
print('%r' % '5')
int_value = 5
str_value = '5'
print(f'{int_value!r} != {str_value!r}')
>>>
5
'5'
5 != '5'
~~~

​		对于Python类的实例，人类可读的默认字符串值与repr值相同。这意味着传递一个实例给print将会做正确的事情，并且不需要显式地对它调用repr。不幸的是，对象子类的repr的默认实现并不是特别有用。例如，这里定义了一个简单的类，然后打印它的一个实例:

```python
class OpaqueClass:
    def __init__(self, x, y):
        self.x = x
        self.y = y

obj = OpaqueClass(1, 'foo')
print(obj)
>>>
<__main__.OpaqueClass object at 0x10963d6d0>
```

​		这个输出不能传递给eval函数，而且它没有说明对象的实例字段。

​		这个问题有两种解决方案。如果控制了这个类，可以定义你自己的--repr--特殊方法，它返回一个包含重新创建对象的Python表达式的字符串。这里，我为上面的类定义了这个函数:

```python
class BetterClass:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return f'BetterClass({self.x!r}, {self.y!r})'
```

​		现在repr值更有用了:

~~~python
obj = BetterClass(2, 'bar')
print(obj)
>>>
BetterClass(2, 'bar')
~~~

​		当不能控制类定义时，可以进入对象的实例字典，它存储在--dict--属性中。在这里，打印了一个paqueClass实例的内容:

~~~python
obj = OpaqueClass(4, 'baz')
print(obj.__dict__)
>>>
{'x': 4, 'y': 'baz'}
~~~

**要点**

* 在内置Python类型上调用print会生成可读的字符串版本的值，它隐藏了类型信息
* 在内置Python类型上调用repr会生成一个值的可打印字符串版本。这些repr字符串通常可以传递给eval内置函数以获得原始值
* 格式字符串中的%s会产生像str这样的可读字符串。%r会产生像repr这样的可打印字符串。f -字符串生成可用于替换文本表达式的可读字符串，除非您指定!r后缀
* 可以在类上定义--repr--特殊方法来定制实例的可打印表示，并提供更详细的调试信息

