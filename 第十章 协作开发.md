# 第十章 协作开发

​		Python具有一些语言特性，可以帮助构造定义良好、具有清晰接口边界的api。Python社区已经建立了最佳实践来最大化代码的可维护性。此外，Python附带的一些标准工具使大型团队能够跨不同的环境一起工作。

​		在Python程序上与他人协作需要在编写代码时慎重考虑。即使正在独立工作，也有可能使用其他人通过标准库或开放源码包编写的代码。理解使与其他Python程序员易于协作的机制是很重要的。

## 第82条 学会寻找由其他Python开发者所构建的模块

  	Python有一个中央模块库(https://pypi.org)，你可以在你的程序中安装和使用它。这些模块是由像您这样的人构建和维护的:Python社区。当您发现自己面临一个不熟悉的挑战时，Python Package Index (PyPI)是一个查找代码的好地方，可以帮助您更接近您的目标。

​		要使用包索引，需要使用命令行工具pip(“pip安装包”的递归首字母缩写)。pip可以与python3 -m pip一起运行，以确保在您的系统上安装了正确版本的Python包(参见第1项:“知道您使用的Python版本”)。使用pip安装新模块很简单。例如，我在这里安装了我在本书其他地方使用的pytz模块(参见第67项:“使用datetime代替本地时钟的时间”):

~~~sh
$ python3 -m pip install pytz
Collecting pytz
Downloading ...
Installing collected packages: pytz
Successfully installed pytz-2018.9
~~~

​		pip最好与内置模块venv一起使用，以一致地跟踪要为项目安装的包集(参见第83项:“为隔离和可重复依赖使用虚拟环境”)。您还可以创建自己的PyPI包，与Python社区共享，或托管自己的私有包存储库，以便与pip一起使用。

​		PyPI中的每个模块都有自己的软件许可证。大多数软件包，特别是流行的软件包，都有免费或开源许可证(详情请参阅https://opensource.org)。在大多数情况下，这些许可证允许你在你的程序中包含一个模块的副本;如果有疑问，去找律师。

**要点**

* Python包索引(PyPI)包含了大量由Python社区构建和维护的通用包
* pip是可以用于从PyPI安装包的命令行工具
* 大多数PyPI模块都是免费的开源软件

## 第83条　用虚拟环境隔离项目，并重建依赖关系

​		构建更大更复杂的程序通常会导致依赖于来自Python社区的各种包(见第82项:“知道在哪里找到社区构建模块”)。会发现自己正在运行python3 -m pip命令行工具来安装诸如pytz、numpy等包。

​		问题是，在默认情况下，pip会在全局位置安装新包。这会导致系统上的所有Python程序都受到这些已安装模块的影响。理论上，这不应该是一个问题。如果安装了一个包，却从不导入它，它会如何影响你的程序呢?

​		问题来自于传递依赖:安装的包所依赖的包。例如，在安装Sphinx包后，可以通过询问pip来查看它依赖于什么:

~~~sh
$ python3 -m pip show Sphinx
Name: Sphinx
Version: 2.1.2
Summary: Python documentation generator
Location: /usr/local/lib/python3.8/site-packages
Requires: alabaster, imagesize, requests,
➥ sphinxcontrib-applehelp, sphinxcontrib-qthelp,
➥ Jinja2, setuptools, sphinxcontrib-jsmath,
➥ sphinxcontrib-serializinghtml, Pygments, snowballstemmer,
➥ packaging, sphinxcontrib-devhelp, sphinxcontrib-htmlhelp,
➥ babel, docutils
Required-by:
~~~

​		如果安装了另一个包，比如flask，会发现它也依赖于jinj2包:

~~~sh
$ python3 -m pip show flask
Name: Flask
Version: 1.0.3
Summary: A simple framework for building complex web
applications.
Location: /usr/local/lib/python3.8/site-packages
Requires: itsdangerous, click, Jinja2, Werkzeug
Required-by:
~~~

​		随着时间的推移，Sphinx和flask可能会产生依赖冲突。也许现在它们都需要相同版本的jinj2，一切都很好。但是六个月或一年之后，jinj2可能会发布一个新版本，对库的用户做出破坏性的改变。如果使用python3 -m pip install——upgrade jinj2更新jinj2的全局版本，可能会发现Sphinx崩溃，而flask继续工作。

​		造成这种破坏的原因是Python一次只能安装一个模块的全局版本。如果安装的一个软件包必须使用新版本，而另一个软件包必须使用旧版本，系统将无法正常工作;这种情况通常被称为依赖地狱。

​		这样的破坏甚至可能发生在包维护者尽力保持不同版本之间API的兼容性时(见第85项:“使用包来组织模块和提供稳定的API”)。库的新版本可以微妙地改变使用api的代码所依赖的行为。系统上的用户可以将一个包升级到新版本，但不能将其他包升级到新版本，这可能会打破依赖关系。如果你不小心，你脚下的土地就有不断移动的危险。

​		当与在单独的计算机上工作的其他开发人员合作时，这些困难会被放大。最好做最坏的假设:他们在机器上安装的Python和全局包的版本将与你的稍有不同。这可能会导致一些令人沮丧的情况，比如代码库在一个程序员的机器上完美运行，但在另一个程序员的机器上却完全崩溃。

​		所有这些问题的解决方案是使用一种名为venv的工具，它提供了虚拟环境。从Python 3.4开始，pip和venv模块默认随Python安装一起可用(可通过Python -m venv访问)。

​		venv允许创建Python环境的独立版本。使用venv，可以在同一系统上同时安装同一包的多个不同版本，而不会产生冲突。这意味着可以在同一台计算机上从事许多不同的项目并使用许多不同的工具。Venv通过将软件包的显式版本及其依赖项安装到完全独立的目录结构中来实现这一点。这使得重新生成一个与代码一起工作的Python环境成为可能。这是避免意外破裂的可靠方法

*Using venv on the Command Line*

​		这里有一个关于如何有效使用venv的快速教程。在使用该工具之前，一定要注意系统上python3命令行的含义。在我的计算机上，python3位于/usr/local/bin目录下，并计算为3.8.0版本(见第1项:“知道你使用的Python的哪个版本”):

~~~sh
$ which python3
/usr/local/bin/python3
$ python3 --version
Python 3.8.0
~~~

​		为了演示环境的设置，可以测试运行导入pytz模块的命令不会导致错误。这是可行的，因为已经安装了pytz包作为全局模块:

~~~sh
$ python3 -c 'import pytz'
$
~~~

​		现在，使用venv创建一个名为myproject的新虚拟环境。每个虚拟环境必须位于其自己的惟一目录中。该命令的结果是一个目录和文件树，用于管理虚拟环境:

~~~sh
$ python3 -m venv myproject
$ cd myproject
$ ls
bin include lib pyvenv.cfg
~~~

​		为了开始使用虚拟环境，使用shell中的bin/activate脚本中的source命令。Activate修改所有环境变量以匹配虚拟环境。它还更新了命令行提示符，包括虚拟环境名称(" myproject ")，以使它非常清楚我正在做什么:

~~~sh
$ source bin/activate
(myproject)$
~~~

在Windows上，相同的脚本如下所示:

~~~sh
C:\> myproject\Scripts\activate.bat
(myproject) C:>
~~~

或者使用powershell：

~~~sh
PS C:\> myproject\Scripts\activate.ps1
(myproject) PS C:>
~~~

激活后，python3命令行工具的路径已经移动到虚拟环境目录中:

~~~python
(myproject)$ which python3
/tmp/myproject/bin/python3
(myproject)$ ls -l /tmp/myproject/bin/python3
... -> /usr/local/bin/python3.8
~~~

​		这确保了对外部系统的更改不会影响虚拟环境。即使外部系统将其默认的python3升级到版本3.9，我的虚拟环境仍然显式地指向版本3.8。

​		使用venv创建的虚拟环境开始时没有安装任何包，除了pip和setuptools。尝试在外部系统中使用作为全局模块安装的pytz包将会失败，因为它对虚拟环境是未知的:

~~~python
(myproject)$ python3 -c 'import pytz'
Traceback (most recent call last):
File "<string>", line 1, in <module>
ModuleNotFoundError: No module named 'pytz'
~~~

​		可以使用pip命令行工具将pytz模块安装到虚拟环境中:

~~~python
(myproject)$ python3 -m pip install pytz
Collecting pytz
Downloading ...
Installing collected packages: pytz
Successfully installed pytz-2019.1
~~~

​		安装后，可以使用相同的test import命令来验证它是否正常工作:

~~~python
(myproject)$ python3 -c 'import pytz'
(myproject)$
~~~

​		当使用完虚拟环境并想回到默认系统时，使用deactivate命令。这将环境恢复到系统默认值，包括python3命令行工具的位置:

~~~python
(myproject)$ which python3
/tmp/myproject/bin/python3
(myproject)$ deactivate
$ which python3
/usr/local/bin/python3
~~~

​		如果想再次在我的项目环境中工作，我可以像以前一样在目录中运行source bin/activate。

*Reproducing Dependencies*

​		在虚拟环境中之后，可以继续使用pip在其中安装需要的包。最终，可能希望将环境复制到其他地方。例如，假设想从工作站在数据中心的服务器上重现开发环境。或者想在自己的机器上克隆其他人的环境，以便帮助调试他们的代码。

​		Venv使这些任务变得容易。可以使用python3 -m pip freeze命令将所有显式的包依赖项保存到一个文件中(按照约定，该文件名为requirements.txt):

~~~python
(myproject)$ python3 -m pip freeze > requirements.txt
(myproject)$ cat requirements.txt
certifi==2019.3.9
chardet==3.0.4
idna==2.8
numpy==1.16.2
pytz==2018.9
requests==2.21.0
urllib3==1.24.1
~~~

​		现在，假设希望有另一个与项目环境相匹配的虚拟环境。可以像以前一样使用venv创建一个新目录并激活它:

~~~python
$ python3 -m venv otherproject
$ cd otherproject
$ source bin/activate
(otherproject)$
~~~

​		新环境中不会安装额外的包:

~~~python
(otherproject)$ python3 -m pip list
Package Version
---------- -------
pip 10.0.1
setuptools 39.0.1
~~~

​		可以安装来自第一个环境的所有包，通过在用python3 -m pip freeze命令生成的require .txt中运行python3 -m pip install:

~~~python
(otherproject)$ python3 -m pip install -r /tmp/myproject/
➥ requirements.txt
~~~

​		在检索和安装重现第一个环境所需的所有包时，这个命令会运行一段时间。当它完成时，可以在第二个虚拟环境中列出已安装的软件包集，应该会看到在第一个虚拟环境中找到的相同的依赖项列表:

~~~sh
(otherproject)$ python3 -m pip list
Package Version
---------- --------
certifi 2019.3.9
chardet 3.0.4
idna 2.8
numpy 1.16.2
pip 10.0.1
pytz 2018.9
requests 2.21.0
setuptools 39.0.1
urllib3 1.24.1
~~~

​		使用requirements.txt文件是通过修订控制系统与他人协作的理想选择。可以在更新包依赖项列表的同时提交对代码的更改，以确保它们同步移动。但是，需要注意的是，您正在使用的特定版本的Python没有包含在requirements.txt文件中，因此必须单独管理。

​		虚拟环境的问题是，移动它们会破坏一切，因为所有路径(比如python3命令行工具)都硬编码到环境的安装目录中。但最终这个限制无关紧要。虚拟环境的全部目的是使重新创建设置变得容易。不需要移动虚拟环境目录，只需在旧目录上使用python3 -m pip freeze，在其他地方创建一个新的虚拟环境，并从require .txt文件中重新安装所有内容。

**要点**

* 虚拟环境允许您使用pip在同一台机器上安装相同包的多个不同版本，而不会发生冲突
* 使用python -m venv创建虚拟环境，使用source bin/activate启用，使用deactivate禁用
* 可以使用python3 -m pip freeze转储环境的所有需求；可以通过运行python3 -m pip install -r requirements.txt来重现一个环境

## 第84条　每一个函数、类与模块都要写docstring

​		由于Python语言的动态特性，Python中的文档是极其重要的。Python为将文档附加到代码块提供了内置支持。与许多其他语言不同的是，在程序运行时，可以直接访问来自程序源代码的文档。

​		例如，可以通过在函数的def语句后提供一个文档字符串来添加文档:

```python
def palindrome(word):
    """Return True if the given word is a palindrome."""
    return word == word[::-1]

assert palindrome('tacocat')
assert not palindrome('banana')
```

​		可以通过访问函数的--doc--特殊属性从Python程序中检索文档字符串:

```python
print(repr(palindrome.__doc__))
>>>
'Return True if the given word is a palindrome.'
```

​		也可以从命令行使用内置的pydoc模块来运行本地的web服务器，它承载了你的解释器可以访问的所有Python文档，包括编写的模块:

~~~sh
$ python3 -m pydoc -p 1234
Server ready at http://localhost:1234/
Server commands: [b]rowser, [q]uit
server> b
~~~

​		文档字符串可以附加到函数、类和模块。此连接是编译和运行Python程序过程的一部分。对文档字符串和--doc--属性的支持有三个后果:

* 文档的可访问性使交互式开发更加容易。可以使用内置函数help检查函数、类和模块，以查看它们的文档。这使得Python交互式解释器(Python“shell”)和像IPython Notebook (https://ipython.org)这样的工具在开发算法、测试api和编写代码片段时使用起来非常愉快
* 定义文档的标准方法使构建将文本转换为更吸引人的格式(如HTML)的工具变得容易。这为Python社区带来了优秀的文档生成工具，例如Sphinx (https://www.sphinx-doc.org)。它还支持社区资助的网站，如Read the Docs (https://readthedocs.org)，这些网站为开源Python项目提供免费的漂亮的文档托管
* Python的一流的、可访问的、漂亮的文档鼓励人们编写更多的文档。Python社区的成员对文档的重要性有着强烈的信念。有一种假设是，“好的代码”也意味着良好文档化的代码。这意味着可以期望大多数开源Python库都有像样的文档

​		要参与这种优秀的文档文化，在编写文档字符串时需要遵循一些指导原则。详细内容可在PEP 257(https://www.python.org/dev/peps/pep-0257/上在线讨论)。这里有一些您应该确保遵循的最佳实践。

*Documenting Modules*

​		每个模块都应该有一个顶级文档字符串——一个字符串字面量，它是源文件中的第一个语句。它应该使用三个双引号(“”)。这个文档字符串的目标是介绍模块及其内容。

​		文档字符串的第一行应该是一个描述模块用途的句子。接下来的段落应该包含模块的所有用户应该知道的关于其操作的详细信息。模块docstring也是一个起点，可以在这里突出显示模块中发现的重要类和函数。

```python
# words.py
#!/usr/bin/env python3
"""Library for finding linguistic patterns in words.

Testing how words relate to each other can be tricky sometimes!
This module provides easy ways to determine when words you've
found have special properties.

Available functions:
- palindrome: Determine if a word is a palindrome.
- check_anagram: Determine if two words are anagrams.
...
"""
```

​		如果模块是一个命令行实用程序，模块docstring也是放置用于运行该工具的使用信息的好地方。

*Documenting Classes*

​		每个类都应该有一个类级别的文档字符串。这在很大程度上遵循与模块级文档字符串相同的模式。第一行是类的单句目的。接下来的段落讨论了类操作的重要细节。

​		类的重要公共属性和方法应该在类级文档字符串中突出显示。它还应该指导子类如何正确地与受保护的属性交互(参见第42项:“优先使用公共属性而不是私有属性”)和超类的方法。

下面是类docstring的一个例子:

~~~python
class Player:
    """Represents a player of the game.
    Subclasses may override the 'tick' method to provide
    custom animations for the player's movement depending
    on their power level, etc.
    Public attributes:
    - power: Unused power-ups (float between 0 and 1).
    - coins: Coins found during the level (integer).
    """
    ...

~~~

*Documenting Functions*

​		每个公共函数和方法都应该有一个文档字符串。这与模块和类的文档字符串遵循相同的模式。第一行用一句话描述了函数的功能。接下来的段落应该描述函数的任何特定行为和参数。应该提到任何返回值。应该解释调用方必须作为函数接口的一部分处理的任何异常(参见第20项:“首选引发异常而不是返回None”，了解如何记录引发的异常)。

​		下面是一个docstring函数的例子:

```python
import itertools
def find_anagrams(word, dictionary):
    """Find all anagrams for a word.

    This function only runs as fast as the test for
    membership in the 'dictionary' container.

    Args:
        word: String of the target word.
        dictionary: collections.abc.Container with all
            strings that are known to be actual words.

    Returns:
        List of anagrams that were found. Empty if
        none were found.
    """
    permutations = itertools.permutations(word, len(word))
    possible = (''.join(x) for x in permutations)
    found = {word for word in possible if word in dictionary}
    return list(found)

assert find_anagrams('pancakes', ['scanpeak']) == ['scanpeak']
```

​		在为函数编写文档字符串时，也有一些特殊情况需要了解:

* 如果函数没有参数和一个简单的返回值，一个单句描述可能就足够了
* 如果一个函数不返回任何东西，最好不要提及返回值，而不是说“返回None”
* 如果一个函数的接口包含引发异常(参见第20项:“首选引发异常而不是返回None”)，它的文档字符串应该描述每个被引发的异常以及何时被引发
* 如果不希望一个函数在正常操作期间引发异常，就不要提及这个事实
* 如果一个函数接受可变数量的参数(见项目22:“用可变位置参数减少视觉噪声”)或关键字参数(见项目23:“用关键字参数提供可选行为”)，在参数的文档列表中使用*args和**kwargs来描述它们的目的
* 如果函数有默认值的参数，这些默认值应该被提到(见项目24:使用None和文档字符串来指定动态默认参数")
* 如果一个函数是一个生成器(见第30项:“考虑生成器而不是返回列表”)，它的文档字符串应该描述生成器在迭代时产生的内容
* 如果一个函数是一个异步协程(参见第60项:“用协程实现高并发I/O”)，它的文档字符串应该解释它何时将停止执行

*Using Docstrings and Type Annotations*

​		Python现在支持多种用途的类型注释(参见第90项:“考虑通过类型进行静态分析以消除bug”了解如何使用类型注释)。对于典型的文档字符串，它们包含的信息可能是多余的。例如，下面是应用了类型注释的find_anagram的函数签名:

```python
# Check types in this file with: python -m mypy <path>

from typing import Container, List

def find_anagrams(word: str,
                  dictionary: Container[str]) -> List[str]:
    pass
```

​		不再需要在文档字符串中指定word参数是字符串，因为类型注释具有该信息。对于collections.abc.Container的dictionary参数也是如此。没有理由提到返回类型将是列表，因为这个事实已经有明确的注释。当没有找到字谜时，返回值仍然必须是一个列表，因此这意味着它将是空的;在文档字符串中不需要注意这一点。在这里，从上面写了相同的函数签名，并相应地缩短了文档字符串:

```python
from typing import Container, List

def find_anagrams(word: str,
                  dictionary: Container[str]) -> List[str]:
    """Find all anagrams for a word.

    This function only runs as fast as the test for
    membership in the 'dictionary' container.

    Args:
        word: Target word.
        dictionary: All known actual words.

    Returns:
        Anagrams that were found.
    """
    pass
```

​		对于实例字段、类属性和方法，应该类似地避免类型注释和文档字符串之间的冗余。最好将类型信息只放在一个地方，这样就减少了它偏离实际实现的风险。

**要点**

* 使用文档字符串为每个模块、类、方法和函数编写文档。当您的代码发生变化时，请保持它们是最新的
* 对于模块:引入模块的内容和所有用户应该知道的任何重要类或函数
* 对于类:文档行为、重要属性和class语句后面的文档字符串中的子类行为
* 对于函数和方法:在def语句之后的文档字符串中记录每个参数、返回值、引发的异常和其他行为
* 如果正在使用类型注释，请忽略文档字符串中已经存在于类型注释中的信息，因为在两个地方都有它是多余的

