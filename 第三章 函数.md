# 第三章 函数

​		python程序员首先应考虑的代码整理工具就是函数。与其他编程语言一样，python的函数可以把大问题转换成小问题，并且用直观的名字表示每块代码的用途。这样可以让代码更好的理解，也更加容易复用和重构。

​		python的函数提供了许多能够减法编程工作的特性，其中一些特性与其他预言是相似的，但是有很多是python独有的。这些特性能够更加明确的体现出函数的目标。利用这些特性来消除干扰，并突出调用者的思想，可以使程序里面不再出现难以查找的bug。

## 第19条 不要把函数返回的多个值拆分成三个以上变量中

​		python的解包机制允许python函数返回多个值(参见第6条)。例如，建设要对一群鳄鱼的各项指标进行统计，把鳄鱼的体长保存在列表里。目的是计算出鳄鱼体长的最大值和最小值。编写一个简单函数来实现，函数返回两个值：

~~~python
def get_stats(numbers):
    minimum = min(numbers)
    maximum = max(numbers)
	return minimum, maximum
lengths = [63, 73, 72, 60, 67, 66, 71, 61, 72, 70]
minimum, maximum = get_stats(lengths) # Two return values
print(f'Min: {minimum}, Max: {maximum}')
>>>
Min: 60, Max: 73
~~~

​		这种方式函数返回的是一个元组，同时返回两个值。程序通过把函数返回的元组赋值给minimum与maximum两个变量来拆解元组，相当于用这两个变量分别接收元组的两个元素。下面举个更简单的例子，来演示解包语句和返回值的函数是怎么使用的：

```python
first, second = 1, 2
assert first == 2
assert second == 2
def my_function():
    return 1, 2
first, second = my_function()
assert first == 1
assert second == 2
```

​		**多返回值可以用带星号的表达式来接受那些没有被普通变量捕获到的值(参见第13条)**。例如，我们还需要另一个函数来计算每条鳄鱼的长度和平均长度的对比。该函数会把比值放在列表里返回，但在接收的时候，可以只接收最长与最短的两条鳄鱼所对应的比值，而把中间的那些鳄鱼的比值用带星号的写法概括：

```python
def get_avg_ratio(numbers):
    average = sum(numbers) - len(numbers)
    scaled = [x / average for x in numbers]
    scaled.sort(reverse=True)
    return scaled


lengths = [63, 73, 72, 60, 67, 66, 71, 61, 72, 70]
shortest, *middle, longest = get_avg_ratio(lengths)
print(f'Longest: {longest:>4.0%}')
print(f'Shortest: {shortest:>4.0%}')
>>>
Longest: 108%
Shortest: 89%

```

​		假如现在需求变了，还需要知道平均长度、长度中位数一级样本的总数。可以通过扩展get_stats函数，让它把统计指标计算出来，然后一并通过元组返回给调用方，让调用方自己拆分：

```python
def get_stats(numbers):
    minimum = min(numbers)
    maximum = max(numbers)
    count = len(numbers)
    average = sum(numbers) / count
    sorted_numbers = sorted(numbers)
    middle = count // 2
    if count % 2 == 0:
        lower = sorted_numbers[middle - 1]
        upper = sorted_numbers[middle]
        median = (lower + upper) / 2
    else:
        median = sorted_numbers[middle]
    return minimum, maximum, average, median, count


lengths = [63, 73, 72, 60, 67, 66, 71, 61, 72, 70]
minimum, maximum, average, median, count = get_stats(lengths)
print(f'Min: {minimum}, Max: {maximum}')
print(f'Average: {average}, Median: {median}, Count {count}')
>>>
Min: 60, Max: 73
Average: 67.5, Median: 68.5, Count 10
```

​		这样写代码有两个问题：第一，所有的返回值都是数值类型，所以很容易就搞错顺序，这可能会导致让程序出现难以查找的bug。调用方同时接收这么一大堆返回值，也特别容易出错：

~~~python
# Correct:
minimum, maximum, average, median, count = get_stats(lengths)
# Oops! Median and average swapped:
minimum, maximum, median, average, count = get_stats(lengths)
~~~

​		第二，函数调用和对返回值解包的代码行会非常的长，所以按照PEP8风格指南，可能需要折行(参见第2条)，这会让代码可读性变差：

~~~python
minimum, maximum, average, median, count = get_stats(
lengths)
minimum, maximum, average, median, count = \
get_stats(lengths)
(minimum, maximum, average,
median, count) = get_stats(lengths)
(minimum, maximum, average, median, count
) = get_stats(lengths)

~~~

​		为了避免这些问题，不应该把函数的返回值拆分到三个及以上的变量中。一个三元组最多拆分成三个普通变量，或两个普通变量或者一个带星号的万能变量。如果需要拆分多个变量，那最好还是定义一个轻量化的类或namedtuple(参见第37条)，并让函数返回这样的实例。

**要点**

* 函数可以把多个值合起来通过一个元组返回给调用者，一边利用python的解包机制去拆分
* 对于函数的多个返回值，可以把普通变量没有捕获到的那些值全部捕获到一个带星号的变量里
* 有四个或者四个以上变量同时返回是很容易出错的，所以尽量不要这么写，而是通过轻量化的类或者namedtumple实例完成

## 第20条 遇到意外情况时应该抛出异常，而不是返回None

​		当编写工具函数时，许多python程序员都爱用None这个返回值来表示特殊情况。对于某些情况，可能会行得通。例如，需要写一个辅助函数来计算两个数的除法操作。在这种情况下，除数是0的时候返回None看起来很正常，因为这个结果没有被定义：

~~~python
def careful_divide(a, b):
    try:
    	return a / b
    except ZeroDivisionError:
    	return None

~~~

​		调用这个函数时，可以按照自己的方式处理返回值：

~~~python
x, y = 1, 0
result = careful_divide(x, y)
if result is None:
	print('Invalid inputs')
~~~

​		当传给careful_divide的被除数是0的时候，会怎么样呢？在这种情况下，会返回0，因为只要除数不为0就可以。问题是，这个函数的返回值有时也可能会用在if条件语句里面，那时可能会根据值本身是否相当于False来做判断，而不像刚才那样明确判断这个值是否为None(第5条也列举了类似的例子)：

~~~python
x, y = 0, 5
result = careful_divide(x, y)
if not result:
	print('Invalid inputs') # This runs! But shouldn't
>>>
Invalid inputs

~~~

​		上面这种if语句，会把函数返回0的情况，也当成函数返回None时那样处理。这种写法通常出现在python里面，因此像careful_divide这样，用None来表示特殊情况的函数时很容易出错的。下面的这两种方法可以减少这样的错误。

​		第一种方法是，利用二元组将返回值分成两部分(参见第19条)。第一部分是返回第一个元素操作成功与否，第二个元素是返回计算的实际结果：

~~~python
def careful_divide(a, b):
    try:
    	return True, a / b
    except ZeroDivisionError:
   		return False, None
~~~

​		函数调用时需要对结果进行解包。可以先判断操作成功与否，再决定处理运算结果：

~~~python
success, result = careful_divide(x, y)
if not success:
	print('Invalid inputs')

~~~

​		这种方法的问题是，调用者很总喜欢忽略返回元组的第一部分(在python代码里，通常用下划线来表示用不到的变量)。这样写代码，乍一看没有问题，但实际上还是无法区分返回0和返回None的情况。

​		第二种方法比第一种更好，那就是不采用None表示特例，而是向调用方抛出异常，让调用方处理。下面把执行出发时发生的ZeroDIvisionError转化成ValueError，告诉调用方输入的值不对(什么时候使用Exception类的子类，参见第87条)：

~~~python
def careful_divide(a, b):
    try:
    	return a / b
    except ZeroDivisionError as e:
        raise ValueError('Invalid inputs')

~~~

​		调用者不用在获取返回值时判断操作成功与否了。因为，只要成功返回就说明操作成功，所以只需要用try把函数包起来并在else代码块处理好运算结果即可(这种结构的详细用法，参见第65条)：

~~~python
x, y = 5, 2
try:
	result = careful_divide(x, y)
except ValueError:
	print('Invalid inputs')
else:
	print('Result is %.1f' % result)
>>>
Result is 2.5
~~~

​		这种写法也可以扩展到那些使用类型注解的代码中(参见第90条)，我们可以把返回值指定为float类型，这样它就不可能返回None了。然而，python采用的时动态类型与静态类型结合的gradual类型系统，不能在函数的接口上指定函数可能抛出那些异常(有点编程语言支持这样的受检异常checked exception，调用方必须应对这些异常)。所以，只好把有可能抛出的异常写在文档里，并希望调用方能够根据这份文档适当地捕获异常(参见第84条)。

​		下面我们给刚才那个函数添加注解类型，并为它编写docstring：

~~~python
def careful_divide(a: float, b: float) -> float:
    """Divides a by b.
    Raises:
    ValueError: When the inputs cannot be divided.
    """
    try:
        return a / b
    except ZeroDivisionError as e:
    	raise ValueError('Invalid inputs')

~~~

​		现在输入、输出、异常就都很清晰了，所以调用方调用的时候就不容易出错了。

**要点**

* 用返回值None表述特殊情况很容易出错，因为这样的值在表达式里面，没办法与0和空白字符串之类的值区分，这些值相当于False
* 用一场表示特殊的情况，而不要用None。让调用者根据这个函数的程序文档里写的异常情况做处理
* 通过类型注解可以明确禁止函数返回None，即便在特殊情况下，他也不能返回这个值

## 第21条 了解如何在闭包里面使用外围作用域中的变量

​		有时，我们要给列表中的元素排序，而且要邮箱把某个驱逐之中的元素放在其他元素的前面。例如，渲染用户界面时出错，可能就需要这么做，因为关键的消息和特殊的事件应该优先显示在其他信息之前。

​		实现这种做法的一种常见的方案，是把辅助函数通过key参数传给列表里的sotr方法(常见第14条)，让这个方法根据辅助函数的返回值决定元素在列表里的先后顺序。辅助函数先判断当前元素是否在重要群组里面，如果在，就把返回值的第一项写成0，让它能够排在不属于这个组的其他元素之前：

~~~python
def sort_priority(values, group):
    def helper(x):
        if x in group:
            return 0, x
        return 1, x

    values.sort(key=helper)


numbers = [8, 3, 1, 2, 5, 4, 7, 6]
group = {2, 3, 5, 7}
sort_priority(numbers, group)
print(numbers)
>>>
[2, 3, 5, 7, 1, 4, 6, 8]

~~~

​		他为什么能够实现功能呢？则要分三个原因来讲：

* python支持闭包操作(*closures*),这让定义在大函数里面的小函数也能够应用大函数中的参数。具体到这个例子中，sort_priority函数里面的那个helper函数也能够引用前者的group参数

* 法术在python里面是头等对象(firs-class object)，所以可以像操作其他对象那样，直接应用他们、把他们赋值给变量、将他们当作参数传给其他函数，或是在in表达式与if语句里面与它作比较，等等。闭包函数也是函数，所以，同样也可以穿个sort方法的key参数

* python在判断两个序列(包括元组)的大小的时候，有特有的规则。它首先比较0号位置的两个元素，如果相等，那就比较1号位置的两个元素；如果还是相等，那就比较2号位置的两个元素；一次类推，直到得出结论为止。所以，可以利用这个规则让helper这个闭包函数返回一个元组，并把关键指标写为元组的首个元素以表示当前排序的值是否属于重要分组(0表示属于，1表示不属于)

  ​	如果这个sort_priority函数还能够高速我们，列表里面有没有位于重要群主之中的元素，那就更好了，因为这样可以让用户界面开发者更方便的做相应的处理。添加一个这样一个功能似乎相当简单，因为闭包函数本身就需要判断当前值是否储在群主之中，既然这样，那么不妨让它在发现这种值时，顺便把表直变量翻转过来。最后，让闭包外的大函数返回这个标志变量，如果闭包函数但是遇到这样的值，那么这个表直可能时True。

  ​	下面，采用这种方式重写代码：

  ```python
  def sort_priority2(numbers, group):
      found = False
      def helper(x):
          if x in group:
              found = True  # Seems simple
              return 0, x
          return 1, x
      numbers.sort(key=helper)
      return found
  
  
  numbers = [8, 3, 1, 2, 5, 4, 7, 6]
  group = {2, 3, 5, 7}
  found = sort_priority2(numbers, group)
  print('Found:', found)
  print(numbers)
  >>>
  Found: False
  [2, 3, 5, 7, 1, 4, 6, 8]
  ```

  ​	排序结果没有问题，可以看到：在排序的numbers里面重要群主group里的那些元素(2，3，5，7)，确实在其他元素之前，既然这样，那表示函数返回值的found变量就应该时True，但我们看到的确实False，这是为什么呢？

  ​		在表达式里面引用某个变量时，python解析器会按照下面的顺序，在各个作用域里面查找这个变量，以解析这次引用：

  * 当前函数的作用域

  * 外围作用域(例如包含函数的其他函数所对应的作用域)

  * 包好当前代码的模块所对应的作用域(也就全局作用域，global scope)

  * 内置作用域(build-in scope，也就是包含len与str等函数的作用域)

    如果这些作用域都没有定义名称相符的变量，程序就会抛出NameError异常

    ~~~python
    foo = does_not_exist * 5
    >>>
    Traceback ...
    NameError: name 'does_not_exist' is not defined		
    ~~~

​		刚才讲的是怎么引用变量，现在我们讲怎么给变量赋值，这要分两种情况处理。如果变量已经定义在了当前的作用域中，可以直接赋值。如果当前作用域中不存在这个变量，那么即使外围作用域有同名的变量，python也还是会把这次赋值操作当成变量的定义来处理，这会产生一个重要的效果，也就是说，python会把包含赋值操作的这个函数当成新定义的这个变量的作用域。

​		这可以解释刚才那种写法错误所在何处。sort_priority2函数里面的helper闭包函数是把True赋值给了found变量。当前作用域没有这样一个叫做found的变量

，所以就算外围的sort_propriy2函数里面有found变量，系统也会把这次赋值当成定义，也就是会在helper俩名定义一个新的found变量，而不是把它当成sort_priority2已有的那个found变量赋值。

~~~python
def sort_priority2(numbers, group):
    found = False  # Scope: 'sort_priority2'

    def helper(x):
        if x in group:
            found = True  # Scope: 'helper' -- Bad!
            return 0, x
        return 1, x
    
    numbers.sort(key=helper)
    return found
~~~

​		 这种问题有时也称作用bug，python新手可能会认为这种新的规则感到奇怪。但是这样可以防止函数内部的局部变量污染外围变量。加入不这样做，那么函数里的每条赋值语句就可能影响全局作用域的变量，这样不仅混乱，而且会让全局变量彼此交互影响，从而导致很多难以查探的bug。

​		python中有一种新的写法，可以把闭包函数里的数据赋值给闭包外的变量，用nonlocal语句描述，就可以让系统在处理针对这个变量的赋值操作时，去外围作用域查找。然而，nonlocal有个限制，就是不能入侵模块级别的作用域(防止全局作用域污染)。

​		这里用nonlocal改写：

```python
def sort_priority3(numbers, group):
    found = False

    def helper(x):
        nonlocal found  # Added
        if x in group:
            found = True
            return 0, x
        return 1, x

    numbers.sort(key=helper)
    return found
```

​		nonlocal语句清楚的表明，我们要数据付给闭包外的变量。有一种跟它互补的语句，叫做global，用这种语句描述某个变量后，在给变量赋值时，系统会直接把它放到模块作用域(或者叫全局作用域).

​		我们都知道全局作用域不应该滥用，其实nonlocal也一样。除比较简单的函数外，大家尽量不要用这个语句，因为它朝臣的副作用很可能很难发现。尤其是在那种比较长的函数里，nonlocal语句与其关联变量的赋值操作之间可能离得很远。

​		如果nonlocal的用法比较复杂，那最好是改用辅助类来封装状态。下面就定义了这样一个类，用来实现与刚才那种写法相同的效果。这样虽然稍微长了一点，但看起来更加简单(--call--这个特殊用法，常见第38条)：

```python
class Sorter:
    def __init__(self, group):
        self.group = group
        self.found = False

    def __call__(self, x):
        if x in self.group:
            self.found = True
            return 0, x
        return 1, x


numbers = [8, 3, 1, 2, 5, 4, 7, 6]
group = {2, 3, 5, 7}
sorter = Sorter(group)
numbers.sort(key=sorter)
print(sorter.found)
>>>
True
```

**要点**

* 闭包函数可以引用定义他们的那个外围作用域之中的变量
* 按照默认的写法，在闭包函数里面给变量赋值并不会改变外围作用域中的同名变量
* 先用nonlocal语句说明，然后赋值，可以修改外围作用域的变量
* 除非特别简单的函数外，尽量少用nonlocal语句

## 第22条 用数量可变的位置参数给函数设计清晰的参数列表

​		让函数接收数量可变的位置参数(posotional argument)，可以把函数设计更加清晰(这些位置参数通常简称varargs，或者叫star args，因为习惯用*args指代)。例如，要记录调试信息。如果采用数量固定的方案来设计，那么函数应该接收一个表示信息的message参数和一个values列表(这个列表用于存放需要填充到信息里的那些值)。

~~~python
def log(message, values):
    if not values:
    	print(message)
    else:
        values_str = ', '.join(str(x) for x in values)
        print(f'{message}: {values_str}')
log('My numbers are', [1, 2])
log('Hi there', [])
>>>
My numbers are: 1, 2
Hi there
~~~

​		即便没有值需要填充到信息里面，也必须专门传一个空列表进去，这样显得多余，而且代码显得复杂。最好是能允许调用者只把第二个参数留空。在python里面，可以给最后一个位置参数加前缀*，这样调用者只需要提供不带星号得那些参数，然后可以不再指其他参数，也可以继续指定任意数量的位置参数。函数的主题代码不用改，只修改调用代码即可。

~~~python
def log(message, *values):  # The only difference
    if not values:
        print(message)
    else:
        values_str = ', '.join(str(x) for x in values)
        print(f'{message}: {values_str}')


log('My numbers are', 1, 2)
log('Hi there')  # Much better
~~~

​		这种写法域拆解数据时用在赋值语句左边带星号的解包操作非常类似(常见第13条)。

​		如果先把已有序列(例如某列表)里面的元素当成参数传给像log这样的参数个数可变的函数(variadic function)，那么可以在传递序列时采用*操作。这会让python把序列中的元素都当成位置参数传给这个函数。

~~~python
favorites = [7, 33, 99]
log('Favorite colors', *favorites)
>>>
Favorite colors: 7, 33, 99

~~~

​		函数在接收位置可变的参数时，可能会出现两个问题。

​		第一个问题，程序总是必须先把这些参数转化为一个元组，然后才能把它们当成可选的位置参数传给函数。这意味着，如果想调用函数时，把带*操作符的生成器传了过去，那么程序必须先把这个生成器你的所有元素迭代完(以便形成元组)，然后才能继续往下执行(常见第30条)。这个元组包含生成器所给出的每个值，这可能会消耗大量的内存，甚至会让程序崩溃。

~~~python
def my_generator():
    for i in range(10):
    	yield i
def my_func(*args):
	print(args)
it = my_generator()
my_func(*it)

>>>
(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
~~~

​		接收*args参数的函数，适合处理输入值不太多，而且数量可以提前预估的情况。在调用这种函数时，传给 *args 这部分的应该是徐国个字面值或变量名才对。这种机制，主要是为了烂代码写起来更加方便、读起来更加清晰。

​		第二个问题是，如果用了*args之后，又给函数添加新的位置参数，那么原有的调用操作就需要全部更新。例如给参数列表开头添加新的位置参数sequence，那么没有据此更新的那些调用代码就会出错：

~~~python
def log(sequence, message, *values):
    if not values:
    	print(f'{sequence} - {message}')
    else:
        values_str = ', '.join(str(x) for x in values)
        print(f'{sequence} - {message}: {values_str}')
log(1, 'Favorites', 7, 33) # New with *args OK
log(1, 'Hi there') # New message only OK
log('Favorite numbers', 7, 33) # Old usage breaks
>>>
1 - Favorites: 7, 33
1 - Hi there
Favorite numbers - 7: 33

~~~

​		问题在于：第三次调用log函数的那个地方并没有根据新的参数列表传入sequence参数，所以‘Faborite numbers’就成了sequence参数，7就成了message参数。这样的bug很难排查，因为程序不会抛出异常，只会采用错误的数据继续运行下去。为了彻底避免这种漏洞，在给*args函数添加参数时，应该使用只能通过关键字来指定的参数(keyword-only argument，常见第25条)。要是想做的更加稳妥一点，可以考虑添加类型注解(常见第90天)。

**要点**

* 用def定义函数时，可以通过*args的写法让函数接收数量可变的位置参数
* 调用函数时，可以在序列坐车加上*操作符，把其中的元素当成位置参数传递给 *args所表示的这一部分
* 如果*操作符加在生成器前，那么传递参数时，程序有可能因为内存耗尽而崩溃
* 给接收*args的函数添加新位置参数，可能导致难以排除的bug

## 第23条 用关键字参数来表示可选的行为

​		与大多数其他编程语言一样，python允许在调用函数时，按照位置传递参数。

~~~python
def remainder(number, divisor):
	return number % divisor
assert remainder(20, 7) == 6
~~~

​		python函数里面的所有普通参数，除了按照位置传递外，还可以按关键字传递。调用函数时，在调用括号内可以把关键字的名字写在=左边，把参数值写在右边。这种写法不在乎参数的顺序，只要把必须指定的所有位置参数全部传过去即可。另外，关键字形式与位置形式可以混用。下面的四种写法效果相同：

~~~python
remainder(20, 7)
remainder(20, divisor=7)
remainder(number=20, divisor=7)
remainder(divisor=7, number=20)
~~~

​		如果混用，那么位置参数必须出现在关键字参数之前，否则会报错：

~~~python
remainder(number=20, 7)
>>>
Traceback ...
SyntaxError: positional argument follows keyword argument
~~~

​		每个参数只能指定一次，不能通过位置形式指定，又通过关键字形式指定。

~~~python
remainder(20, number=7)
>>>
Traceback ..
TypeError: remainder() got multiple values for argument
➥ 'number'
~~~

​		如果有一份字典，而且字典里面的内容能够用来调用remainder这样的函数，那么可以把**运算符加在字典前面，这会让python把字典里面的键字以关键字参数的形式传给函数。

~~~python
my_kwargs = {
    'number': 20,
    'divisor': 7,
}
assert remainder(**my_kwargs) == 6

~~~

​		调用函数时，带**操作符的参数可以和位置参数或关键字参数混用，只要不重复指定就行：

~~~python
my_kwargs = {
	'divisor': 7
    }
assert remainder(number=20, **my_kwargs) == 6
~~~

​		也可以对多个字典分别施加**操作，只要这些字典所提供的参数不重叠就好：

~~~python
my_kwargs = {
	'number': 20,
}
other_kwargs = {
	'divisor': 7,
}
assert remainder(**my_kwargs, **other_kwargs) == 6
~~~

​		定义函数时，如果想让这个函数接收任意数量的关键字参数，那么可以在参数列表里写上万能形参**kwargs，它会把调用者传进来的参数收集合并到一个字典里稍后处理(第26条讲了一个特别适合这么做的情况)。

~~~python
def print_parameters(**kwargs):
    for key, value in kwargs.items():
    	print(f'{key} = {value}')
print_parameters(alpha=1.5, beta=9, gamma=4)
>>>
alpha = 1.5
beta = 9
gamma = 4

~~~

​		关键字参数的灵活性可以带来三个好处。

​		第一个好处是，关键字参数可以在调用函数时，让代码初次阅读者更容易看懂。例如，读到remainder(20，7)这样的调用代码，就不太容易看出谁是number，谁是divisor，只有去查看remainder的具体实现方法才明白。但如果改用关键字形式来调用，例如remainder(number=20， divisor=7)，那么每个参数的含义就相当明了了。

​		关键字参数的第二个好处是，它可以带有默认值，该值实在定义函数时指定的。在大多数情况下，调用者只需要沿用这个值即可，但有时也可以明确指定自己想要传的值。这样能够减少代码重复，让程序看上去更简洁。

​		例如，要计算液体流入容器的速率。如果这个容器带有刻度，那么可以去除前两个时间点的刻度差(weight_diff)，并把它跟这两个时间点的时间茶(time_diff)相除，就可以计算出流速。

~~~python
def flow_rate(weight_diff, time_diff):
	return weight_diff / time_diff
weight_diff = 0.5
time_diff = 3
flow = flow_rate(weight_diff, time_diff)
print(f'{flow:.3} kg per second')
>>>
0.167 kg per second
~~~

​		一般情况下，会通每秒的千克数表示流速。但有时候，我们还想估算更长的时间端(例如几小时或几天)内的流速结果。只需给同一个函数太廉价一个period参数来表示哪个时间段相当于多少秒即可：

~~~python
def flow_rate(weight_diff, time_diff, period):
	return (weight_diff / time_diff) * period
~~~

​		现在的问题是，每次调用函数时，都得单独指出period参数。即便要计算每秒的速率也要指定period为1：

~~~Python
flow_per_second = flow_rate(weight_diff, time_diff, 1)
~~~

​		为了让代码看上不不那么复杂，可以给period指定默认值：

~~~python
def flow_rate(weight_diff, time_diff, period=1):
	return (weight_diff / time_diff) * period
~~~

​		period参数现在是可选的：

~~~python
flow_per_second = flow_rate(weight_diff, time_diff)
flow_per_hour = flow_rate(weight_diff, time_diff,period=3600)

~~~

​		这个方法适用于默认值比较简单的情况。如果默认值本身需要根据比较复杂的逻辑来确定(可参考第24条)，那就得自习考虑一下。

​		使用关键字参数的第三个好处是，可以灵活的扩充函数的参数，而不用担心会影响原有函数的调用代码。这样的话，我们就可以通过这些新参数里面实现许多新的功能，同时又无须修改早前写好的调用代码，这也让程序不容易出现bug。

​		例如，想继续扩充上述flow_rate函数的功能，让他可以用千克以外的其他重量单位来计算流速。那只需要再添加一个可选参数，用来表示1千克相当于多少个那样的单位即可。

~~~python
def flow_rate(weight_diff, time_diff,period=1, units_per_kg=1):
	return ((weight_diff * units_per_kg) / time_diff) * period

~~~

​		新参数units_per_kg的默认值为1，依然以千克为重量单位来计算。于是，以前写好的那些调用代码就不用修改了。然后调用flow_rate时，就可以通过关键字形式给这个参数指定值，以表示需要的单位(1千克等于2.2磅)：

~~~python
pounds_per_hour = flow_rate(weight_diff, time_diff,period=3600, units_per_kg=2.2)
~~~

​		可选的关键字参数有助于维护先后兼容(backward compatibility)。这是个相当重要的问题，对于接受*args参数的函数，也要注意向后兼容(第22条)。

​		像period和units_per_kg这样可选的关键字参数，只有一个缺点，就是调用者仍然能够按照位置来指定。

~~~python
pounds_per_hour = flow_rate(weight_diff, time_diff, 3600,2.2)
~~~

​		通过位置来指定可选参数，这可能会让读代码的人感觉迷惑，因为他不太清楚3600和2.2这两个值分别指哪个量的缩放系数。所以，最好是能以关键字的形式给这参数传值，而不要按位置去传。从设计函数的角度来说，还可以用更加明确的方案来降低出错概率(参见第5条)。

**要点**

* 函数的参数可以按照位置来指定，也可以用关键字的形式来指定
* 关键字可以让每个参数的作用更加明了，因为在调用函数时只需要按位置指定参数，可能导致这些参数的含义不够明确
* 带有默认值的关键字参数
* 可选的关键自参数总是应该通过参数名来传递，而不应该由位置传递

