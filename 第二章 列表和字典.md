# 第二章 列表和字典

​		许多程序都是用来执行自动化重复的任务的，这些程序更适合机器处理而非人。在Python中，最常见的方式是通过使用一个列表存储任务序列来处理这些任务。列表的用途十分广泛，并且可以用来解决各种各样的问题。

​		有了列表，自然就有了跟它互补的结构，即字典，它存储映射键值对(这也叫关键矩阵或者哈希表)。对于字典来说，访问与赋值所花费的时间平均下来是常量，所以这种结构很适合存储动态信息。

​		Python拥有独特的语法和内置模块来增强列表和字典的可读性并拓展其能力，这要比能想到的其他语言中的简单数组、向量或哈希表都要强。

## 第11条 了解怎么切分序列

​		Python拥有对序列进行切分的语法。这种切片允许以最小的代价获取序列的子集。最简单的用法就是切割内置的list、str与bytes类型。其实，实现了__ getitem__和 __ setitem__方法的任何Python类都可以进行切片(参见第43条)。

​		最基本的切片语法就是somelist[start : end]，也就是获取start到end前一个的所有元素：

~~~python
a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
print('Middle two: ', a[3:5])
print('All but ends:', a[1:7])
>>>
Middle two: ['d', 'e']
All but ends: ['b', 'c', 'd', 'e', 'f', 'g']
~~~

​		当从列表的第一个元素开始切片时，就可以省略冒号左侧的0，这能让代码更清晰：

~~~pyuthon
a[:5] == a[0:5]
~~~

​		当切片刀列表的末尾时，可以省略冒号右侧的下标：

~~~python
a[5:] == a[5:len(a)]
~~~

​		使用负数作为下标表示从列表末尾往前算。下面这些切割方式，即便刚看到这些代码也可以明白什么意思：

~~~python
a[:] # ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
a[:5] # ['a', 'b', 'c', 'd', 'e']
a[:-1] # ['a', 'b', 'c', 'd', 'e', 'f', 'g']
a[4:] # ['e', 'f', 'g', 'h']
a[-3:] # ['f', 'g', 'h']
a[2:5] # ['c', 'd', 'e']
a[2:-1] # ['c', 'd', 'e', 'f', 'g']
a[-3:-1] # ['f', 'g']
~~~

​		这并没有什么独特之处，尽管用就好。

​		如果起点和终点所确定的范围超过了列表的边界，系统会自动忽略不存在的元素。利用这些特性，很容易就能构造出一个最多只有若干元素的序列，例如：

~~~python
first_twenty_items = a[:20]
last_twenty_items = a[-20:]
~~~

​		切片时下标可以越界，但是直接访问时却会抛出异常：

~~~python
a[20]
>>>
Traceback ...
IndexError: list index out of range

~~~

***

**提示**

​		在用负数对列表进行切片时，只有少数情况会得到意想不到的结果。只要n大于或等于1，somelist[-n : 1]总是可以切出预期的结果。只有当n为0时，才需要特别注意。此时somelist[-0 : ]相当于somelist[0 :]，所以更somelist[ : ]一暗影，会制作出原来列表的一份副本。

***

​		从原有列表中切割出来的列表是一个全新的列表。即便出去某个元素，也不影响原来的列表。原列表的对应位置值不变：

~~~python
b = a[3:]
print('Before: ', b)
b[1] = 99
print('After: ', b)
print('No change:', a)
>>>
Before: ['d', 'e', 'f', 'g', 'h']
After: ['d', 99, 'f', 'g', 'h']
No change: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
~~~

​		切片可以出现在赋值符号的左侧，表示右侧那些元素把源列表中位于这个范围之内的元素替换掉。这与解包操作的赋值不同，这种赋值不要求等号两边所指定的元素个数相同(例如，a,b =c[:2]，参见第6条)。在原列表中，位于切片范围之前和之后的那些元素会予以保留，但是列表的长度可能有所改变。例如下面这个例子中，列表的长度会变短，因为赋值符号右侧值提供了三个值，但是左侧的切片却包含了五个值，列表会比原来少两个元素：

~~~python
print('Before ', a)
a[2:7] = [99, 22, 14]
print('After ', a)
>>>
Before ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
After ['a', 'b', 99, 22, 14, 'h']
~~~

​		下面这种情况，列表会变长，因为赋值符号右侧的元素数量比左侧切片所涵盖的元素数量多：

~~~python
print('Before ', a)
a[2:3] = [47, 11]
print('After ', a)
>>>
Before ['a', 'b', 99, 22, 14, 'h']
After ['a', 'b', 47, 11, 22, 14, 'h']
~~~

​		起始位置都留空的切片，如果出现在赋值符号的右侧，那么表示给这个列表做副本，这样制作出来的新列表内容和原列表相同，但身份不同。

~~~python
b = a[:]
assert b == a and b is not a
~~~

​		把不带起止下标的切片放在赋值符号的左侧，表示用右侧那个列表的副本把左侧列表的内容全部替换(注意左侧列表依旧保持原来身份，系统不会分配新的列表)：

~~~python
b = a
print('Before a', a)
print('Before b', b)
a[:] = [101, 102, 103]
assert a is b # Still the same list object
print('After a ', a) # Now has different contents
print('After b ', b) # Same list, so same contents as a
>>>
Before a ['a', 'b', 47, 11, 22, 14, 'h']
Before b ['a', 'b', 47, 11, 22, 14, 'h']
After a [101, 102, 103]
After b [101, 102, 103]
~~~

**要点**

* 切片要尽可能简单：如果从头开始选取就省略下标0；如果要选到序列末尾，就省略终止下标
* 切片允许起始和终止下标越界，所以很容易就能飙到“取开头多少个元素”(例如a[:20])或“取末尾多少个元素”(例如a[-20 : 0])，而且不用担心切片是否真有这么多元素
* 把切片放在赋值符号的左侧可以将原来列表中这段范围的元素用付支付号右侧的元素替换掉，但可能会改变原列表的长度

## 第12条 避免在切边里同时指定起止下标和步进

​		除了切边的基本操作外(参见第11条)，Python还有特殊的补进切片方式someli[start : end : stride]。这种形式会在每n个元素里选取一个，这样很容易就能把技术位置上的元素和偶数上的元素分别通过x[::2]与x[1::2]选取出来：

~~~python
x = ['red', 'orange', 'yellow', 'green', 'blue', 'purple']
odds = x[::2]
evens = x[1::2]
print(odds)
print(evens)
>>>
['red', 'yellow', 'blue']
['orange', 'green', 'purple']
~~~

​		切片时采用步进经常会有意想不到的结果，并且会导致程序出现bug。例如，Python里面常用的倒置字符串的技巧，就是采用步长为-1的切片：

~~~python
x = b'mongoose'
y = x[::-1]
print(y)
>>>
b'esoognom'
~~~

​		这个技巧同样适用于Unicode字符串(参见第3条)：

~~~python
x = '寿司'
y = x[::-1]
print(y)
>>>
司寿
~~~

​		但是如果Unicode字符创采用UTF-8编码时，这个技巧就失效了：

~~~python
w = '寿司'
x = w.encode('utf-8')
y = x[::-1]
z = y.decode('utf-8')
>>>
Traceback ...
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xb8 in
position 0: invalid start byte
~~~

​		除了-1以外，其他的负数步进是否有用呢？思考下下面的例子：

~~~python
x = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
x[::2] # ['a', 'c', 'e', 'g']
x[::-2] # ['h', 'f', 'd', 'b']
~~~

​		这里，::2表示“从起始位置每两个元素取一个”。有趣的是，::-2表示“从末尾开始每两个元素取一个”。

​		2::2表示什么呢？同理，-2::2\-2::-2,2:2:-2表示什么意思呢？

~~~python
x[2::2] # ['c', 'e', 'g']
x[-2::-2] # ['g', 'e', 'c', 'a']
x[-2:2:-2] # ['g', 'e']
x[2:2:-2] # []
~~~

​		同时使用起止下标和步进会让切片很难理解。方括号里面写三个值会很不简洁，很不易读，而且在指定了步进值时(尤其是负数步进值)，必须要考虑是从强往后还是从后往前。

​		为了避免这个问题，建议在使用起止下标时，避免使用步进值。如果必须使用步进，尽量使用正数步进值，同时置空起止下标。如果必须同时使用起止下标和步进值，应该分开来写：

~~~python
y = x[::2] # ['a', 'c', 'e', 'g']
z = y[1:-1] # ['c', 'e']
~~~

​		先步进取值然后再切割，会让程序多一次浅**拷贝(shallow copy)**.所以，应该吧最能缩减李彪长度的切片操作放在最前面。如果程序实在没有那么多时间或内存去分两步操作，那么可以改用内置的itertools模块的islice方法(参见第36条)，这个方法用起来更加清晰，因为他的起止位置与步进值都不能为负数。

**要点**

* 同时制定起止位置与步进会让代码晦涩难懂
* 尽量使用正数步进值且把起止下标置空，避免使用负数步进值
* 避免在同一个切片操作中使用起止下标和步进值。如果必须同时使用，应分两次操作(一次隔位取值，一次做切片)，也可以采用内置itertools模块的islice方法。

## 第13条 在获取多个元素时，使用星号解包避免切片操作

​		基本的解包操作(参见第6条)有一项限制，就是必须提前确定需要解包的序列长度。例如，在销售汽车时，可能会把每辆汽车的年龄写在一个列表中，然后按照从大到小的顺序排列。如果通过基本的解包操作来获取最旧的两辆汽车，程序在运行时可能会报错：

~~~python
car_ages = [0, 9, 4, 8, 7, 20, 19, 1, 6, 15]
car_ages_descending = sorted(car_ages, reverse=True)
oldest, second_oldest = car_ages_descending
>>>
Traceback ...
ValueError: too many values to unpack (expected 2)
~~~

​		Python小白在遇到这种情况时，经常使用下标或者切片(参见第11条)。例如，可以明确通过下标把最旧和第二旧的汽车以及其他的汽车区分开来：

~~~python
oldest = car_ages_descending[0]
second_oldest = car_ages_descending[1]
others = car_ages_descending[2:]
print(oldest, second_oldest, others)
>>>
20 19 [15, 9, 8, 7, 6, 4, 1, 0]
~~~

​		这样确实能达到目的，但是下标操作和切片操作看起来很复杂。然而，用这种方法把序列中的元素分成多个子集合，其实很容易出错，因为通常容易把下标多写或者少写。例如，如果修改其中一行，但却忘了更改另一行，就会遇到这样的错误。

​		通过带星号的解包方法可以更好的结果这些问题，这也是一种解包操作，它可以把无法由普通变量接收的那些元素都囊括进去。下面用带星号的解包操作修改上面的方法，这里既不用下标也不用切片：

~~~python
oldest, second_oldest, *others = car_ages_descending
print(oldest, second_oldest, others)
>>>
20 19 [15, 9, 8, 7, 6, 4, 1, 0]
~~~

​		这段代码更加简短易读了，并且不容易出错，因为它不要求我们在修改其中一个下标后，还必须记得同步更新其他下标。

​		这种星号表达式可以出现在任何位置，所以它能捕获序列的任意一段元素：

~~~python
oldest, *others, youngest = car_ages_descending
print(oldest, youngest, others)
*others, second_youngest, youngest = car_ages_descending
print(youngest, second_youngest, others)
>>>
20 0 [19, 15, 9, 8, 7, 6, 4, 1]
0 1 [20, 19, 15, 9, 8, 7, 6, 4]
~~~

​		然而，在使用这种写法时，至少有一个普通变量与其搭配，否则就会出现SyntaxError。不能像下面这样使用星号解包：

~~~python
*others = car_ages_descending
>>>
Traceback ...
SyntaxError: starred assignment target must be in a list or
➥tuple
~~~

​		同样的，在单层的结构中，同一级里面只能使用一次星号解包：

~~~python
first, *middle, *second_middle, last = [1, 2, 3, 4]
>>>
Traceback ...
SyntaxError: two starred expressions in assignment
~~~

​		如果要拆解的结构有多层，那么同一级的不同部分可以各自出现星号解包。并不推荐这种用法(参见第19条)。理解他的解包原理可以帮你更加灵活的在不同的情况下使用星号解包：

~~~python
car_inventory = {
'Downtown': ('Silver Shadow', 'Pinto', 'DMC'),
'Airport': ('Skyline', 'Viper', 'Gremlin', 'Nova'),
}
((loc1, (best1, *rest1)),
(loc2, (best2, *rest2))) = car_inventory.items()
print(f'Best at {loc1} is {best1}, {len(rest1)} others')
print(f'Best at {loc2} is {best2}, {len(rest2)} others')
>>>
Best at Downtown is Silver Shadow, 2 others
Best at Airport is Skyline, 3 others

~~~

​		星号解包会得到一个列表实例。如果要拆分的序列没有元素就会得到一个空列表。如果能够提前确定待处理的序列至少有N个元素，那么这项特性就更加有用：

~~~python
short_list = [1, 2]
first, second, *rest = short_list
print(first, second, rest)
>>>
1 2 []
~~~

​		星号解包也可以用在迭代器中，但这样写与把数据拆分到多个变量里面的那种基本写法相比，并没有太大的优势。例如，首相构造一个长度为2的取值范围(range)，并把它封装到it这个迭代器中，然后将其中的值拆分到first和second两个变量中。但这样写还不如执行使用形式相符的静态列表(例如[1,2])简单：

~~~python
it = iter(range(1, 3))
first, second = it
print(f'{first} and {second}')
>>>
1 and 2
~~~

​		对迭代器采用星号解包的好处，主要体现在星号的用法上，它使得迭代器的拆分值更加清晰。例如，有个一生成器，每次可以从含有整个一周的汽车订单的CSV文件中取出一行数据：

~~~python
def generate_csv():
	yield ('Date', 'Make', 'Model', 'Year', 'Price')
	...
~~~

​		可以采用下标和切片来处理这个迭代器所给出的结果，但这样写需要多行代码，其看起来很乱：

~~~python
all_csv_rows = list(generate_csv())
header = all_csv_rows[0]
rows = all_csv_rows[1:]
print('CSV Header:', header)
print('Row count: ', len(rows))
>>>
CSV Header: ('Date', 'Make', 'Model', 'Year', 'Price')
Row count: 200
~~~

​		采用星号解包，就可以很容易的把第一行(表头)单独放在header变量中，同时把迭代器所给的其他内容合起来表示成rows变量。这样就清晰多了：

~~~python
it = generate_csv()
header, *rows = it
print('CSV Header:', header)
print('Row count: ', len(rows))
>>>
CSV Header: ('Date', 'Make', 'Model', 'Year', 'Price')
Row count: 200
~~~

​		请记住，因为星号解包会把结果放在列表中，这就可能耗尽计算机的全部内存并导致程序崩溃。首相必须确定系统有足够的内存可以存储拆分出来的结果数据，然后才可以对迭代器采用星号解包(还有一种做法，参见第13条).

**要点**

* 拆分数据结构并把其中的数据赋给变量时，可以采用星号解包，将结构中无法与普通变量像匹配的内中捕获到列表中
* 星号解包可以出现在赋值符号左侧的任意位置，它总会形成空的或者多值列表
* 在把列表拆分成多个互不重叠的部分时，星号解包比较好用，而通过下标和切片比较麻烦