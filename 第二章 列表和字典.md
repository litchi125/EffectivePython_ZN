# 第二章 列表和字典

​		许多程序都是用来执行自动化重复的任务的，这些程序更适合机器处理而非人。在Python中，最常见的方式是通过使用一个列表存储任务序列来处理这些任务。列表的用途十分广泛，并且可以用来解决各种各样的问题。

​		有了列表，自然就有了跟它互补的结构，即字典，它存储映射键值对(这也叫关键矩阵或者哈希表)。对于字典来说，访问与赋值所花费的时间平均下来是常量，所以这种结构很适合存储动态信息。

​		Python拥有独特的语法和内置模块来增强列表和字典的可读性并拓展其能力，这要比能想到的其他语言中的简单数组、向量或哈希表都要强。

## 第11条 了解怎么切分序列

​		Python拥有对序列进行切分的语法。这种切片允许以最小的代价获取序列的子集。最简单的用法就是切割内置的list、str与bytes类型。其实，实现了__ getitem__和 __ setitem__方法的任何Python类都可以进行切片(参见第43条)。

​		最基本的切片语法就是somelist[start : end]，也就是获取start到end前一个的所有元素：

~~~python
a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
print('Middle two: ', a[3:5])
print('All but ends:', a[1:7])
>>>
Middle two: ['d', 'e']
All but ends: ['b', 'c', 'd', 'e', 'f', 'g']
~~~

​		当从列表的第一个元素开始切片时，就可以省略冒号左侧的0，这能让代码更清晰：

~~~pyuthon
a[:5] == a[0:5]
~~~

​		当切片刀列表的末尾时，可以省略冒号右侧的下标：

~~~python
a[5:] == a[5:len(a)]
~~~

​		使用负数作为下标表示从列表末尾往前算。下面这些切割方式，即便刚看到这些代码也可以明白什么意思：

~~~python
a[:] # ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
a[:5] # ['a', 'b', 'c', 'd', 'e']
a[:-1] # ['a', 'b', 'c', 'd', 'e', 'f', 'g']
a[4:] # ['e', 'f', 'g', 'h']
a[-3:] # ['f', 'g', 'h']
a[2:5] # ['c', 'd', 'e']
a[2:-1] # ['c', 'd', 'e', 'f', 'g']
a[-3:-1] # ['f', 'g']
~~~

​		这并没有什么独特之处，尽管用就好。

​		如果起点和终点所确定的范围超过了列表的边界，系统会自动忽略不存在的元素。利用这些特性，很容易就能构造出一个最多只有若干元素的序列，例如：

~~~python
first_twenty_items = a[:20]
last_twenty_items = a[-20:]
~~~

​		切片时下标可以越界，但是直接访问时却会抛出异常：

~~~python
a[20]
>>>
Traceback ...
IndexError: list index out of range

~~~

***

**提示**

​		在用负数对列表进行切片时，只有少数情况会得到意想不到的结果。只要n大于或等于1，somelist[-n : 1]总是可以切出预期的结果。只有当n为0时，才需要特别注意。此时somelist[-0 : ]相当于somelist[0 :]，所以更somelist[ : ]一暗影，会制作出原来列表的一份副本。

***

​		从原有列表中切割出来的列表是一个全新的列表。即便出去某个元素，也不影响原来的列表。原列表的对应位置值不变：

~~~python
b = a[3:]
print('Before: ', b)
b[1] = 99
print('After: ', b)
print('No change:', a)
>>>
Before: ['d', 'e', 'f', 'g', 'h']
After: ['d', 99, 'f', 'g', 'h']
No change: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
~~~

​		切片可以出现在赋值符号的左侧，表示右侧那些元素把源列表中位于这个范围之内的元素替换掉。这与解包操作的赋值不同，这种赋值不要求等号两边所指定的元素个数相同(例如，a,b =c[:2]，参见第6条)。在原列表中，位于切片范围之前和之后的那些元素会予以保留，但是列表的长度可能有所改变。例如下面这个例子中，列表的长度会变短，因为赋值符号右侧值提供了三个值，但是左侧的切片却包含了五个值，列表会比原来少两个元素：

~~~python
print('Before ', a)
a[2:7] = [99, 22, 14]
print('After ', a)
>>>
Before ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
After ['a', 'b', 99, 22, 14, 'h']
~~~

​		下面这种情况，列表会变长，因为赋值符号右侧的元素数量比左侧切片所涵盖的元素数量多：

~~~python
print('Before ', a)
a[2:3] = [47, 11]
print('After ', a)
>>>
Before ['a', 'b', 99, 22, 14, 'h']
After ['a', 'b', 47, 11, 22, 14, 'h']
~~~

​		起始位置都留空的切片，如果出现在赋值符号的右侧，那么表示给这个列表做副本，这样制作出来的新列表内容和原列表相同，但身份不同。

~~~python
b = a[:]
assert b == a and b is not a
~~~

​		把不带起止下标的切片放在赋值符号的左侧，表示用右侧那个列表的副本把左侧列表的内容全部替换(注意左侧列表依旧保持原来身份，系统不会分配新的列表)：

~~~python
b = a
print('Before a', a)
print('Before b', b)
a[:] = [101, 102, 103]
assert a is b # Still the same list object
print('After a ', a) # Now has different contents
print('After b ', b) # Same list, so same contents as a
>>>
Before a ['a', 'b', 47, 11, 22, 14, 'h']
Before b ['a', 'b', 47, 11, 22, 14, 'h']
After a [101, 102, 103]
After b [101, 102, 103]
~~~

**要点**

* 切片要尽可能简单：如果从头开始选取就省略下标0；如果要选到序列末尾，就省略终止下标
* 切片允许起始和终止下标越界，所以很容易就能飙到“取开头多少个元素”(例如a[:20])或“取末尾多少个元素”(例如a[-20 : 0])，而且不用担心切片是否真有这么多元素
* 把切片放在赋值符号的左侧可以将原来列表中这段范围的元素用付支付号右侧的元素替换掉，但可能会改变原列表的长度

## 第12条 避免在切边里同时指定起止下标和步进

​		除了切边的基本操作外(参见第11条)，Python还有特殊的补进切片方式someli[start : end : stride]。这种形式会在每n个元素里选取一个，这样很容易就能把技术位置上的元素和偶数上的元素分别通过x[::2]与x[1::2]选取出来：

~~~python
x = ['red', 'orange', 'yellow', 'green', 'blue', 'purple']
odds = x[::2]
evens = x[1::2]
print(odds)
print(evens)
>>>
['red', 'yellow', 'blue']
['orange', 'green', 'purple']
~~~

​		切片时采用步进经常会有意想不到的结果，并且会导致程序出现bug。例如，Python里面常用的倒置字符串的技巧，就是采用步长为-1的切片：

~~~python
x = b'mongoose'
y = x[::-1]
print(y)
>>>
b'esoognom'
~~~

​		这个技巧同样适用于Unicode字符串(参见第3条)：

~~~python
x = '寿司'
y = x[::-1]
print(y)
>>>
司寿
~~~

​		但是如果Unicode字符创采用UTF-8编码时，这个技巧就失效了：

~~~python
w = '寿司'
x = w.encode('utf-8')
y = x[::-1]
z = y.decode('utf-8')
>>>
Traceback ...
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xb8 in
position 0: invalid start byte
~~~

​		除了-1以外，其他的负数步进是否有用呢？思考下下面的例子：

~~~python
x = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
x[::2] # ['a', 'c', 'e', 'g']
x[::-2] # ['h', 'f', 'd', 'b']
~~~

​		这里，::2表示“从起始位置每两个元素取一个”。有趣的是，::-2表示“从末尾开始每两个元素取一个”。

​		2::2表示什么呢？同理，-2::2\-2::-2,2:2:-2表示什么意思呢？

~~~python
x[2::2] # ['c', 'e', 'g']
x[-2::-2] # ['g', 'e', 'c', 'a']
x[-2:2:-2] # ['g', 'e']
x[2:2:-2] # []
~~~

​		同时使用起止下标和步进会让切片很难理解。方括号里面写三个值会很不简洁，很不易读，而且在指定了步进值时(尤其是负数步进值)，必须要考虑是从强往后还是从后往前。

​		为了避免这个问题，建议在使用起止下标时，避免使用步进值。如果必须使用步进，尽量使用正数步进值，同时置空起止下标。如果必须同时使用起止下标和步进值，应该分开来写：

~~~python
y = x[::2] # ['a', 'c', 'e', 'g']
z = y[1:-1] # ['c', 'e']
~~~

​		先步进取值然后再切割，会让程序多一次浅**拷贝(shallow copy)**.所以，应该吧最能缩减李彪长度的切片操作放在最前面。如果程序实在没有那么多时间或内存去分两步操作，那么可以改用内置的itertools模块的islice方法(参见第36条)，这个方法用起来更加清晰，因为他的起止位置与步进值都不能为负数。

**要点**

* 同时制定起止位置与步进会让代码晦涩难懂
* 尽量使用正数步进值且把起止下标置空，避免使用负数步进值
* 避免在同一个切片操作中使用起止下标和步进值。如果必须同时使用，应分两次操作(一次隔位取值，一次做切片)，也可以采用内置itertools模块的islice方法。

## 第13条 在获取多个元素时，使用星号解包避免切片操作

​		基本的解包操作(参见第6条)有一项限制，就是必须提前确定需要解包的序列长度。例如，在销售汽车时，可能会把每辆汽车的年龄写在一个列表中，然后按照从大到小的顺序排列。如果通过基本的解包操作来获取最旧的两辆汽车，程序在运行时可能会报错：

~~~python
car_ages = [0, 9, 4, 8, 7, 20, 19, 1, 6, 15]
car_ages_descending = sorted(car_ages, reverse=True)
oldest, second_oldest = car_ages_descending
>>>
Traceback ...
ValueError: too many values to unpack (expected 2)
~~~

​		Python小白在遇到这种情况时，经常使用下标或者切片(参见第11条)。例如，可以明确通过下标把最旧和第二旧的汽车以及其他的汽车区分开来：

~~~python
oldest = car_ages_descending[0]
second_oldest = car_ages_descending[1]
others = car_ages_descending[2:]
print(oldest, second_oldest, others)
>>>
20 19 [15, 9, 8, 7, 6, 4, 1, 0]
~~~

​		这样确实能达到目的，但是下标操作和切片操作看起来很复杂。然而，用这种方法把序列中的元素分成多个子集合，其实很容易出错，因为通常容易把下标多写或者少写。例如，如果修改其中一行，但却忘了更改另一行，就会遇到这样的错误。

​		通过带星号的解包方法可以更好的结果这些问题，这也是一种解包操作，它可以把无法由普通变量接收的那些元素都囊括进去。下面用带星号的解包操作修改上面的方法，这里既不用下标也不用切片：

~~~python
oldest, second_oldest, *others = car_ages_descending
print(oldest, second_oldest, others)
>>>
20 19 [15, 9, 8, 7, 6, 4, 1, 0]
~~~

​		这段代码更加简短易读了，并且不容易出错，因为它不要求我们在修改其中一个下标后，还必须记得同步更新其他下标。

​		这种星号表达式可以出现在任何位置，所以它能捕获序列的任意一段元素：

~~~python
oldest, *others, youngest = car_ages_descending
print(oldest, youngest, others)
*others, second_youngest, youngest = car_ages_descending
print(youngest, second_youngest, others)
>>>
20 0 [19, 15, 9, 8, 7, 6, 4, 1]
0 1 [20, 19, 15, 9, 8, 7, 6, 4]
~~~

​		然而，在使用这种写法时，至少有一个普通变量与其搭配，否则就会出现SyntaxError。不能像下面这样使用星号解包：

~~~python
*others = car_ages_descending
>>>
Traceback ...
SyntaxError: starred assignment target must be in a list or
➥tuple
~~~

​		同样的，在单层的结构中，同一级里面只能使用一次星号解包：

~~~python
first, *middle, *second_middle, last = [1, 2, 3, 4]
>>>
Traceback ...
SyntaxError: two starred expressions in assignment
~~~

​		如果要拆解的结构有多层，那么同一级的不同部分可以各自出现星号解包。并不推荐这种用法(参见第19条)。理解他的解包原理可以帮你更加灵活的在不同的情况下使用星号解包：

~~~python
car_inventory = {
'Downtown': ('Silver Shadow', 'Pinto', 'DMC'),
'Airport': ('Skyline', 'Viper', 'Gremlin', 'Nova'),
}
((loc1, (best1, *rest1)),
(loc2, (best2, *rest2))) = car_inventory.items()
print(f'Best at {loc1} is {best1}, {len(rest1)} others')
print(f'Best at {loc2} is {best2}, {len(rest2)} others')
>>>
Best at Downtown is Silver Shadow, 2 others
Best at Airport is Skyline, 3 others

~~~

​		星号解包会得到一个列表实例。如果要拆分的序列没有元素就会得到一个空列表。如果能够提前确定待处理的序列至少有N个元素，那么这项特性就更加有用：

~~~python
short_list = [1, 2]
first, second, *rest = short_list
print(first, second, rest)
>>>
1 2 []
~~~

​		星号解包也可以用在迭代器中，但这样写与把数据拆分到多个变量里面的那种基本写法相比，并没有太大的优势。例如，首相构造一个长度为2的取值范围(range)，并把它封装到it这个迭代器中，然后将其中的值拆分到first和second两个变量中。但这样写还不如执行使用形式相符的静态列表(例如[1,2])简单：

~~~python
it = iter(range(1, 3))
first, second = it
print(f'{first} and {second}')
>>>
1 and 2
~~~

​		对迭代器采用星号解包的好处，主要体现在星号的用法上，它使得迭代器的拆分值更加清晰。例如，有个一生成器，每次可以从含有整个一周的汽车订单的CSV文件中取出一行数据：

~~~python
def generate_csv():
	yield ('Date', 'Make', 'Model', 'Year', 'Price')
	...
~~~

​		可以采用下标和切片来处理这个迭代器所给出的结果，但这样写需要多行代码，其看起来很乱：

~~~python
all_csv_rows = list(generate_csv())
header = all_csv_rows[0]
rows = all_csv_rows[1:]
print('CSV Header:', header)
print('Row count: ', len(rows))
>>>
CSV Header: ('Date', 'Make', 'Model', 'Year', 'Price')
Row count: 200
~~~

​		采用星号解包，就可以很容易的把第一行(表头)单独放在header变量中，同时把迭代器所给的其他内容合起来表示成rows变量。这样就清晰多了：

~~~python
it = generate_csv()
header, *rows = it
print('CSV Header:', header)
print('Row count: ', len(rows))
>>>
CSV Header: ('Date', 'Make', 'Model', 'Year', 'Price')
Row count: 200
~~~

​		请记住，因为星号解包会把结果放在列表中，这就可能耗尽计算机的全部内存并导致程序崩溃。首相必须确定系统有足够的内存可以存储拆分出来的结果数据，然后才可以对迭代器采用星号解包(还有一种做法，参见第13条).

**要点**

* 拆分数据结构并把其中的数据赋给变量时，可以采用星号解包，将结构中无法与普通变量像匹配的内中捕获到列表中
* 星号解包可以出现在赋值符号左侧的任意位置，它总会形成空的或者多值列表
* 在把列表拆分成多个互不重叠的部分时，星号解包比较好用，而通过下标和切片比较麻烦

## 第14条 通过在sort中使用key参数完成复杂排序

​		在python的内置的列表类型中，提供了sort方法用于针对不同情况对列表实例进行复杂排序。默认情况下，sort方法将会按照自然顺序对列表元素进行排序。例如，对整型数据的列表进行从小到大的排序：

~~~python
numbers = [93, 86, 11, 68, 70]
numbers.sort()
print(numbers)
>>>
[11, 68, 70, 86, 93]
~~~

​		sort方法默认情况下能够对几乎所有的内置类型(string、floats等等)进行自然排序。在对象中结构中使用sort方法又会怎么样呢？例如，这里定义一个包含__ repr__ 方法的类，这样类实例是可打印的；例如，这里定义了一个Tool类表示各种建筑工具，它带有一个__  repr__，因此可疑将类实例打印成字符串参见第75条：

~~~python
class Tool:
    def __init__(self, name, weight):
        self.name = name
        self.weight = weight
    def __repr__(self):
        return f'Tool({self.name!r}, {self.weight})'
    tools = [
        Tool('level', 3.5),
        Tool('hammer', 1.25),
        Tool('screwdriver', 0.5),
        Tool('chisel', 0.25),
    ]
~~~

​		但是，这样由类对象所构成的列表是没办法对sort方法进行排序的，因为sort方法所需要的特殊方法并没有在Tool类中定义：

~~~python
tools.sort()
>>>
Traceback ...
TypeError: '<' not supported between instances of 'Tool' and
'Tool'
~~~

​		如果某些类像整数那样拥有自然顺序，就可以定义一些特殊的方法(参见第73条)，这压根就可以通过sort方法而不要额外的参数进行排序了。但是更常见的是，很多对象需要在不同的情况下按照不同的标准排序，此时定义自然排序实际上是没有意义的。

​		通常情况下需要的是对对象中的某个属性进行排序。为了适应这样的排序需求，可疑定义一个由key参数的方法。key所表示的方法本身应该带有一个参数，这个参数指代列表中有待排序的对象，方法返回的应该是个可比较的值(具有自然顺序的值)，以便sort方法以该值为标准给这些对象排序。

​		这里，使用lambda关键字定义一个方法，把它传给sort方法的key关键字来对Tool对象的name属性排序：、

~~~python
class Tool:
    def __init__(self, name, weight):
        self.name = name
        self.weight = weight
    def __repr__(self):
        return f'Tool({self.name!r}, {self.weight})'
tools = [
    Tool('level', 3.5),
    Tool('hammer', 1.25),
    Tool('screwdriver', 0.5),
    Tool('chisel', 0.25),
]
print('Unsorted:', repr(tools))
tools.sort(key=lambda x: x.name)
print('\nSorted: ', tools)
>>>
Unsorted: [Tool('level', 3.5), Tool('hammer', 1.25), Tool('screwdriver', 0.5), Tool('chisel', 0.25)]

Sorted:  [Tool('chisel', 0.25), Tool('hammer', 1.25), Tool('level', 3.5), Tool('screwdriver', 0.5)]
~~~

​		同理，可以很容易的用lambda关键字定义一个针对weight排序的方法，并把它传给sort方法的key关键字，实现对Tool类的weight属性的排序：

~~~python
class Tool:
    def __init__(self, name, weight):
        self.name = name
        self.weight = weight
    def __repr__(self):
        return f'Tool({self.name!r}, {self.weight})'
tools = [
    Tool('level', 3.5),
    Tool('hammer', 1.25),
    Tool('screwdriver', 0.5),
    Tool('chisel', 0.25),
]
print('Unsorted:', repr(tools))
tools.sort(key=lambda x: x.weight)
print('\nSorted: ', tools)
>>>
Unsorted: [Tool('level', 3.5), Tool('hammer', 1.25), Tool('screwdriver', 0.5), Tool('chisel', 0.25)]

Sorted:  [Tool('chisel', 0.25), Tool('screwdriver', 0.5), Tool('hammer', 1.25), Tool('level', 3.5)]
~~~

​		在编写传给key参数的lambda方法时，可以像刚才拿行返回对象的某个属性，如果对象是序列、元组或字典，那么还可以返回其中的某个元素。其实，只要是有效的表达式都可以充当lambda方法的返回值。

​		对于像字符串这样的基本类型，我们可能需要通过key函数先对它的内容做一些变换。并根据变换后的结果排序。例如，下面的这个places列表中存放这地点字符串，如果要在排序前忽略大小写，就可以先使用lower方法把待排序的字符串处理(因为对于字符串来说，自然顺序就是在字母表中的顺序，大写在小写之前)：

```python
class Tool:
    def __init__(self, name, weight):
        self.name = name
        self.weight = weight

    def __repr__(self):
        return f'Tool({self.name!r}, {self.weight})'


places = ['home', 'work', 'New York', 'Paris']
places.sort()
print('Case sensitive: ', places)
places.sort(key=lambda x: x.lower())
print('Case insensitive:', places)
>>>
Case sensitive:  ['New York', 'Paris', 'home', 'work']
Case insensitive: ['home', 'New York', 'Paris', 'work']
```

​		有时可能会需要多个标准进行排序。例如，这里有一些电力工具，需要先通过重量排序再通过名字排序，需要怎么来实现了？

~~~python
power_tools = [
    Tool('drill', 4),
    Tool('circular saw', 5),
    Tool('jackhammer', 40),
    Tool('sander', 4),
]

~~~

​		再python中最简单的方法是：通过元组类型实现。源主是一种不可变的序列，能够存放任意的python值。元组是可比较的且本身含有自然排序，也就是所sort方法需要的特殊方法(例如__ it __)，它都已经定义好了。元组在实现这些特殊方法时会依次比较每个位置上对应位置的元素，知道能够确定大小位置。这里，我们看看其中一个工具比另一个工具重的情况，在这种情况下，只需要根据元组中的第一个元素重量就可以确定两个元组的大小：

~~~python
saw = (5, 'circular saw')
jackhammer = (40, 'jackhammer')
assert not (jackhammer < saw) # Matches expectations
~~~

​		如果两个元组的首个元素相等，就会比较第二个元素，如果仍然相等，就会继续往下比较。这里演示两个重量相同，但是名字不同的元组：

```python
drill = (4, 'drill')
sander = (4, 'sander')
assert drill[0] == sander[0]  # Same weight
assert drill[1] < sander[1]  # Alphabetically less
assert drill < sander  # Thus, drill comes first
```

​		利用元组的这种特性，可以用工具的weight和name构造一个元组。限免就定义一个这样的lambda方法，让他返回元组，把首要指标weight放在前面，次要指标name放在后面：

```python
class Tool:
    def __init__(self, name, weight):
        self.name = name
        self.weight = weight

    def __repr__(self):
        return f'Tool({self.name!r}, {self.weight})'


power_tools = [
    Tool('drill', 4),
    Tool('circular saw', 5),
    Tool('jackhammer', 40),
    Tool('sander', 4),
]
power_tools.sort(key=lambda x: (x.weight, x.name))
print(power_tools)
>>>
[Tool('drill', 4), Tool('sander', 4), Tool('circular saw', 5), Tool('jackhammer', 40)]
```

​		这样做有一个缺点，key方法所构造的这个元组只能按照同一个排序方向对比它所表示的各项指标(如果是升序，就只能是升序；如果是降序，就只能是降序)，所以不太容易实现按照weight降序、name升序这样的情况。sort方法可以指定reverse参数，这个参数会同时影响元组中的所有指标(例如下面的例子中，weight和name都会按照降序处理，所以’sander‘会出现在’drill‘前面，而不像像前面那样)：

```python
class Tool:
    def __init__(self, name, weight):
        self.name = name
        self.weight = weight

    def __repr__(self):
        return f'Tool({self.name!r}, {self.weight})'


power_tools = [
    Tool('drill', 4),
    Tool('circular saw', 5),
    Tool('jackhammer', 40),
    Tool('sander', 4),
]
power_tools.sort(key=lambda x: (x.weight, x.name),
                 reverse=True)  # Makes all criteriadescending
print(power_tools)
>>>
[Tool('jackhammer', 40), Tool('circular saw', 5), Tool('sander', 4), Tool('drill', 4)]
```

​		如果其中一项指标是数字，那么就可以在实现key方法时，利用一元减操作符让两个指标按照不同的方向排序。也就是所，key方法在返回这个元组时，可以单独对这个指标取相反数，并保持其他指标不变，这就相当于让排序算法单独在这个指标上采用逆序。下面就演示怎么按照重量从小到大、名称由大到小的顺序排序(这次，’sander‘会在’drill‘后面)：

```python
class Tool:
    def __init__(self, name, weight):
        self.name = name
        self.weight = weight

    def __repr__(self):
        return f'Tool({self.name!r}, {self.weight})'


power_tools = [
    Tool('drill', 4),
    Tool('circular saw', 5),
    Tool('jackhammer', 40),
    Tool('sander', 4),
]
power_tools.sort(key=lambda x: (-x.weight, x.name))
print(power_tools)
>>>
[Tool('jackhammer', 40), Tool('circular saw', 5), Tool('drill', 4), Tool('sander', 4)]
```

​		但是，这个技巧并不适合所有的类型。例如，若想在指定reverse=True的情况下得到相同的排序结果，就可以对name使用一元减操作符，看能否实现相同的效果：

```python
class Tool:
    def __init__(self, name, weight):
        self.name = name
        self.weight = weight

    def __repr__(self):
        return f'Tool({self.name!r}, {self.weight})'


power_tools = [
    Tool('drill', 4),
    Tool('circular saw', 5),
    Tool('jackhammer', 40),
    Tool('sander', 4),
]
power_tools.sort(key=lambda x: (x.weight, -x.name),
                 reverse=True)
print(power_tools)
>>>
Traceback (most recent call last):
  File "D:/PyCharm_pro/punter_v0.1.8/test/test21.py", line 22, in <module>
    reverse=True)
  File "D:/PyCharm_pro/punter_v0.1.8/test/test21.py", line 21, in <lambda>
    power_tools.sort(key=lambda x: (x.weight, -x.name),
TypeError: bad operand type for unary -: 'str'
```

​		可以看到，str类型不支持”-“操作。在这种情况下，应该考虑sort方法的一项特性，那就是这个方法是个稳定的排序算法。这就意味着，如果key方法认定两个值相同，那么这两个值就在排序结果中的先后顺序就会和他们在排序强的顺序一致。于是，我们可以在同一列表中中多次调用sort方法，每次指定不同的排序标准。下面我们就利用者线特性实现刚才的小果果。把首要指标weight降序放在第二轮，把次要指标name升序放在第一轮：

```python
class Tool:
    def __init__(self, name, weight):
        self.name = name
        self.weight = weight

    def __repr__(self):
        return f'Tool({self.name!r}, {self.weight})'


power_tools = [
    Tool('drill', 4),
    Tool('circular saw', 5),
    Tool('jackhammer', 40),
    Tool('sander', 4),
]
power_tools.sort(key=lambda x: x.name) # Name ascending
power_tools.sort(key=lambda x: x.weight, # Weight descending
                 reverse=True)
print(power_tools)
>>>
[Tool('jackhammer', 40), Tool('circular saw', 5), Tool('drill', 4), Tool('sander', 4)]
```

​		为什么这样可以获得正确的结果呢？我们分开来看。第一轮排序，按照name升序排序：

~~~python
power_tools.sort(key=lambda x: x.name)
print(power_tools)
>>>
[Tool('circular saw', 5),Tool('drill', 4),Tool('jackhammer', 40),Tool('sander', 4)]
~~~

​		然后，第二轮，按照重量重复降序排序。这里由于’sander‘与’drill‘所对应的俩哥哥Tool对象的重量相同，key方法就会判定两个对象相等。于是，在sort方法的排序结果中，他们之间的先后次序就和第一轮结束时相同。所以，我们实现呢按重量降序排序的同时，保留呢质量相同的对象在上一轮排序时的相对顺序，而上一轮时按照name排序的：

~~~python
power_tools.sort(key=lambda x: x.weight,
reverse=True)
print(power_tools)
>>>
[Tool('jackhammer', 40),Tool('circular saw', 5),Tool('drill', 4),Tool('sander', 4)]
~~~

​		无论有多少项排序指标都可以按照这样的思路实现，而且每项指标可以分别按照各自的方向排序，不用全是升序或全是降序。只需倒着写这些即可，也就是把最主要的那项指标放在最后一轮处理。在上面的例子中，首要指标是重量降序，次要指标是name升序，所以要按照name升序、重量降序排列。

​		尽管这两种思路都能实现相同的效果，当只调用一次sort显然要比调用两次sort更加简单。所以，在实现多个指标不同方向的排序时，应该优先考虑让key方法返回元组，并对元组的相应指标取相反数。只有在万不得已时，才考虑多次调用sort方法。

**要点**

* 列表的sort方法可以根据自然顺序给其中的字符串、整形、元组等内置元素进行排序
* 普通对象如果通过特殊方法定义自然顺序，那么也可以用sort方法排序，但这样的对象并不多见
* 可以把辅助函数传给sort方法的key参数，让sort根据这个函数返回的值排列元素顺序，而不是根据元素本身排序
* 如果排序的指标有多个时，可以把他们放在同一个元组中，让key方法返回这样的元组。对于支持”-“操作的类型来说，可以单独给这项指标取反，这让排序算法在这项指标上按照相反的方向处理
* 如果这些指标不支持”-“操作，可以多次调用sort方法，并在每次调用时分别指定key方法与reverse参数。最迟要的指标放在第一轮，然后逐步处理更重要的指标，最后处理最重要的指标