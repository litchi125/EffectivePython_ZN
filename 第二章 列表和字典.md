# 第二章 列表和字典

​		许多程序都是用来执行自动化重复的任务的，这些程序更适合机器处理而非人。在Python中，最常见的方式是通过使用一个列表存储任务序列来处理这些任务。列表的用途十分广泛，并且可以用来解决各种各样的问题。

​		有了列表，自然就有了跟它互补的结构，即字典，它存储映射键值对(这也叫关键矩阵或者哈希表)。对于字典来说，访问与赋值所花费的时间平均下来是常量，所以这种结构很适合存储动态信息。

​		Python拥有独特的语法和内置模块来增强列表和字典的可读性并拓展其能力，这要比能想到的其他语言中的简单数组、向量或哈希表都要强。

## 第11条 了解怎么切分序列

​		Python拥有对序列进行切分的语法。这种切片允许以最小的代价获取序列的子集。最简单的用法就是切割内置的list、str与bytes类型。其实，实现了__ getitem__和 __ setitem__方法的任何Python类都可以进行切片(参见第43条)。

​		最基本的切片语法就是somelist[start : end]，也就是获取start到end前一个的所有元素：

~~~python
a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
print('Middle two: ', a[3:5])
print('All but ends:', a[1:7])
>>>
Middle two: ['d', 'e']
All but ends: ['b', 'c', 'd', 'e', 'f', 'g']
~~~

​		当从列表的第一个元素开始切片时，就可以省略冒号左侧的0，这能让代码更清晰：

~~~pyuthon
a[:5] == a[0:5]
~~~

​		当切片刀列表的末尾时，可以省略冒号右侧的下标：

~~~python
a[5:] == a[5:len(a)]
~~~

​		使用负数作为下标表示从列表末尾往前算。下面这些切割方式，即便刚看到这些代码也可以明白什么意思：

~~~python
a[:] # ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
a[:5] # ['a', 'b', 'c', 'd', 'e']
a[:-1] # ['a', 'b', 'c', 'd', 'e', 'f', 'g']
a[4:] # ['e', 'f', 'g', 'h']
a[-3:] # ['f', 'g', 'h']
a[2:5] # ['c', 'd', 'e']
a[2:-1] # ['c', 'd', 'e', 'f', 'g']
a[-3:-1] # ['f', 'g']
~~~

​		这并没有什么独特之处，尽管用就好。

​		如果起点和终点所确定的范围超过了列表的边界，系统会自动忽略不存在的元素。利用这些特性，很容易就能构造出一个最多只有若干元素的序列，例如：

~~~python
first_twenty_items = a[:20]
last_twenty_items = a[-20:]
~~~

​		切片时下标可以越界，但是直接访问时却会抛出异常：

~~~python
a[20]
>>>
Traceback ...
IndexError: list index out of range

~~~

***

**提示**

​		在用负数对列表进行切片时，只有少数情况会得到意想不到的结果。只要n大于或等于1，somelist[-n : 1]总是可以切出预期的结果。只有当n为0时，才需要特别注意。此时somelist[-0 : ]相当于somelist[0 :]，所以更somelist[ : ]一暗影，会制作出原来列表的一份副本。

***

​		从原有列表中切割出来的列表是一个全新的列表。即便出去某个元素，也不影响原来的列表。原列表的对应位置值不变：

~~~python
b = a[3:]
print('Before: ', b)
b[1] = 99
print('After: ', b)
print('No change:', a)
>>>
Before: ['d', 'e', 'f', 'g', 'h']
After: ['d', 99, 'f', 'g', 'h']
No change: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
~~~

​		切片可以出现在赋值符号的左侧，表示右侧那些元素把源列表中位于这个范围之内的元素替换掉。这与解包操作的赋值不同，这种赋值不要求等号两边所指定的元素个数相同(例如，a,b =c[:2]，参见第6条)。在原列表中，位于切片范围之前和之后的那些元素会予以保留，但是列表的长度可能有所改变。例如下面这个例子中，列表的长度会变短，因为赋值符号右侧值提供了三个值，但是左侧的切片却包含了五个值，列表会比原来少两个元素：

~~~python
print('Before ', a)
a[2:7] = [99, 22, 14]
print('After ', a)
>>>
Before ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
After ['a', 'b', 99, 22, 14, 'h']
~~~

​		下面这种情况，列表会变长，因为赋值符号右侧的元素数量比左侧切片所涵盖的元素数量多：

~~~python
print('Before ', a)
a[2:3] = [47, 11]
print('After ', a)
>>>
Before ['a', 'b', 99, 22, 14, 'h']
After ['a', 'b', 47, 11, 22, 14, 'h']
~~~

​		起始位置都留空的切片，如果出现在赋值符号的右侧，那么表示给这个列表做副本，这样制作出来的新列表内容和原列表相同，但身份不同。

~~~python
b = a[:]
assert b == a and b is not a
~~~

​		把不带起止下标的切片放在赋值符号的左侧，表示用右侧那个列表的副本把左侧列表的内容全部替换(注意左侧列表依旧保持原来身份，系统不会分配新的列表)：

~~~python
b = a
print('Before a', a)
print('Before b', b)
a[:] = [101, 102, 103]
assert a is b # Still the same list object
print('After a ', a) # Now has different contents
print('After b ', b) # Same list, so same contents as a
>>>
Before a ['a', 'b', 47, 11, 22, 14, 'h']
Before b ['a', 'b', 47, 11, 22, 14, 'h']
After a [101, 102, 103]
After b [101, 102, 103]
~~~

**要点**

* 切片要尽可能简单：如果从头开始选取就省略下标0；如果要选到序列末尾，就省略终止下标
* 切片允许起始和终止下标越界，所以很容易就能飙到“取开头多少个元素”(例如a[:20])或“取末尾多少个元素”(例如a[-20 : 0])，而且不用担心切片是否真有这么多元素
* 把切片放在赋值符号的左侧可以将原来列表中这段范围的元素用付支付号右侧的元素替换掉，但可能会改变原列表的长度

## 第12条 避免在切边里同时指定起止下标和步进

​		除了切边的基本操作外(参见第11条)，Python还有特殊的补进切片方式someli[start : end : stride]。这种形式会在每n个元素里选取一个，这样很容易就能把技术位置上的元素和偶数上的元素分别通过x[::2]与x[1::2]选取出来：

~~~python
x = ['red', 'orange', 'yellow', 'green', 'blue', 'purple']
odds = x[::2]
evens = x[1::2]
print(odds)
print(evens)
>>>
['red', 'yellow', 'blue']
['orange', 'green', 'purple']
~~~

​		切片时采用步进经常会有意想不到的结果，并且会导致程序出现bug。例如，Python里面常用的倒置字符串的技巧，就是采用步长为-1的切片：

~~~python
x = b'mongoose'
y = x[::-1]
print(y)
>>>
b'esoognom'
~~~

​		这个技巧同样适用于Unicode字符串(参见第3条)：

~~~python
x = '寿司'
y = x[::-1]
print(y)
>>>
司寿
~~~

​		但是如果Unicode字符创采用UTF-8编码时，这个技巧就失效了：

~~~python
w = '寿司'
x = w.encode('utf-8')
y = x[::-1]
z = y.decode('utf-8')
>>>
Traceback ...
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xb8 in
position 0: invalid start byte
~~~

​		除了-1以外，其他的负数步进是否有用呢？思考下下面的例子：

~~~python
x = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
x[::2] # ['a', 'c', 'e', 'g']
x[::-2] # ['h', 'f', 'd', 'b']
~~~

​		这里，::2表示“从起始位置每两个元素取一个”。有趣的是，::-2表示“从末尾开始每两个元素取一个”。

​		2::2表示什么呢？同理，-2::2\-2::-2,2:2:-2表示什么意思呢？

~~~python
x[2::2] # ['c', 'e', 'g']
x[-2::-2] # ['g', 'e', 'c', 'a']
x[-2:2:-2] # ['g', 'e']
x[2:2:-2] # []
~~~

​		同时使用起止下标和步进会让切片很难理解。方括号里面写三个值会很不简洁，很不易读，而且在指定了步进值时(尤其是负数步进值)，必须要考虑是从强往后还是从后往前。

​		为了避免这个问题，建议在使用起止下标时，避免使用步进值。如果必须使用步进，尽量使用正数步进值，同时置空起止下标。如果必须同时使用起止下标和步进值，应该分开来写：

~~~python
y = x[::2] # ['a', 'c', 'e', 'g']
z = y[1:-1] # ['c', 'e']
~~~

​		先步进取值然后再切割，会让程序多一次浅**拷贝(shallow copy)**.所以，应该吧最能缩减李彪长度的切片操作放在最前面。如果程序实在没有那么多时间或内存去分两步操作，那么可以改用内置的itertools模块的islice方法(参见第36条)，这个方法用起来更加清晰，因为他的起止位置与步进值都不能为负数。

**要点**

* 同时制定起止位置与步进会让代码晦涩难懂
* 尽量使用正数步进值且把起止下标置空，避免使用负数步进值
* 避免在同一个切片操作中使用起止下标和步进值。如果必须同时使用，应分两次操作(一次隔位取值，一次做切片)，也可以采用内置itertools模块的islice方法。

## 第13条 在获取多个元素时，使用星号解包避免切片操作

​		基本的解包操作(参见第6条)有一项限制，就是必须提前确定需要解包的序列长度。例如，在销售汽车时，可能会把每辆汽车的年龄写在一个列表中，然后按照从大到小的顺序排列。如果通过基本的解包操作来获取最旧的两辆汽车，程序在运行时可能会报错：

~~~python
car_ages = [0, 9, 4, 8, 7, 20, 19, 1, 6, 15]
car_ages_descending = sorted(car_ages, reverse=True)
oldest, second_oldest = car_ages_descending
>>>
Traceback ...
ValueError: too many values to unpack (expected 2)
~~~

​		Python小白在遇到这种情况时，经常使用下标或者切片(参见第11条)。例如，可以明确通过下标把最旧和第二旧的汽车以及其他的汽车区分开来：

~~~python
oldest = car_ages_descending[0]
second_oldest = car_ages_descending[1]
others = car_ages_descending[2:]
print(oldest, second_oldest, others)
>>>
20 19 [15, 9, 8, 7, 6, 4, 1, 0]
~~~

​		这样确实能达到目的，但是下标操作和切片操作看起来很复杂。然而，用这种方法把序列中的元素分成多个子集合，其实很容易出错，因为通常容易把下标多写或者少写。例如，如果修改其中一行，但却忘了更改另一行，就会遇到这样的错误。

​		通过带星号的解包方法可以更好的结果这些问题，这也是一种解包操作，它可以把无法由普通变量接收的那些元素都囊括进去。下面用带星号的解包操作修改上面的方法，这里既不用下标也不用切片：

~~~python
oldest, second_oldest, *others = car_ages_descending
print(oldest, second_oldest, others)
>>>
20 19 [15, 9, 8, 7, 6, 4, 1, 0]
~~~

​		这段代码更加简短易读了，并且不容易出错，因为它不要求我们在修改其中一个下标后，还必须记得同步更新其他下标。

​		这种星号表达式可以出现在任何位置，所以它能捕获序列的任意一段元素：

~~~python
oldest, *others, youngest = car_ages_descending
print(oldest, youngest, others)
*others, second_youngest, youngest = car_ages_descending
print(youngest, second_youngest, others)
>>>
20 0 [19, 15, 9, 8, 7, 6, 4, 1]
0 1 [20, 19, 15, 9, 8, 7, 6, 4]
~~~

​		然而，在使用这种写法时，至少有一个普通变量与其搭配，否则就会出现SyntaxError。不能像下面这样使用星号解包：

~~~python
*others = car_ages_descending
>>>
Traceback ...
SyntaxError: starred assignment target must be in a list or
➥tuple
~~~

​		同样的，在单层的结构中，同一级里面只能使用一次星号解包：

~~~python
first, *middle, *second_middle, last = [1, 2, 3, 4]
>>>
Traceback ...
SyntaxError: two starred expressions in assignment
~~~

​		如果要拆解的结构有多层，那么同一级的不同部分可以各自出现星号解包。并不推荐这种用法(参见第19条)。理解他的解包原理可以帮你更加灵活的在不同的情况下使用星号解包：

~~~python
car_inventory = {
'Downtown': ('Silver Shadow', 'Pinto', 'DMC'),
'Airport': ('Skyline', 'Viper', 'Gremlin', 'Nova'),
}
((loc1, (best1, *rest1)),
(loc2, (best2, *rest2))) = car_inventory.items()
print(f'Best at {loc1} is {best1}, {len(rest1)} others')
print(f'Best at {loc2} is {best2}, {len(rest2)} others')
>>>
Best at Downtown is Silver Shadow, 2 others
Best at Airport is Skyline, 3 others

~~~

​		星号解包会得到一个列表实例。如果要拆分的序列没有元素就会得到一个空列表。如果能够提前确定待处理的序列至少有N个元素，那么这项特性就更加有用：

~~~python
short_list = [1, 2]
first, second, *rest = short_list
print(first, second, rest)
>>>
1 2 []
~~~

​		星号解包也可以用在迭代器中，但这样写与把数据拆分到多个变量里面的那种基本写法相比，并没有太大的优势。例如，首相构造一个长度为2的取值范围(range)，并把它封装到it这个迭代器中，然后将其中的值拆分到first和second两个变量中。但这样写还不如执行使用形式相符的静态列表(例如[1,2])简单：

~~~python
it = iter(range(1, 3))
first, second = it
print(f'{first} and {second}')
>>>
1 and 2
~~~

​		对迭代器采用星号解包的好处，主要体现在星号的用法上，它使得迭代器的拆分值更加清晰。例如，有个一生成器，每次可以从含有整个一周的汽车订单的CSV文件中取出一行数据：

~~~python
def generate_csv():
	yield ('Date', 'Make', 'Model', 'Year', 'Price')
	...
~~~

​		可以采用下标和切片来处理这个迭代器所给出的结果，但这样写需要多行代码，其看起来很乱：

~~~python
all_csv_rows = list(generate_csv())
header = all_csv_rows[0]
rows = all_csv_rows[1:]
print('CSV Header:', header)
print('Row count: ', len(rows))
>>>
CSV Header: ('Date', 'Make', 'Model', 'Year', 'Price')
Row count: 200
~~~

​		采用星号解包，就可以很容易的把第一行(表头)单独放在header变量中，同时把迭代器所给的其他内容合起来表示成rows变量。这样就清晰多了：

~~~python
it = generate_csv()
header, *rows = it
print('CSV Header:', header)
print('Row count: ', len(rows))
>>>
CSV Header: ('Date', 'Make', 'Model', 'Year', 'Price')
Row count: 200
~~~

​		请记住，因为星号解包会把结果放在列表中，这就可能耗尽计算机的全部内存并导致程序崩溃。首相必须确定系统有足够的内存可以存储拆分出来的结果数据，然后才可以对迭代器采用星号解包(还有一种做法，参见第13条).

**要点**

* 拆分数据结构并把其中的数据赋给变量时，可以采用星号解包，将结构中无法与普通变量像匹配的内中捕获到列表中
* 星号解包可以出现在赋值符号左侧的任意位置，它总会形成空的或者多值列表
* 在把列表拆分成多个互不重叠的部分时，星号解包比较好用，而通过下标和切片比较麻烦

## 第14条 通过在sort中使用key参数完成复杂排序

​		在python的内置的列表类型中，提供了sort方法用于针对不同情况对列表实例进行复杂排序。默认情况下，sort方法将会按照自然顺序对列表元素进行排序。例如，对整型数据的列表进行从小到大的排序：

~~~python
numbers = [93, 86, 11, 68, 70]
numbers.sort()
print(numbers)
>>>
[11, 68, 70, 86, 93]
~~~

​		sort方法默认情况下能够对几乎所有的内置类型(string、floats等等)进行自然排序。在对象中结构中使用sort方法又会怎么样呢？例如，这里定义一个包含__ repr__ 方法的类，这样类实例是可打印的；例如，这里定义了一个Tool类表示各种建筑工具，它带有一个__  repr__，因此可疑将类实例打印成字符串参见第75条：

~~~python
class Tool:
    def __init__(self, name, weight):
        self.name = name
        self.weight = weight
    def __repr__(self):
        return f'Tool({self.name!r}, {self.weight})'
    tools = [
        Tool('level', 3.5),
        Tool('hammer', 1.25),
        Tool('screwdriver', 0.5),
        Tool('chisel', 0.25),
    ]
~~~

​		但是，这样由类对象所构成的列表是没办法对sort方法进行排序的，因为sort方法所需要的特殊方法并没有在Tool类中定义：

~~~python
tools.sort()
>>>
Traceback ...
TypeError: '<' not supported between instances of 'Tool' and
'Tool'
~~~

​		如果某些类像整数那样拥有自然顺序，就可以定义一些特殊的方法(参见第73条)，这压根就可以通过sort方法而不要额外的参数进行排序了。但是更常见的是，很多对象需要在不同的情况下按照不同的标准排序，此时定义自然排序实际上是没有意义的。

​		通常情况下需要的是对对象中的某个属性进行排序。为了适应这样的排序需求，可疑定义一个由key参数的方法。key所表示的方法本身应该带有一个参数，这个参数指代列表中有待排序的对象，方法返回的应该是个可比较的值(具有自然顺序的值)，以便sort方法以该值为标准给这些对象排序。

​		这里，使用lambda关键字定义一个方法，把它传给sort方法的key关键字来对Tool对象的name属性排序：、

~~~python
class Tool:
    def __init__(self, name, weight):
        self.name = name
        self.weight = weight
    def __repr__(self):
        return f'Tool({self.name!r}, {self.weight})'
tools = [
    Tool('level', 3.5),
    Tool('hammer', 1.25),
    Tool('screwdriver', 0.5),
    Tool('chisel', 0.25),
]
print('Unsorted:', repr(tools))
tools.sort(key=lambda x: x.name)
print('\nSorted: ', tools)
>>>
Unsorted: [Tool('level', 3.5), Tool('hammer', 1.25), Tool('screwdriver', 0.5), Tool('chisel', 0.25)]

Sorted:  [Tool('chisel', 0.25), Tool('hammer', 1.25), Tool('level', 3.5), Tool('screwdriver', 0.5)]
~~~

​		同理，可以很容易的用lambda关键字定义一个针对weight排序的方法，并把它传给sort方法的key关键字，实现对Tool类的weight属性的排序：

~~~python
class Tool:
    def __init__(self, name, weight):
        self.name = name
        self.weight = weight
    def __repr__(self):
        return f'Tool({self.name!r}, {self.weight})'
tools = [
    Tool('level', 3.5),
    Tool('hammer', 1.25),
    Tool('screwdriver', 0.5),
    Tool('chisel', 0.25),
]
print('Unsorted:', repr(tools))
tools.sort(key=lambda x: x.weight)
print('\nSorted: ', tools)
>>>
Unsorted: [Tool('level', 3.5), Tool('hammer', 1.25), Tool('screwdriver', 0.5), Tool('chisel', 0.25)]

Sorted:  [Tool('chisel', 0.25), Tool('screwdriver', 0.5), Tool('hammer', 1.25), Tool('level', 3.5)]
~~~

​		在编写传给key参数的lambda方法时，可以像刚才拿行返回对象的某个属性，如果对象是序列、元组或字典，那么还可以返回其中的某个元素。其实，只要是有效的表达式都可以充当lambda方法的返回值。

​		对于像字符串这样的基本类型，我们可能需要通过key函数先对它的内容做一些变换。并根据变换后的结果排序。例如，下面的这个places列表中存放这地点字符串，如果要在排序前忽略大小写，就可以先使用lower方法把待排序的字符串处理(因为对于字符串来说，自然顺序就是在字母表中的顺序，大写在小写之前)：

```python
class Tool:
    def __init__(self, name, weight):
        self.name = name
        self.weight = weight

    def __repr__(self):
        return f'Tool({self.name!r}, {self.weight})'


places = ['home', 'work', 'New York', 'Paris']
places.sort()
print('Case sensitive: ', places)
places.sort(key=lambda x: x.lower())
print('Case insensitive:', places)
>>>
Case sensitive:  ['New York', 'Paris', 'home', 'work']
Case insensitive: ['home', 'New York', 'Paris', 'work']
```

​		有时可能会需要多个标准进行排序。例如，这里有一些电力工具，需要先通过重量排序再通过名字排序，需要怎么来实现了？

~~~python
power_tools = [
    Tool('drill', 4),
    Tool('circular saw', 5),
    Tool('jackhammer', 40),
    Tool('sander', 4),
]

~~~

​		再python中最简单的方法是：通过元组类型实现。源主是一种不可变的序列，能够存放任意的python值。元组是可比较的且本身含有自然排序，也就是所sort方法需要的特殊方法(例如__ it __)，它都已经定义好了。元组在实现这些特殊方法时会依次比较每个位置上对应位置的元素，知道能够确定大小位置。这里，我们看看其中一个工具比另一个工具重的情况，在这种情况下，只需要根据元组中的第一个元素重量就可以确定两个元组的大小：

~~~python
saw = (5, 'circular saw')
jackhammer = (40, 'jackhammer')
assert not (jackhammer < saw) # Matches expectations
~~~

​		如果两个元组的首个元素相等，就会比较第二个元素，如果仍然相等，就会继续往下比较。这里演示两个重量相同，但是名字不同的元组：

```python
drill = (4, 'drill')
sander = (4, 'sander')
assert drill[0] == sander[0]  # Same weight
assert drill[1] < sander[1]  # Alphabetically less
assert drill < sander  # Thus, drill comes first
```

​		利用元组的这种特性，可以用工具的weight和name构造一个元组。限免就定义一个这样的lambda方法，让他返回元组，把首要指标weight放在前面，次要指标name放在后面：

```python
class Tool:
    def __init__(self, name, weight):
        self.name = name
        self.weight = weight

    def __repr__(self):
        return f'Tool({self.name!r}, {self.weight})'


power_tools = [
    Tool('drill', 4),
    Tool('circular saw', 5),
    Tool('jackhammer', 40),
    Tool('sander', 4),
]
power_tools.sort(key=lambda x: (x.weight, x.name))
print(power_tools)
>>>
[Tool('drill', 4), Tool('sander', 4), Tool('circular saw', 5), Tool('jackhammer', 40)]
```

​		这样做有一个缺点，key方法所构造的这个元组只能按照同一个排序方向对比它所表示的各项指标(如果是升序，就只能是升序；如果是降序，就只能是降序)，所以不太容易实现按照weight降序、name升序这样的情况。sort方法可以指定reverse参数，这个参数会同时影响元组中的所有指标(例如下面的例子中，weight和name都会按照降序处理，所以’sander‘会出现在’drill‘前面，而不像像前面那样)：

```python
class Tool:
    def __init__(self, name, weight):
        self.name = name
        self.weight = weight

    def __repr__(self):
        return f'Tool({self.name!r}, {self.weight})'


power_tools = [
    Tool('drill', 4),
    Tool('circular saw', 5),
    Tool('jackhammer', 40),
    Tool('sander', 4),
]
power_tools.sort(key=lambda x: (x.weight, x.name),
                 reverse=True)  # Makes all criteriadescending
print(power_tools)
>>>
[Tool('jackhammer', 40), Tool('circular saw', 5), Tool('sander', 4), Tool('drill', 4)]
```

​		如果其中一项指标是数字，那么就可以在实现key方法时，利用一元减操作符让两个指标按照不同的方向排序。也就是所，key方法在返回这个元组时，可以单独对这个指标取相反数，并保持其他指标不变，这就相当于让排序算法单独在这个指标上采用逆序。下面就演示怎么按照重量从小到大、名称由大到小的顺序排序(这次，’sander‘会在’drill‘后面)：

```python
class Tool:
    def __init__(self, name, weight):
        self.name = name
        self.weight = weight

    def __repr__(self):
        return f'Tool({self.name!r}, {self.weight})'


power_tools = [
    Tool('drill', 4),
    Tool('circular saw', 5),
    Tool('jackhammer', 40),
    Tool('sander', 4),
]
power_tools.sort(key=lambda x: (-x.weight, x.name))
print(power_tools)
>>>
[Tool('jackhammer', 40), Tool('circular saw', 5), Tool('drill', 4), Tool('sander', 4)]
```

​		但是，这个技巧并不适合所有的类型。例如，若想在指定reverse=True的情况下得到相同的排序结果，就可以对name使用一元减操作符，看能否实现相同的效果：

```python
class Tool:
    def __init__(self, name, weight):
        self.name = name
        self.weight = weight

    def __repr__(self):
        return f'Tool({self.name!r}, {self.weight})'


power_tools = [
    Tool('drill', 4),
    Tool('circular saw', 5),
    Tool('jackhammer', 40),
    Tool('sander', 4),
]
power_tools.sort(key=lambda x: (x.weight, -x.name),
                 reverse=True)
print(power_tools)
>>>
Traceback (most recent call last):
  File "D:/PyCharm_pro/punter_v0.1.8/test/test21.py", line 22, in <module>
    reverse=True)
  File "D:/PyCharm_pro/punter_v0.1.8/test/test21.py", line 21, in <lambda>
    power_tools.sort(key=lambda x: (x.weight, -x.name),
TypeError: bad operand type for unary -: 'str'
```

​		可以看到，str类型不支持”-“操作。在这种情况下，应该考虑sort方法的一项特性，那就是这个方法是个稳定的排序算法。这就意味着，如果key方法认定两个值相同，那么这两个值就在排序结果中的先后顺序就会和他们在排序强的顺序一致。于是，我们可以在同一列表中中多次调用sort方法，每次指定不同的排序标准。下面我们就利用者线特性实现刚才的小果果。把首要指标weight降序放在第二轮，把次要指标name升序放在第一轮：

```python
class Tool:
    def __init__(self, name, weight):
        self.name = name
        self.weight = weight

    def __repr__(self):
        return f'Tool({self.name!r}, {self.weight})'


power_tools = [
    Tool('drill', 4),
    Tool('circular saw', 5),
    Tool('jackhammer', 40),
    Tool('sander', 4),
]
power_tools.sort(key=lambda x: x.name) # Name ascending
power_tools.sort(key=lambda x: x.weight, # Weight descending
                 reverse=True)
print(power_tools)
>>>
[Tool('jackhammer', 40), Tool('circular saw', 5), Tool('drill', 4), Tool('sander', 4)]
```

​		为什么这样可以获得正确的结果呢？我们分开来看。第一轮排序，按照name升序排序：

~~~python
power_tools.sort(key=lambda x: x.name)
print(power_tools)
>>>
[Tool('circular saw', 5),Tool('drill', 4),Tool('jackhammer', 40),Tool('sander', 4)]
~~~

​		然后，第二轮，按照重量重复降序排序。这里由于’sander‘与’drill‘所对应的俩哥哥Tool对象的重量相同，key方法就会判定两个对象相等。于是，在sort方法的排序结果中，他们之间的先后次序就和第一轮结束时相同。所以，我们实现呢按重量降序排序的同时，保留呢质量相同的对象在上一轮排序时的相对顺序，而上一轮时按照name排序的：

~~~python
power_tools.sort(key=lambda x: x.weight,
reverse=True)
print(power_tools)
>>>
[Tool('jackhammer', 40),Tool('circular saw', 5),Tool('drill', 4),Tool('sander', 4)]
~~~

​		无论有多少项排序指标都可以按照这样的思路实现，而且每项指标可以分别按照各自的方向排序，不用全是升序或全是降序。只需倒着写这些即可，也就是把最主要的那项指标放在最后一轮处理。在上面的例子中，首要指标是重量降序，次要指标是name升序，所以要按照name升序、重量降序排列。

​		尽管这两种思路都能实现相同的效果，当只调用一次sort显然要比调用两次sort更加简单。所以，在实现多个指标不同方向的排序时，应该优先考虑让key方法返回元组，并对元组的相应指标取相反数。只有在万不得已时，才考虑多次调用sort方法。

**要点**

* 列表的sort方法可以根据自然顺序给其中的字符串、整形、元组等内置元素进行排序
* 普通对象如果通过特殊方法定义自然顺序，那么也可以用sort方法排序，但这样的对象并不多见
* 可以把辅助函数传给sort方法的key参数，让sort根据这个函数返回的值排列元素顺序，而不是根据元素本身排序
* 如果排序的指标有多个时，可以把他们放在同一个元组中，让key方法返回这样的元组。对于支持”-“操作的类型来说，可以单独给这项指标取反，这让排序算法在这项指标上按照相反的方向处理
* 如果这些指标不支持”-“操作，可以多次调用sort方法，并在每次调用时分别指定key方法与reverse参数。最迟要的指标放在第一轮，然后逐步处理更重要的指标，最后处理最重要的指标

## 第15条 不要过分依赖给字典添加条目时所用的顺序

<<<<<<< HEAD
	在python3.5及其之前的版本中，当迭代字典时，会以任意的顺序返回字典key，这些key的顺序与之前构造字典时元素的插入顺序并非相同。例如，构造一个字典，用来匹配动物的名字和他们的幼崽的名字，然后输出(常见第75条)：
=======
​		在python3.5及其之前的版本中，当迭代字典时，会以任意的顺序返回字典key，这些key的顺序与之前构造字典时元素的插入顺序并非相同。例如，构造一个字典，用来匹配动物的名字和他们的幼崽的名字，然后输出(常见第75条)：
>>>>>>> ce37f296022b6527731d3ae60d135c7e9e712ae1

~~~python
# Python 3.5
baby_names = {
	'cat': 'kitten',
    'dog': 'puppy',
}
print(baby_names)
>>>
{'dog': 'puppy', 'cat': 'kitten'}
~~~

​		在创建字典的时候，key值的顺序时先cat后dog，然而打印出来的时候顺序却相反，先dog后cat。这样的结果让人意想不到，而且每次看到得的顺序不固定，因此很难在调试用例中使用。这会让调试变得更加困难，并且会让python小白更加困惑。

​		出现这种情况的原因是，字典类型之前使用hash表算法来实现的(这个算法通过内置的hash函数与一个随机的种子数来运行，而该种子数每次启动python解析器时确定)。所以，这样的机制导致这些键值对在字典中的存放顺序不一定会与添加时的顺序相同，所以每次程序运行的时候，存放顺序可能都不一样。

​		从python3.6开始，尤其是python3.7，字典会保留插入时键值对的顺序。现在，程序会按照字典插入时的键值对顺序打印：

~~~python
baby_names = {
    'cat': 'kitten',
    'dog': 'puppy',
}
print(baby_names)
>>>
{'cat': 'kitten', 'dog': 'puppy'}
~~~

​		在python3.5或者更早的版本中，字典中提供的方法(包括keys、values、items、popitem等)都不保证固定顺序，所以让人感觉时随机的：

~~~python
# Python 3.5
print(list(baby_names.keys()))
print(list(baby_names.values()))
print(list(baby_names.items()))
print(baby_names.popitem()) # Randomly chooses an item
>>>
['dog', 'cat']
['puppy', 'kitten']
[('dog', 'puppy'), ('cat', 'kitten')]
('dog', 'puppy')

~~~

​		在新的版本中，上面的这些方法都会按照添加键值对时的顺序处理字典：

~~~python
print(list(baby_names.keys()))
print(list(baby_names.values()))
print(list(baby_names.items()))
print(baby_names.popitem()) # Last item inserted
>>>
['cat', 'dog']
['kitten', 'puppy']
[('cat', 'kitten'), ('dog', 'puppy')]
('dog', 'puppy')

~~~

​		python的这项改变，对其他的依赖dict类型的特性产生了很大影响。

​		函数的关键字参数(包括万能的**kwargs参数，参见第23条)，以前时几乎都是按照随机顺序产生的，在调用方法时很难调试：

~~~python
# Python 3.5
def my_func(**kwargs):
    for key, value in kwargs.items():
    	print('%s = %s' % (key, value))
my_func(goose='gosling', kangaroo='joey')
>>>
kangaroo = joey
goose = gosling
~~~

​		现在这些关键字参数总是能够保证函数调用时所指定的顺序：

~~~python
def my_func(**kwargs):
    for key, value in kwargs.items():
    	print(f'{key} = {value}')
my_func(goose='gosling', kangaroo='joey')
>>>
goose = gosling
kangaroo = joey
~~~

​		另外，类也会利用字典来保证这个类的实例所具备的一些数据。在早起的python版本中，对象中得字段看上去也是随机的：

~~~python
# Python 3.5
class MyClass:
    def __init__(self):
        self.alligator = 'hatchling'
        self.elephant = 'calf'
a = MyClass()
for key, value in a.__dict__.items():
	print('%s = %s' % (key, value))
>>>
elephant = calf
alligator = hatchling

~~~

​		同样，在新版本的python中，--dict--中各个字段的出现顺序与当初赋值的时候一样：

~~~python
class MyClass:
    def __init__(self):
        self.alligator = 'hatchling'
        self.elephant = 'calf'
a = MyClass()
for key, value in a.__dict__.items():
        print(f'{key} = {value}')
>>>
alligator = hatchling
elephant = calf
~~~

​		现在python语言规范已经要求，字典必须保留添加键值对时依照的顺序。所以，可以利用这些特性来实现一些功能，而且可以把它融入到设计的类和方法的API中。

***

**提示**

​		其实，内置的collections模块早就提供了这种能够保留插入顺序的字典，叫做OrderDict。它的行为跟(python3.7以来)标准的dict很像，但性能上有区别。如果要频繁的插入或弹出键值对(例如钥匙链least-recently-uesd缓存)，那么OrderedDict可能比标准的dict更加合适(如何判断私有应该用这种类型，参见第70条)。

***

​		然而，当使用字典时，并不能保证所有情况都能保证键值对插入时的顺序。在python中，开发者很容易就定义它自己的容器类型，并使得这些容器类型可以先标准的list、dict那样遵守相关协议(参见第43条)。python并非是静态类型的语言，大多数代码都一个鸭子类型(duck typing)机制运转(也就是说，对象支持什么样的行为，就可以当作什么样的数据处理，而不用执着于他在类体系中的地位)。这种特性可能会有意想不到的效果。

​		例如，写一个程序，统计各个小动物的受欢迎程度。我们可以假定一个字典，并把每个动物和它的的票数据关联在一起。

~~~python
votes = {
    'otter': 1281,
    'polar bear': 587,
	'fox': 863,
}
<<<<<<< HEAD
~~~
=======
>>>>>>> ce37f296022b6527731d3ae60d135c7e9e712ae1

​		现在定义一个方法来处理投票数据。用户可以把空的字典传递给这个函数，这样的话，它就会把每个动物及排名放到这个字典中。这种字典剋充当数据模型，给用户界面提供元素：

~~~python
def populate_ranks(votes, ranks):
    names = list(votes.keys())
    names.sort(key=votes.get, reverse=True)
    for i, name in enumerate(names, 1):
    	ranks[name] = i
<<<<<<< HEAD
=======

>>>>>>> ce37f296022b6527731d3ae60d135c7e9e712ae1
~~~

​		还需要一个方法用来输出人气最高的动物。这个方法假定populate_ranks总是会按照升序向字典写入键值对，这样第一个出现在字典里的就应该是最考前的动物。

~~~python
def get_winner(ranks):
	return next(iter(ranks))
~~~

​		下面就验证刚才设计的方法，看他们是否可以实现预期效果：

~~~python
ranks = {}
populate_ranks(votes, ranks)
print(ranks)
winner = get_winner(ranks)
print(winner)
>>>
{'otter': 1, 'fox': 2, 'polar bear': 3}
otter
~~~

​		现在，如果这个项目需求变了。前端UI显示要按照字母顺序显示，而不是原来那样按照名次显示。为了实现这样的效果，调用内置的collections.abc模块定义这样一个类。类的功能和字典一样，而且会按照字母顺序迭代其中的内容：

~~~python
from collections.abc import MutableMapping

class SortedDict(MutableMapping):
    def __init__(self):
    	self.data = {}
    def __getitem__(self, key):
   	 return self.data[key]
    def __setitem__(self, key, value):
    	self.data[key] = value
    def __delitem__(self, key):
    	del self.data[key]
    def __iter__(self):
        keys = list(self.data.keys())
        keys.sort()
        for key in keys:
        	yield key
    def __len__(self):
    	return len(self.data)
~~~

<<<<<<< HEAD
​		原来使用标准dict的地方，现在可以改用这个类实例。SortedDict类与标准字典遵循同一套协议，因此程序不会报错。但是，并不能得到正确的结果。

~~~python
sorted_ranks = SortedDict()
populate_ranks(votes, sorted_ranks)
print(sorted_ranks.data)
winner = get_winner(sorted_ranks)
print(winner)
>>>
{'otter': 1, 'fox': 2, 'polar bear': 3}
fox
~~~

​		出现问题的原因是，get_winner方法总是假设迭代字典时的顺序和populate_rangks方法当初向字典中插入数据时的顺序一样。这里使用了SortedDict代替了dict，所以假设不再成立了。因此，函数按照字母变顺序第一个的元素‘fox’。

​		这里有三种方法解决问题。第一种是重新写get_winner方法，是它不再假设ranks字典按照固定的顺序来迭代。这是最保险、稳妥的解决方法：

~~~python
def get_winner(ranks):
    for name, rank in ranks.items():
        if rank == 1:
        	return name
winner = get_winner(sorted_ranks)
print(winner)
>>>
otter
~~~

​		第二种方法是在方法最开始判断ranks是不是预期的那种标准字典。如果不是，就抛出异常。这个方法的运行性比第一种好一些：

~~~python
def get_winner(ranks):
    if not isinstance(ranks, dict):
    	raise TypeError('must provide a dict instance')
    return next(iter(ranks))
get_winner(sorted_ranks)
>>>
Traceback ...
TypeError: must provide a dict instance

~~~

​		第三种方法是通过类型注解(type annotation)来保证给get_winner方法的的确是一个真正的dic实例，而不是那种行为和标准字典类似的MutableMappling(参见第90条)。下面就采用严格模式，针对含有注解的代码运行mypy工具：

~~~python
from typing import Dict, MutableMapping
def populate_ranks(votes: Dict[str, int],
					ranks: Dict[str, int]) -> None:
	names = list(votes.keys())
	names.sort(key=votes.get, reverse=True)
    for i, name in enumerate(names, 1):
    	ranks[name] = i
def get_winner(ranks: Dict[str, int]) -> str:
	return next(iter(ranks))
class SortedDict(MutableMapping[str, int]):
...
votes = {
'otter': 1281,
'polar bear': 587,
'fox': 863,
}
sorted_ranks = SortedDict()
populate_ranks(votes, sorted_ranks)
print(sorted_ranks.data)
winner = get_winner(sorted_ranks)
print(winner)

>>>
$ python3 -m mypy --strict example.py
.../example.py:48: error: Argument 2 to "populate_ranks" has
➥incompatible type "SortedDict"; expected "Dict[str, int]"
.../example.py:50: error: Argument 1 to "get_winner" has
➥incompatible type "SortedDict"; expected "Dict[str, int]"
~~~

​		这样可以检测出来类型不符的问题，mypy会标出错误的用法，指出方法要求的是dict，但是传入的确实MutableMapping。这个方案既能保证静态类型的正确性，也能不会影响程序运行的效率。

**要点**

* 从Python3.7开始，就可以确信迭代标准字典时所看到的顺序和插入字典时的顺序一致
* 在Python代码中，很容易就可以定义出跟标准字典很像但是又不是dict实例的对象。对于这种类型的对象，不能假设迭代时的顺序和插入时的顺序相同
* 如果不想把这种跟标准字典很相似的类型也当成标准字典来处理，可以考虑这三种方法：第一，不要依赖插入时的顺序编写代码；第二、在程序运行时明确判断它是不是标准字典；第三、给代码添加注解并做静态分析
=======





>>>>>>> ce37f296022b6527731d3ae60d135c7e9e712ae1

