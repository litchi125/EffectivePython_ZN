# 第二章 列表和字典

​		许多程序都是用来执行自动化重复的任务的，这些程序更适合机器处理而非人。在Python中，最常见的方式是通过使用一个列表存储任务序列来处理这些任务。列表的用途十分广泛，并且可以用来解决各种各样的问题。

​		有了列表，自然就有了跟它互补的结构，即字典，它存储映射键值对(这也叫关键矩阵或者哈希表)。对于字典来说，访问与赋值所花费的时间平均下来是常量，所以这种结构很适合存储动态信息。

​		Python拥有独特的语法和内置模块来增强列表和字典的可读性并拓展其能力，这要比能想到的其他语言中的简单数组、向量或哈希表都要强。

## 第11条 了解怎么切分序列

​		Python拥有对序列进行切分的语法。这种切片允许以最小的代价获取序列的子集。最简单的用法就是切割内置的list、str与bytes类型。其实，实现了__ getitem__和 __ setitem__方法的任何Python类都可以进行切片(参见第43条)。

​		最基本的切片语法就是somelist[start : end]，也就是获取start到end前一个的所有元素：

~~~python
a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
print('Middle two: ', a[3:5])
print('All but ends:', a[1:7])
>>>
Middle two: ['d', 'e']
All but ends: ['b', 'c', 'd', 'e', 'f', 'g']
~~~

​		当从列表的第一个元素开始切片时，就可以省略冒号左侧的0，这能让代码更清晰：

~~~pyuthon
a[:5] == a[0:5]
~~~

​		当切片刀列表的末尾时，可以省略冒号右侧的下标：

~~~python
a[5:] == a[5:len(a)]
~~~

​		使用负数作为下标表示从列表末尾往前算。下面这些切割方式，即便刚看到这些代码也可以明白什么意思：

~~~python
a[:] # ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
a[:5] # ['a', 'b', 'c', 'd', 'e']
a[:-1] # ['a', 'b', 'c', 'd', 'e', 'f', 'g']
a[4:] # ['e', 'f', 'g', 'h']
a[-3:] # ['f', 'g', 'h']
a[2:5] # ['c', 'd', 'e']
a[2:-1] # ['c', 'd', 'e', 'f', 'g']
a[-3:-1] # ['f', 'g']
~~~

​		这并没有什么独特之处，尽管用就好。

​		如果起点和终点所确定的范围超过了列表的边界，系统会自动忽略不存在的元素。利用这些特性，很容易就能构造出一个最多只有若干元素的序列，例如：

~~~python
first_twenty_items = a[:20]
last_twenty_items = a[-20:]
~~~

​		切片时下标可以越界，但是直接访问时却会抛出异常：

~~~python
a[20]
>>>
Traceback ...
IndexError: list index out of range

~~~

***

**提示**

​		在用负数对列表进行切片时，只有少数情况会得到意想不到的结果。只要n大于或等于1，somelist[-n : 1]总是可以切出预期的结果。只有当n为0时，才需要特别注意。此时somelist[-0 : ]相当于somelist[0 :]，所以更somelist[ : ]一暗影，会制作出原来列表的一份副本。

***

​		从原有列表中切割出来的列表是一个全新的列表。即便出去某个元素，也不影响原来的列表。原列表的对应位置值不变：

~~~python
b = a[3:]
print('Before: ', b)
b[1] = 99
print('After: ', b)
print('No change:', a)
>>>
Before: ['d', 'e', 'f', 'g', 'h']
After: ['d', 99, 'f', 'g', 'h']
No change: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
~~~

​		切片可以出现在赋值符号的左侧，表示右侧那些元素把源列表中位于这个范围之内的元素替换掉。这与解包操作的赋值不同，这种赋值不要求等号两边所指定的元素个数相同(例如，a,b =c[:2]，参见第6条)。在原列表中，位于切片范围之前和之后的那些元素会予以保留，但是列表的长度可能有所改变。例如下面这个例子中，列表的长度会变短，因为赋值符号右侧值提供了三个值，但是左侧的切片却包含了五个值，列表会比原来少两个元素：

~~~python
print('Before ', a)
a[2:7] = [99, 22, 14]
print('After ', a)
>>>
Before ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
After ['a', 'b', 99, 22, 14, 'h']
~~~

​		下面这种情况，列表会变长，因为赋值符号右侧的元素数量比左侧切片所涵盖的元素数量多：

~~~python
print('Before ', a)
a[2:3] = [47, 11]
print('After ', a)
>>>
Before ['a', 'b', 99, 22, 14, 'h']
After ['a', 'b', 47, 11, 22, 14, 'h']
~~~

​		起始位置都留空的切片，如果出现在赋值符号的右侧，那么表示给这个列表做副本，这样制作出来的新列表内容和原列表相同，但身份不同。

~~~python
b = a[:]
assert b == a and b is not a
~~~

​		把不带起止下标的切片放在赋值符号的左侧，表示用右侧那个列表的副本把左侧列表的内容全部替换(注意左侧列表依旧保持原来身份，系统不会分配新的列表)：

~~~python
b = a
print('Before a', a)
print('Before b', b)
a[:] = [101, 102, 103]
assert a is b # Still the same list object
print('After a ', a) # Now has different contents
print('After b ', b) # Same list, so same contents as a
>>>
Before a ['a', 'b', 47, 11, 22, 14, 'h']
Before b ['a', 'b', 47, 11, 22, 14, 'h']
After a [101, 102, 103]
After b [101, 102, 103]
~~~

**要点**

* 切片要尽可能简单：如果从头开始选取就省略下标0；如果要选到序列末尾，就省略终止下标
* 切片允许起始和终止下标越界，所以很容易就能飙到“取开头多少个元素”(例如a[:20])或“取末尾多少个元素”(例如a[-20 : 0])，而且不用担心切片是否真有这么多元素
* 把切片放在赋值符号的左侧可以将原来列表中这段范围的元素用付支付号右侧的元素替换掉，但可能会改变原列表的长度

## 第12条 避免在切边里同时指定起止下标和步进

​		除了切边的基本操作外(参见第11条)，Python还有特殊的补进切片方式someli[start : end : stride]。这种形式会在每n个元素里选取一个，这样很容易就能把技术位置上的元素和偶数上的元素分别通过x[::2]与x[1::2]选取出来：

~~~python
x = ['red', 'orange', 'yellow', 'green', 'blue', 'purple']
odds = x[::2]
evens = x[1::2]
print(odds)
print(evens)
>>>
['red', 'yellow', 'blue']
['orange', 'green', 'purple']
~~~

​		切片时采用步进经常会有意想不到的结果，并且会导致程序出现bug。例如，Python里面常用的倒置字符串的技巧，就是采用步长为-1的切片：

~~~python
x = b'mongoose'
y = x[::-1]
print(y)
>>>
b'esoognom'
~~~

​		这个技巧同样适用于Unicode字符串(参见第3条)：

~~~python
x = '寿司'
y = x[::-1]
print(y)
>>>
司寿
~~~

​		但是如果Unicode字符创采用UTF-8编码时，这个技巧就失效了：

~~~python
w = '寿司'
x = w.encode('utf-8')
y = x[::-1]
z = y.decode('utf-8')
>>>
Traceback ...
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xb8 in
position 0: invalid start byte
~~~

​		除了-1以外，其他的负数步进是否有用呢？思考下下面的例子：

~~~python
x = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
x[::2] # ['a', 'c', 'e', 'g']
x[::-2] # ['h', 'f', 'd', 'b']
~~~

​		这里，::2表示“从起始位置每两个元素取一个”。有趣的是，::-2表示“从末尾开始每两个元素取一个”。

​		2::2表示什么呢？同理，-2::2\-2::-2,2:2:-2表示什么意思呢？

~~~python
x[2::2] # ['c', 'e', 'g']
x[-2::-2] # ['g', 'e', 'c', 'a']
x[-2:2:-2] # ['g', 'e']
x[2:2:-2] # []
~~~

​		同时使用起止下标和步进会让切片很难理解。方括号里面写三个值会很不简洁，很不易读，而且在指定了步进值时(尤其是负数步进值)，必须要考虑是从强往后还是从后往前。

​		为了避免这个问题，建议在使用起止下标时，避免使用步进值。如果必须使用步进，尽量使用正数步进值，同时置空起止下标。如果必须同时使用起止下标和步进值，应该分开来写：

~~~python
y = x[::2] # ['a', 'c', 'e', 'g']
z = y[1:-1] # ['c', 'e']
~~~

​		先步进取值然后再切割，会让程序多一次浅**拷贝(shallow copy)**.所以，应该吧最能缩减李彪长度的切片操作放在最前面。如果程序实在没有那么多时间或内存去分两步操作，那么可以改用内置的itertools模块的islice方法(参见第36条)，这个方法用起来更加清晰，因为他的起止位置与步进值都不能为负数。

**要点**

* 同时制定起止位置与步进会让代码晦涩难懂
* 尽量使用正数步进值且把起止下标置空，避免使用负数步进值
* 避免在同一个切片操作中使用起止下标和步进值。如果必须同时使用，应分两次操作(一次隔位取值，一次做切片)，也可以采用内置itertools模块的islice方法。

