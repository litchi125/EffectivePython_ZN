# 第五章 类和接口

​		作为一种面向对象的编程语言，python支持各种特性，例如继承、封装和多态。用python完成工作通常需要编写新的类，并定义他们如何通过接口和层次结构进行交互。

​		Python的类和继承使得程序对对象内部活动进行拓展变得很容易。这能够使得随着时间的推移改进和扩展功能。它们在需求不断变化的环境中提供了灵活性。了解如何很好地使用它们使您能够编写可维护的代码。

## 第37条 使用组合类，而不是嵌套多级内置类型

​		Python的内置字典类型非常适合在对象的生命周期内保持动态的内部状态。所谓动态，指的是需要为一组意料之外的标识符进行标记的情况。例如，假设我要记录一组成绩没有提前知道名字的学生。我可以定义一个类来存储名字在字典中，而不是使用预定义的属性为每个学生:

~~~python
class SimpleGradebook:
    def __init__(self):
        self._grades = {}

    def add_student(self, name):
        self._grades[name] = []

    def report_grade(self, name, score):
        self._grades[name].append(score)

    def average_grade(self, name):
        grades = self._grades[name]
        return sum(grades) / len(grades)
   
book = SimpleGradebook()
book.add_student('Isaac Newton')
book.report_grade('Isaac Newton', 90)
book.report_grade('Isaac Newton', 95)
book.report_grade('Isaac Newton', 85)
print(book.average_grade('Isaac Newton'))
>>>
90.0
~~~

​		字典及其相关的内置类型非常容易使用，因此有过度扩展它们而编写脆弱代码的危险。例如，假设我想要扩展SimpleGradebook类，以按学科保存评分列表，而不只是按总体排名。我可以通过更改_grades字典来将学生名(它的键)映射到另一个字典(它的值)来做到这一点。最里面的字典将主题(它的键)映射到等级列表(它的值)。在这里，我通过使用内部字典的defaultdict实例来处理丢失的主题(参见第17条)：

```python
from collections import defaultdict
class BySubjectGradebook:
    def __init__(self):
        self._grades = {} # Outer dict
    def add_student(self, name):
        self._grades[name] = defaultdict(list) # Inner dict
```

​		这看上去非常直观。report_grade和average_grade方法在处理多级字典时变得相当复杂，但它看起来是可以管理的：

~~~python
from collections import defaultdict


class BySubjectGradebook:
    def __init__(self):
        self._grades = {}  # Outer dict

    def add_student(self, name):
        self._grades[name] = defaultdict(list)  # Inner dict

    def report_grade(self, name, subject, grade):
        by_subject = self._grades[name]
        grade_list = by_subject[subject]
        grade_list.append(grade)

    def average_grade(self, name):
        by_subject = self._grades[name]
        total, count = 0, 0
        for grades in by_subject.values():
            total += sum(grades)
            count += len(grades)
        return total / count
book = BySubjectGradebook()
book.add_student('Albert Einstein')
book.report_grade('Albert Einstein', 'Math', 75)
book.report_grade('Albert Einstein', 'Math', 65)
book.report_grade('Albert Einstein', 'Gym', 90)
book.report_grade('Albert Einstein', 'Gym', 95)
print(book.average_grade('Albert Einstein'))
>>>
81.25    
~~~

​		现在，假设需求再次发生变化。还想跟踪每个分数在班级总成绩中的权重，这样期中和期末考试就比随堂测验更重要。实现这个特性的一种方法是改变最内层的字典;可以在值列表中使用(score, weight)元组，而不是将主题(其键)映射到等级列表(其值)：

~~~python
class WeightedGradebook:
    def __init__(self):
        self._grades = {}

    def add_student(self, name):
        self._grades[name] = defaultdict(list)

    def report_grade(self, name, subject, score, weight):
        by_subject = self._grades[name]
        grade_list = by_subject[subject]
        grade_list.append((score, weight))

    def average_grade(self, name):
        by_subject = self._grades[name]

        score_sum, score_count = 0, 0
        for subject, scores in by_subject.items():
            subject_avg, total_weight = 0, 0
        for score, weight in scores:
            subject_avg += score * weight
        total_weight += weight
        score_sum += subject_avg / total_weight
        score_count += 1
    return score_sum / score_count
~~~

​		尽管report_grade方法的改变很简单，只是将原来的grade值改编成了元组实例，但是average_grade方法现在却多了一个循环，这很不易读懂：

​		使用这个类也变得更加困难。不清楚位置参数中的所有数字是什么意思:

~~~python
class WeightedGradebook:
    def __init__(self):
        self._grades = {}

    def add_student(self, name):
        self._grades[name] = defaultdict(list)

    def report_grade(self, name, subject, score, weight):
        by_subject = self._grades[name]
        grade_list = by_subject[subject]
        grade_list.append((score, weight))
        print(grade_list)

    def average_grade(self, name):
        by_subject = self._grades[name]

        score_sum, score_count = 0, 0
        for subject, scores in by_subject.items():
            subject_avg, total_weight = 0, 0
            for score, weight in scores:
                subject_avg += score * weight
                total_weight += weight
            score_sum += subject_avg / total_weight
            score_count += 1
        return score_sum / score_count


book = WeightedGradebook()
book.add_student('Albert Einstein')
book.report_grade('Albert Einstein', 'Math', 75, 0.05)
book.report_grade('Albert Einstein', 'Math', 65, 0.15)
book.report_grade('Albert Einstein', 'Math', 70, 0.80)
book.report_grade('Albert Einstein', 'Gym', 100, 0.40)
book.report_grade('Albert Einstein', 'Gym', 85, 0.60)
print(book.average_grade('Albert Einstein'))
>>>
80.25
~~~

​		但看到这种复杂的情况时，就应该从内置类型(例如字典、元组、集合、列表)到类的层次结构的转换了。

​		在分数的例子中，起初不知道需要支持加权分数，所以创建类的复杂性似乎没有必要。Python的内置字典和元组类型使它很容易进行不能类型的嵌套。但是应该避免多层嵌套;使用包含字典的字典会使其他程序员难以阅读您的代码，并且代码极难维护。

​		一旦意识到存储方式变得复杂，把它分解成类。然后，可以提供定义良好的接口来更好地封装数据。这种方法还允许您接口和具体实现之间创建一个抽象层。

**类重构**

​		重构有很多方法(参见第89条)。在这种情况下，可以开始移动到依赖树底部的类:单个等级。对于如此简单的信息，类似乎太重量级了。但是，元组似乎是合适的，因为等级是不可变的。在这里，使用(score, weight)元组来跟踪列表中的分数：

~~~python
grades = []
grades.append((95, 0.45))
grades.append((85, 0.55))
total = sum(score * weight for score, weight in grades)
total_weight = sum(weight for _, weight in grades)
average_grade = total / total_weight
~~~

​		使用_(下划线变量名，Python对未使用变量的约定)来捕获每个等级的元组中的第一个条目，并在计算total_weight时忽略它。

​		此代码的问题是元组实例是位置性的。例如,如果需要关于一个年级的更多信息,比如一组老师的笔记, 这就需要重写每个对two-tuple使用。现在有三个项目而不是两个,这意味着我需要使用_进一步忽略某些索引:

```python
grades = []
grades.append((95, 0.45, 'Great job'))
grades.append((85, 0.55, 'Better next time'))
total = sum(score * weight for score, weight, _ in grades)
total_weight = sum(weight for _, weight, _ in grades)
average_grade = total / total_weight
```

​		这种不断扩展元组的模式类似于加深字典层。一旦发现超过了二元组，就该考虑另一种方法了。

​		这时内置模块collections中的namedtuple类型完全完成了在这种情况下所需要的：它可以很容易地定义微小的、不可变的数据类:

~~~python
from collections import namedtuple
Grade = namedtuple('Grade', ('score', 'weight'))
~~~

​		这些类可以用位置或关键字参数来构造。这些字段可以通过命名属性访问。有了命名属性，以后如果需求再次发生变化，比如需要在简单数据容器中支持可变性或行为，就可以很容易地从命名元组转移到类。

***

**namedtuple的限制性**

​		尽管在很多场合下namedtuple是适用的，但是理解他的机制百利无一害：

* 不能为命名元组类指定默认参数值。当数据可能有许多可选属性时，这会使它们变得笨拙。如果发现自己使用了很多属性，那么使用内置的数据类模块可能是更好的选择
* namedtuple实例的属性值仍然可以使用数值索引和迭代访问。特别是在外部化的api中，这可能会导致无意的使用，从而使以后转移到真正的类变得更加困难。如果不能控制namedtuple实例的所有使用，最好是显式定义一个新类

***

​		接下来，可以编写一个类来表示包含一组分数的单一科目：

~~~python
class Subject:
    def __init__(self):
        self._grades = []
        
    def report_grade(self, score, weight):
        self._grades.append(Grade(score, weight))
        
    def average_grade(self):
        total, total_weight = 0, 0
        for grade in self._grades:
            total += grade.score * grade.weight
            total_weight += grade.weight
        return total / total_weight
~~~

​		然后，我写一个类来代表一个学生正在学习的一组主题：

~~~python
class Student:
    def __init__(self):
        self._subjects = defaultdict(Subject)
        
    def get_subject(self, name):
        return self._subjects[name]
    
    def average_grade(self):
        total, count = 0, 0
        for subject in self._subjects.values():
            total += subject.average_grade()
            count += 1
        return total / count
~~~

​		最后，我将为所有学生编写一个容器，根据他们的名字动态键入：

~~~python
class Gradebook:
    def __init__(self):
        self._students = defaultdict(Student)
    
    def get_student(self, name):
        return self._students[name]
~~~

​		这些类的行数几乎是以前实现大小的两倍。但是这个代码更容易阅读。驱动这些类的示例也更清晰和可扩展:

~~~python
book = Gradebook()
albert = book.get_student('Albert Einstein')
math = albert.get_subject('Math')
math.report_grade(75, 0.05)
math.report_grade(65, 0.15)
math.report_grade(70, 0.80)
gym = albert.get_subject('Gym')
gym.report_grade(100, 0.40)
gym.report_grade(85, 0.60)
print(albert.average_grade())
>>>
80.25
~~~

​		也可以编写向后兼容的方法来帮助将旧API风格的使用迁移到新的对象层次结构中。

**要点**

* 避免使用字典、长元组或其他内置类型的复杂嵌套的值创建字典
* 在需要一个完整类的灵活性之前，使用namedtuple作为轻量级的、不可变的数据容器
* 当内部状态字典变得复杂时，将存储方式改为使用多个类

