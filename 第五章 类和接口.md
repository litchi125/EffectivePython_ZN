# 第五章 类和接口

​		作为一种面向对象的编程语言，python支持各种特性，例如继承、封装和多态。用python完成工作通常需要编写新的类，并定义他们如何通过接口和层次结构进行交互。

​		Python的类和继承使得程序对对象内部活动进行拓展变得很容易。这能够使得随着时间的推移改进和扩展功能。它们在需求不断变化的环境中提供了灵活性。了解如何很好地使用它们使您能够编写可维护的代码。

## 第37条 使用组合类，而不是嵌套多级内置类型

​		Python的内置字典类型非常适合在对象的生命周期内保持动态的内部状态。所谓动态，指的是需要为一组意料之外的标识符进行标记的情况。例如，假设我要记录一组成绩没有提前知道名字的学生。我可以定义一个类来存储名字在字典中，而不是使用预定义的属性为每个学生:

~~~python
class SimpleGradebook:
    def __init__(self):
        self._grades = {}

    def add_student(self, name):
        self._grades[name] = []

    def report_grade(self, name, score):
        self._grades[name].append(score)

    def average_grade(self, name):
        grades = self._grades[name]
        return sum(grades) / len(grades)
   
book = SimpleGradebook()
book.add_student('Isaac Newton')
book.report_grade('Isaac Newton', 90)
book.report_grade('Isaac Newton', 95)
book.report_grade('Isaac Newton', 85)
print(book.average_grade('Isaac Newton'))
>>>
90.0
~~~

​		字典及其相关的内置类型非常容易使用，因此有过度扩展它们而编写脆弱代码的危险。例如，假设我想要扩展SimpleGradebook类，以按学科保存评分列表，而不只是按总体排名。我可以通过更改_grades字典来将学生名(它的键)映射到另一个字典(它的值)来做到这一点。最里面的字典将主题(它的键)映射到等级列表(它的值)。在这里，我通过使用内部字典的defaultdict实例来处理丢失的主题(参见第17条)：

```python
from collections import defaultdict
class BySubjectGradebook:
    def __init__(self):
        self._grades = {} # Outer dict
    def add_student(self, name):
        self._grades[name] = defaultdict(list) # Inner dict
```

​		这看上去非常直观。report_grade和average_grade方法在处理多级字典时变得相当复杂，但它看起来是可以管理的：

~~~python
from collections import defaultdict


class BySubjectGradebook:
    def __init__(self):
        self._grades = {}  # Outer dict

    def add_student(self, name):
        self._grades[name] = defaultdict(list)  # Inner dict

    def report_grade(self, name, subject, grade):
        by_subject = self._grades[name]
        grade_list = by_subject[subject]
        grade_list.append(grade)

    def average_grade(self, name):
        by_subject = self._grades[name]
        total, count = 0, 0
        for grades in by_subject.values():
            total += sum(grades)
            count += len(grades)
        return total / count
book = BySubjectGradebook()
book.add_student('Albert Einstein')
book.report_grade('Albert Einstein', 'Math', 75)
book.report_grade('Albert Einstein', 'Math', 65)
book.report_grade('Albert Einstein', 'Gym', 90)
book.report_grade('Albert Einstein', 'Gym', 95)
print(book.average_grade('Albert Einstein'))
>>>
81.25    
~~~

​		现在，假设需求再次发生变化。还想跟踪每个分数在班级总成绩中的权重，这样期中和期末考试就比随堂测验更重要。实现这个特性的一种方法是改变最内层的字典;可以在值列表中使用(score, weight)元组，而不是将主题(其键)映射到等级列表(其值)：

~~~python
class WeightedGradebook:
    def __init__(self):
        self._grades = {}

    def add_student(self, name):
        self._grades[name] = defaultdict(list)

    def report_grade(self, name, subject, score, weight):
        by_subject = self._grades[name]
        grade_list = by_subject[subject]
        grade_list.append((score, weight))

    def average_grade(self, name):
        by_subject = self._grades[name]

        score_sum, score_count = 0, 0
        for subject, scores in by_subject.items():
            subject_avg, total_weight = 0, 0
        for score, weight in scores:
            subject_avg += score * weight
        total_weight += weight
        score_sum += subject_avg / total_weight
        score_count += 1
    return score_sum / score_count
~~~

​		尽管report_grade方法的改变很简单，只是将原来的grade值改编成了元组实例，但是average_grade方法现在却多了一个循环，这很不易读懂：

​		使用这个类也变得更加困难。不清楚位置参数中的所有数字是什么意思:

~~~python
class WeightedGradebook:
    def __init__(self):
        self._grades = {}

    def add_student(self, name):
        self._grades[name] = defaultdict(list)

    def report_grade(self, name, subject, score, weight):
        by_subject = self._grades[name]
        grade_list = by_subject[subject]
        grade_list.append((score, weight))
        print(grade_list)

    def average_grade(self, name):
        by_subject = self._grades[name]

        score_sum, score_count = 0, 0
        for subject, scores in by_subject.items():
            subject_avg, total_weight = 0, 0
            for score, weight in scores:
                subject_avg += score * weight
                total_weight += weight
            score_sum += subject_avg / total_weight
            score_count += 1
        return score_sum / score_count


book = WeightedGradebook()
book.add_student('Albert Einstein')
book.report_grade('Albert Einstein', 'Math', 75, 0.05)
book.report_grade('Albert Einstein', 'Math', 65, 0.15)
book.report_grade('Albert Einstein', 'Math', 70, 0.80)
book.report_grade('Albert Einstein', 'Gym', 100, 0.40)
book.report_grade('Albert Einstein', 'Gym', 85, 0.60)
print(book.average_grade('Albert Einstein'))
>>>
80.25
~~~

​		但看到这种复杂的情况时，就应该从内置类型(例如字典、元组、集合、列表)到类的层次结构的转换了。

​		在分数的例子中，起初不知道需要支持加权分数，所以创建类的复杂性似乎没有必要。Python的内置字典和元组类型使它很容易进行不能类型的嵌套。但是应该避免多层嵌套;使用包含字典的字典会使其他程序员难以阅读您的代码，并且代码极难维护。

​		一旦意识到存储方式变得复杂，把它分解成类。然后，可以提供定义良好的接口来更好地封装数据。这种方法还允许您接口和具体实现之间创建一个抽象层。

**类重构**

​		重构有很多方法(参见第89条)。在这种情况下，可以开始移动到依赖树底部的类:单个等级。对于如此简单的信息，类似乎太重量级了。但是，元组似乎是合适的，因为等级是不可变的。在这里，使用(score, weight)元组来跟踪列表中的分数：

~~~python
grades = []
grades.append((95, 0.45))
grades.append((85, 0.55))
total = sum(score * weight for score, weight in grades)
total_weight = sum(weight for _, weight in grades)
average_grade = total / total_weight
~~~

​		使用_(下划线变量名，Python对未使用变量的约定)来捕获每个等级的元组中的第一个条目，并在计算total_weight时忽略它。

​		此代码的问题是元组实例是位置性的。例如,如果需要关于一个年级的更多信息,比如一组老师的笔记, 这就需要重写每个对two-tuple使用。现在有三个项目而不是两个,这意味着我需要使用_进一步忽略某些索引:

```python
grades = []
grades.append((95, 0.45, 'Great job'))
grades.append((85, 0.55, 'Better next time'))
total = sum(score * weight for score, weight, _ in grades)
total_weight = sum(weight for _, weight, _ in grades)
average_grade = total / total_weight
```

​		这种不断扩展元组的模式类似于加深字典层。一旦发现超过了二元组，就该考虑另一种方法了。

​		这时内置模块collections中的namedtuple类型完全完成了在这种情况下所需要的：它可以很容易地定义微小的、不可变的数据类:

~~~python
from collections import namedtuple
Grade = namedtuple('Grade', ('score', 'weight'))
~~~

​		这些类可以用位置或关键字参数来构造。这些字段可以通过命名属性访问。有了命名属性，以后如果需求再次发生变化，比如需要在简单数据容器中支持可变性或行为，就可以很容易地从命名元组转移到类。

***

**namedtuple的限制性**

​		尽管在很多场合下namedtuple是适用的，但是理解他的机制百利无一害：

* 不能为命名元组类指定默认参数值。当数据可能有许多可选属性时，这会使它们变得笨拙。如果发现自己使用了很多属性，那么使用内置的数据类模块可能是更好的选择
* namedtuple实例的属性值仍然可以使用数值索引和迭代访问。特别是在外部化的api中，这可能会导致无意的使用，从而使以后转移到真正的类变得更加困难。如果不能控制namedtuple实例的所有使用，最好是显式定义一个新类

***

​		接下来，可以编写一个类来表示包含一组分数的单一科目：

~~~python
class Subject:
    def __init__(self):
        self._grades = []
        
    def report_grade(self, score, weight):
        self._grades.append(Grade(score, weight))
        
    def average_grade(self):
        total, total_weight = 0, 0
        for grade in self._grades:
            total += grade.score * grade.weight
            total_weight += grade.weight
        return total / total_weight
~~~

​		然后，我写一个类来代表一个学生正在学习的一组主题：

~~~python
class Student:
    def __init__(self):
        self._subjects = defaultdict(Subject)
        
    def get_subject(self, name):
        return self._subjects[name]
    
    def average_grade(self):
        total, count = 0, 0
        for subject in self._subjects.values():
            total += subject.average_grade()
            count += 1
        return total / count
~~~

​		最后，我将为所有学生编写一个容器，根据他们的名字动态键入：

~~~python
class Gradebook:
    def __init__(self):
        self._students = defaultdict(Student)
    
    def get_student(self, name):
        return self._students[name]
~~~

​		这些类的行数几乎是以前实现大小的两倍。但是这个代码更容易阅读。驱动这些类的示例也更清晰和可扩展:

~~~python
book = Gradebook()
albert = book.get_student('Albert Einstein')
math = albert.get_subject('Math')
math.report_grade(75, 0.05)
math.report_grade(65, 0.15)
math.report_grade(70, 0.80)
gym = albert.get_subject('Gym')
gym.report_grade(100, 0.40)
gym.report_grade(85, 0.60)
print(albert.average_grade())
>>>
80.25
~~~

​		也可以编写向后兼容的方法来帮助将旧API风格的使用迁移到新的对象层次结构中。

**要点**

* 避免使用字典、长元组或其他内置类型的复杂嵌套的值创建字典
* 在需要一个完整类的灵活性之前，使用namedtuple作为轻量级的、不可变的数据容器
* 当内部状态字典变得复杂时，将存储方式改为使用多个类

## 第38条 对于简单接口，使用函数而不是类

​		许多Python内置API允许通过传入函数来实现定制功能。在运行时，API能够通过hooks调用我们的代码。例如，列表类型的sort方法接受一个可选的key参数，用于确定我们基于哪个参数排序(参见第14条)。在这里，通过提供len内置函数作为key钩子，根据它们的长度对名称列表进行排序:

~~~python
names = ['Socrates', 'Archimedes', 'Plato', 'Aristotle']
names.sort(key=len)
print(names)
>>>
['Plato', 'Socrates', 'Aristotle', 'Archimedes']
~~~

​		在其他语言中，可能会使用抽象类定义hooks。在Python中，许多hooks只是带有定义好的参数和放回值的无状态函数。函数是hooks的最佳选择，因为他们比类更加容易描述和定义。函数像hooks一样工作，因为python有first-class函数：函数和方法可以像语言中的任何其他值一样被传递和引用。

​		例如，假设像定制defaultdict类的行为(参见第17条)。这类数据结构允许提供一个函数，在每次访问丢失的键时，不需要提供参数而直接调用该函数。函数必须放回字典中确实的键应有的默认值。在这里，定义一个hooks，用它来记录每一个键丢失的时间，并未默认值放回0：

~~~python
def log_missing():
    print('Key added')
    return 0
~~~

​		给定一个初始字典和一组所需的增量，可以导致log_missing函数运行并打印两次(用于'red'和'orange'):

~~~python
from collections import defaultdict


def log_missing():
    print('Key added')
    return 0


current = {'green': 12, 'blue': 3}
increments = [
    ('red', 5),
    ('blue', 17),
    ('orange', 9),
]
result = defaultdict(log_missing, current)
print('Before:', dict(result))
for key, amount in increments:
    result[key] += amount
print('After: ', dict(result))
>>>
Before: {'green': 12, 'blue': 3}
Key added
Key added
After:  {'green': 12, 'blue': 20, 'red': 5, 'orange': 9}
~~~

​		提供像log_missing这样的函数使得API易于构建和测试，因为它将副作用从确定性行为中分离出来。例如，假设想在想要传递给defaultdict的默认值hooks来计算丢失值的总数。实现这一点的一种方法是使用闭包(参见第21条)。这里，定义一个helper函数，它使用这样一个闭包作为默认hooks：

~~~python
def increment_with_report(current, increments):
    added_count = 0
    def missing():
        nonlocal added_count # Stateful closure
        added_count += 1
        return 0
    result = defaultdict(missing, current)
    for key, amount in increments:
    	result[key] += amount
    return result, added_count
~~~

​		运行这个函数会产生预期的结果(2),即使defaultdict并不知道丢失的hook保持了状态。接口接受简单函数的另一种好处是，通过在闭包中隐藏状态，可以很容易的在以后添加功能：

~~~python
from collections import defaultdict


def log_missing():
    print('Key added')
    return 0


def increment_with_report(current, increments):
    added_count = 0

    def missing():
        nonlocal added_count  # Stateful closure
        added_count += 1
        return 0

    result = defaultdict(missing, current)
    for key, amount in increments:
        result[key] += amount
    return result, added_count


current = {'green': 12, 'blue': 3}
increments = [
    ('red', 5),
    ('blue', 17),
    ('orange', 9),
]
result, count = increment_with_report(current, increments)
print(result, count)
>>>
defaultdict(<function increment_with_report.<locals>.missing at 0x000001D36D78F8B0>, {'green': 12, 'blue': 20, 'red': 5, 'orange': 9}) 2

~~~

​		为有状态hook定义闭包的问题是，它比无状态函数的例子更难读。另一种方法是吧要跟踪的状态定义成一个小累：

~~~python
class BetterCountMissing:
    def __init__(self):
        self.added = 0

    def __call__(self):
        self.added += 1
        return 0

~~~

​		在其他语言中，能会希望修改defaultdict以适应CountMisssing类接口。但是在python中，由于有了first-class，就可以直接在对象中引用CountMisssing.missig方法，并把它作为参数传递给defaultdict的hook默认值。让一个对象实例的方法满足函数接口是很简单的：

~~~python
counter = CountMissing()
result = defaultdict(counter.missing, current) # Method ref
for key, amount in increments:
	result[key] += amount
assert counter.added == 2
~~~

​		使用这样的helper类来提供有状态闭包的行为比使用increment_with_report函数更清晰，如上所述。

​		然而，有时候，CounMissing类的目的并不那么明显。谁构建了CountMIssing对象呢？谁又调用了missing方法呢？未来的话，这个类是否还需要添加新的公用方法？在看到它在defaultdict中的用法之前，这个类是一个谜。

​		为了让这弄清楚这些问题，Python允许类定义--call--特殊方法。--call--方法允许像调用函数一样调用对象。它还会允许像调用函数一样调用对象。它还会导致内置函数对这样的实例返回True，就想普通函数或方法一样。所有可以以这种方式执行的对象都可以称为可调用对象。

~~~python
class BetterCountMissing:
    def __init__(self):
        self.added = 0

    def __call__(self):
        self.added += 1
        return 0
counter = BetterCountMissing()
assert counter() == 0
assert callable(counter)

~~~

​		这里，使用BetterCountMissing实例作为defaultdict的默认值钩子来跟踪添加的缺失键的数量:

~~~python
counter = BetterCountMissing()
result = defaultdict(counter, current) # Relies on __call__
for key, amount in increments:
	result[key] += amount
assert counter.added == 2
~~~

​		这就比CountMissing.missing这个例子要清晰多了。这里 的--call--方法表名类对象也可以作为函数的参数(例如API钩子)。它将代码的新读者引向负责类的主要行为的入口点。它也表明类就是像有状态闭包一样被调用。

​		最好的是，但使用--call--时，defaultdict仍然不知道发生了什么。defaultdict所需要的知识一个默认值钩子的函数。Python提供了许多不同的方法满足一个简单的函数接口，可以选择合适的满足工作需求。

**要点**

* 在Python中，通常可以简单地将函数用于组件之间的简单接口，而不是定义和实例化类
* Python中对函数和方法的因为是first-class，这意味着他们可以在表达式中使用(像任何其他类型一样)
* 特殊的--call--方法使得类的实例可以像普通Python函数一样被调用
* 当需要一个函数维护状态时，考虑定义一个含有--call--方法的类，而不是顶一个有状态的闭包

## 第39条 使用@classmethod多态性构造泛型对象

​		在python中，不仅对象支持多态性，类也支持。这意味着什么呢?这又有什么好处呢？

​		多态性允许层次结构中的多个类实现它们自己的方法版本。这意味着许多类可以实现相同的接口或抽象基类，同时提供不同的功能(参见第43条)。

​		例如，假如需要一个MapReduce实现，并且想要一个公共类表示输入数据。这里，定义一个这样的类，其read方法必须由子类定义：

```python
class InputData:
    def read(self):
        raise NotImplementedError
```

​		还有一个具体的InputData子类，它从磁盘上的文件中读取数据：

~~~python
class PathInputData(InputData):
    def __init__(self, path):
        self.path = path

    def read(self):
        with open(self.path) as f:
            return f.read()
~~~

​		InputData可以有很多像PathInputData的子类，并且他们都可以实现标准接口read，用来读取数据到进程中。其他InputData子类也可以从网络中读取数据、显式地解压数据等等。

​		例如，MapReduce需要提供一个类似的抽象接口，以一种标准的方式输入数据：

~~~python
class Worker:
    def __init__(self, input_data):
        self.input_data = input_data
        self.result = None
    def map(self):
    	raise NotImplementedError
    def reduce(self, other):
    	raise NotImplementedError

~~~

​		这里定义一个Worker的具体子类，一个行计数器：

~~~python
class LineCountWorker(Worker):
    def map(self):
        data = self.input_data.read()
        self.result = data.count('\n')

    def reduce(self, other):
        self.result += other.result
~~~

​		看起来这个实现很好，但是遇到了最大的障碍了。是什么把这些联系起来的？有一组很好的类、还有各种合理的抽象接口，但只有在构建对象时才能用。什么负责构建对象和编排MapReduce呢？

​		最简单的方法是手动构建并使用一些辅助函数连接对象。这里，列出了一个目录的内容，并未它包含的每个文件构造了一个PathInputData实例：

~~~python
import os


def generate_inputs(data_dir):
    for name in os.listdir(data_dir):
        yield PathInputData(os.path.join(data_dir, name))
~~~

​		接下来，使用generate_inputs返回的InputData实例来创建LineCountWorker实例:

```python
def create_workers(input_list):
    workers = []
    for input_data in input_list:
        workers.append(LineCountWorker(input_data))
    return workers
```

​		我通过将map步骤展开到多个线程来执行这些Worker实例(参见第53条)。然后反复调用reduce，将结果合并为一个最终值:

~~~python
from threading import Thread


def execute(workers):
    threads = [Thread(target=w.map) for w in workers]
    for thread in threads: thread.start()
    for thread in threads: thread.join()
    first, *rest = workers
    for worker in rest:
        first.reduce(worker)
    return first.result
~~~

​		最终，可把每一片通过一个函数联系起来来一步步的运行:

~~~python
def mapreduce(data_dir):
    inputs = generate_inputs(data_dir)
    workers = create_workers(inputs)
    return execute(workers)

~~~

​		在一组测试输入文件上运行这个函数效果很好:

~~~python
import os
import random


def write_test_files(tmpdir):
    os.makedirs(tmpdir)
    for i in range(100):
        with open(os.path.join(tmpdir, str(i)), 'w') as f:
            f.write('\n' * random.randint(0, 100))


tmpdir = 'test_inputs'
write_test_files(tmpdir)
result = mapreduce(tmpdir)
print(f'There are {result} lines')
>>>
There are 4360 lines
~~~

​		这样写的问题是什么呢？这样写的最大问题就是MapReduce函数并不通用。如果想写另外一个InputData或者Worker子类，必须要重写generate_inputs、create_workers子类才能和MapReduce方法搭配。

​		这个问题归结为需要一个通用的方法来构建对象。其他语言中，可以使用构造函数多态性来解决这个问题，要求每个inputdata子类提供一个特殊的构造函数，用于编排MapReduce(类似于工厂模式)的辅助函数。

​		问题是Python只允许一个构造函数--init--。要求每个inputdata子类都有一个兼容的构造函数是不合理的。

​		解决这个问题的最好方法是使用类方法的多态性。这于在inputdata.read多态性一样，除非它是针对整个类而不是他们的构造对象。

​		把这种方法运用在在MapReduce类上。这里，使用泛型对象@classmethod扩展inputdata类，该方法负责使用公共接口创建心得inputdata实例;

~~~python
class GenericInputData:
    def read(self):
    	raise NotImplementedError
        
    @classmethod
    def generate_inputs(cls, config):
    	raise NotImplementedError

~~~

​		让generate_inputs接受一个字典，其中包含genericinputdata的子类需要接受的参数。这里，使用config来查找要列出输入文件的目录：

~~~python
class PathInputData(GenericInputData):
    ...
    @classmethod
    def generate_inputs(cls, config):
    	data_dir = config['data_dir']
        for name in os.listdir(data_dir):
            yield cls(os.path.join(data_dir, name))

~~~

​		类似的，可以使用create_workers函数成为genericworker类的一部分。这里，使用input_class参数(它必须是genericinputdata的一个子类)来生成必要的输入。我通过使用cls()作为泛型构造函数来构造genericworker具体子类的实例。

~~~python
class GenericWorker:
    def __init__(self, input_data):
        self.input_data = input_data
        self.result = None
        
    def map(self):
    	raise NotImplementedError
        
    def reduce(self, other):
    	raise NotImplementedError
        
    @classmethod
    def create_workers(cls, input_class, config):
        workers = []
        for input_data in input_class.generate_inputs(config):
            workers.append(cls(input_data))
            return workers
~~~

​		要注意对input_class的调用。上面的generate_inputs就是要展示的类多态。除了使用--init--方法之外，可以看到create_workers调用cls()提供另一种构造genericworker对象的方法。

​		这对genericworker子类的影响只是改变了它的父类：

~~~python
class LineCountWorker(GenericWorker):
	...
~~~

​		最终可以通过调用create_workers方法来重写MapReduce，使其变得完全通用：

~~~python
def mapreduce(worker_class, input_class, config):
workers = worker_class.create_workers(input_class,
config)
	return execute(workers)
~~~

​		在一组测试文件上运行新的worker会产生于旧的实现效果相同的结果。区别在于MapReduce函数需要更多的参数，因为这样它才可以泛型操作。

~~~python
config = {'data_dir': tmpdir}
result = mapreduce(LineCountWorker, PathInputData, config)
print(f'There are {result} lines')
>>>
There are 4360 lines
~~~

​		现在，我可以按自己的意愿编写其他GenericInputData和GenericWorker子类，而不必重写任何粘合代码。

**要点**

* Python只支持每个类拥有一个构造方法--init--
* 使用@classmethod为类定义替代构造函数
* 使用类方法多态提供构建和连接许多具体子类的泛型方法

## 第40条 使用super关键字初始化父类

​		以前，在子类中初始化父类的最简单的方式是直接用子类实例调用父类的--init--方法：

~~~python
class MyBaseClass:
    def __init__(self, value):
    	self.value = value
class MyChildClass(MyBaseClass):
    def __init__(self):
    	MyBaseClass.__init__(self, 5)
~~~

​		这种方法适用于基本的类层次结构，但是在很多情况下会出现问题。

​		如果一个类受到多重继承的影响(这通常是要避免的，参见第41条)，直接调用超类的--init--方法可能会导致出现一些不可预知的情况。

​		其中一个问题是，--init--方法没有在所有子类中指定。例如，这里定义两个父类。他们操作实例的值字段：

~~~python
class TimesTwo:
	def __init__(self):
        self.value *= 2
class PlusFive:
    def __init__(self):
        self.value += 5
~~~

​		这个类以一个顺序定义它的父类：

~~~python
class OneWay(MyBaseClass, TimesTwo, PlusFive):
    def __init__(self, value):
        MyBaseClass.__init__(self, value)
        TimesTwo.__init__(self)
        PlusFive.__init__(self)
~~~

​		构造它会产生一个与父类顺序匹配的结果：

~~~python
foo = OneWay(5)
print('First ordering value is (5 * 2) + 5 =', foo.value)
>>>
First ordering value is (5 * 2) + 5 = 15

~~~

​		这里另一个类以不同的顺序定义相同的父类(PlusFive后面跟着timesttwo，而不是相反的顺序)：

~~~python
class AnotherWay(MyBaseClass, PlusFive, TimesTwo):
    def __init__(self, value):
        MyBaseClass.__init__(self, value)
        TimesTwo.__init__(self)
        PlusFive.__init__(self)
~~~

​		然而，这个类中调用父类MyBaseClass.--init--、TimesTwo.--init--、PlusFive.--init--的顺序与OneWay类中相同，这意味着该类的行为与其定义中的父类顺序不匹配。继承积累和--init--调用之间的冲突很难发现，这使得代码很难理解：

~~~python
bar = AnotherWay(5)
print('Second ordering value is', bar.value)
>>>
Second ordering value is 15
~~~

​		菱形继承(Diamond Inheritance)还会出现另一个问题。当一个子类从两个具有相同超类且层次结构相同的独立类继承时，就会出现D菱形继承问题。菱形继承会导致公共超类的--init--方法多次运行，这将会导致奇怪的问题。例如，这里定义两个继承自MyBaseClass的子类：

~~~python
class TimesSeven(MyBaseClass):
    def __init__(self, value):
        MyBaseClass.__init__(self, value)
        self.value *= 7
class PlusNine(MyBaseClass):
    def __init__(self, value):
        MyBaseClass.__init__(self, value)
        self.value += 9

~~~

​		之后，定义一个继承自这两个类的子类，使MyBaseClass成为菱形的顶端：

```python
class ThisWay(TimesSeven, PlusNine):
    def __init__(self, value):
        TimesSeven.__init__(self, value)
        PlusNine.__init__(self, value)
foo = ThisWay(5)
print('Should be (5 * 7) + 9 = 44 but is', foo.value)
>>>
Should be (5 * 7) + 9 = 44 but is 14
```

​		这种方式在调用第二个类PlusNine的--init--方法时，由于首先调用了TimsSeven类，这两个类都调用了同一个父类MyBaseClass，当MyBaseClass第二次被调用时，该类的self.value会被第一次调用时重置为5.所以最终的计算结果为self.value的值为5 即5 + 9 = 14，这种方式完全忽略了TimesSeven.--init--对值的影响。这种调用方法获取到的结果很意外，并且这种错误在大多数情况下很难调试出来。

​		为了解决这个问题，Python提供了内置的super函数，这是一个标准方法解析顺序(MRO)。super方法能够确保超类在菱形继承中只运行一次(参见，第48条)。MRO定义了超类初始化的顺序，遵循一种称为C3线性化的算法。

​		这里，再次创建一个菱形结构的类层器，但这次使用super初始化父类：

~~~python
class TimesSevenCorrect(MyBaseClass):
    def __init__(self, value):
        super().__init__(value)
        self.value *= 7
        
        
class PlusNineCorrect(MyBaseClass):
    def __init__(self, value):
        super().__init__(value)
        self.value += 9
~~~

​		现在，菱形结构的顶部，MyBaseClass.--inti--方法只运行一次。其他父类按照class定义时的顺序运行：

~~~python
class GoodWay(TimesSevenCorrect, PlusNineCorrect):
    def __init__(self, value):
        super().__init__(value)
foo = GoodWay(5)
>>>
Should be 7 * (5 + 9) = 98 and is 98
~~~

​		这个顺序看起来可能会很落后。不应该是TimesSevenCorrect.--init--最先运行么？结果不应该是 (5 * 7) + 9 == 44么？答案显而易见不是。这里的顺序是与MRO规则定义的类的顺序像匹配。MRO排序可以在一个叫做MRO的类方法上使用：

~~~python
mro_str = '\n'.join(repr(cls) for cls in GoodWay.mro())
print(mro_str)
>>>
<class '__main__.GoodWay'>
<class '__main__.TimesSevenCorrect'>
<class '__main__.PlusNineCorrect'>
<class '__main__.MyBaseClass'>
<class 'object'>

~~~

​		当我调用GoodWay(5)时，依次调用TimesSevenCorrect.--init--、PlusNineCorrect.--init--、MyBaseClass.--init--。一旦到达菱形顶部，所有的初始化方法实际上都以与他们的--init--方法调用顺序相反。MyBaseClass.--init--赋给初始值5，PlusNineCorrec.--init--添加9使值等于14，TimesSevenCorrect.--init--乘以7使value等于98。

​		调用super().--init--方法除了能让多重继承更加健壮之外，也比直接在子类中调用MyBaseClass.--init--更加易于维护。可以稍后将MyBaseClass重命名，或让TimesSevenCorrect 和 PlusNineCorrect类从另一个超类继承，而不必再通过更新他们的--init--方法来匹配顺序。

​	super函数也可以通过两个参数来调用：第一个是按照MRO顺序要访问的类的类型，第二个是要访问该视图的实例。在构造函数中这些可选参数如下所示：

```python
class ExplicitTrisect(MyBaseClass):
    def __init__(self, value):
        super(ExplicitTrisect, self).__init__(value)
        self.value /= 3
```

​		然而，这些参数在对象实例初始化时不是必要的。python的编译器会自动提供正确的形参(--class--和self)，我们通过super继承父类时并不需要提供形参。这意味着这三种用法是等价的:

~~~python
class AutomaticTrisect(MyBaseClass):
    def __init__(self, value):
        super(__class__, self).__init__(value)
        self.value /= 3
class ImplicitTrisect(MyBaseClass):
    def __init__(self, value):
    	super().__init__(value)
		self.value /= 3
assert ExplicitTrisect(9).value == 3
assert AutomaticTrisect(9).value == 3
assert ImplicitTrisect(9).value == 3

~~~

​		只有在需要从子类访问超类实现的特定功能(例如，包装或重用功能)的情况下，才应该向super提供参数。

**要点**

* Python的标准方法解析顺序(MRO)解决了超类初始化顺序和菱形继承问题
* 使用零参数的内置super函数来初始化父类

